<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Mosquitto原理与实践</title>
    <link href="/Wuhlan3/2023/02/10/MQTT%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <url>/Wuhlan3/2023/02/10/MQTT%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1>Mosquitto-test</h1><h2 id="一、运行方式">一、运行方式</h2><p>打开三个终端</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">mosquitto broker:</span>./mosquitto -c mosquitto.conf -v<span class="hljs-meta">#</span><span class="bash">mosquitto sub:</span>./mosquitto_sub -h localhost -t "hello" -i "sub1"<span class="hljs-meta">#</span><span class="bash">mosquitto pub:</span>./mosquitto_pub -h localhost -t "hello" -m "hello,world" -i "pub"</code></pre><h2 id="二、常用参数说明">二、常用参数说明</h2><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-h</td><td>服务器主机，默认localhost</td></tr><tr><td>-t</td><td>指定主题</td></tr><tr><td>-u</td><td>用户名</td></tr><tr><td>-P</td><td>密码</td></tr><tr><td>-i</td><td>客户端id，唯一</td></tr><tr><td>-m</td><td>发布的消息内容</td></tr></tbody></table><h2 id="三、Bug-Warning">三、Bug/Warning</h2><ol><li><p><code>Warning: Mosquitto should not be run as root/administrator.</code></p><p>最好不要以root的身份来运行Mosquitto代理，可以换一个用户，如<code>Wuhlan</code>，同时mosquitto.config里的<code>user root</code>也要修改为<code>user Wuhlan</code></p></li><li><p><code>Library /lib/libmosquittopp.so can not find symbol: _ZdlPvj</code></p><p>编译成功，运行失败。这个报错大概的意思应该是libmosquittopp.so找不到入口，导致的原因是我在配置链接方式的时候，多链接了这个库。</p></li></ol><h2 id="四、MQTT的基本原理">四、MQTT的基本原理</h2><p>MQTT 是一个轻量级协议，使用基于 TCP/IP 协议的发布/订阅消息转发模式，在物联网应用中大规模使用。以Broker代理服务器作为中转站，客户端之间通过消息订阅和推送的方式来进行通信。如下图所示：</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/MQTT%E5%8E%9F%E7%90%86%E5%9B%BE.drawio.png" alt="MQTT原理"></p><p>mosquitto结构体，它保存了客户端连接broker的相关参数。如下所示：</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mosquitto</span> {</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> WIN32</span>    <span class="hljs-keyword">int</span> sock; <span class="hljs-comment">/*服务器程序与该客户端连接通信所用的socket描述符*/</span><span class="hljs-meta">#  <span class="hljs-meta-keyword">ifndef</span> WITH_BROKER</span>    <span class="hljs-keyword">int</span> sockpairR, sockpairW;<span class="hljs-meta">#  <span class="hljs-meta-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>    SOCKET sock;<span class="hljs-meta">#  <span class="hljs-meta-keyword">ifndef</span> WITH_BROKER</span>    SOCKET sockpairR, sockpairW;<span class="hljs-meta">#  <span class="hljs-meta-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-keyword">enum</span> _mosquitto_protocol protocol;    <span class="hljs-keyword">char</span> *address;<span class="hljs-comment">/*该客户端的IP地址*/</span>    <span class="hljs-keyword">char</span> *id;<span class="hljs-comment">/*该客户端登陆mosquitto程序时所提供的ID值，该值与其他的客户端不能重复*/</span>    <span class="hljs-keyword">char</span> *username;<span class="hljs-comment">/*登录用户名*/</span>    <span class="hljs-keyword">char</span> *password;<span class="hljs-comment">/*密码*/</span>    <span class="hljs-keyword">uint16_t</span> keepalive;<span class="hljs-comment">/*该客户端需在此时间内向mosquitto服务器程序发送一条ping/ping消息*/</span>    <span class="hljs-keyword">uint16_t</span> last_mid;    <span class="hljs-keyword">enum</span> mosquitto_client_state state;    <span class="hljs-keyword">time_t</span> last_msg_in;<span class="hljs-comment">/*last_msg_in和last_msg_out用于记录上次收发消息的时间*/</span>    <span class="hljs-keyword">time_t</span> last_msg_out;    <span class="hljs-keyword">time_t</span> <span class="hljs-keyword">ping_t</span>;    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">mosquitto_packet</span> <span class="hljs-title">in_packet</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">mosquitto_packet</span> *<span class="hljs-title">current_out_packet</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">mosquitto_packet</span> *<span class="hljs-title">out_packet</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mosquitto_message</span> *<span class="hljs-title">will</span>;</span>        ...    <span class="hljs-keyword">bool</span> want_write;    <span class="hljs-keyword">bool</span> want_connect;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(WITH_THREADING) &amp;&amp; !defined(WITH_BROKER)</span>    <span class="hljs-keyword">pthread_mutex_t</span> callback_mutex;    <span class="hljs-keyword">pthread_mutex_t</span> log_callback_mutex;    <span class="hljs-keyword">pthread_mutex_t</span> msgtime_mutex;    <span class="hljs-keyword">pthread_mutex_t</span> out_packet_mutex;    <span class="hljs-keyword">pthread_mutex_t</span> current_out_packet_mutex;    <span class="hljs-keyword">pthread_mutex_t</span> state_mutex;    <span class="hljs-keyword">pthread_mutex_t</span> in_message_mutex;    <span class="hljs-keyword">pthread_mutex_t</span> out_message_mutex;    <span class="hljs-keyword">pthread_t</span> thread_id;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-keyword">bool</span> clean_session;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> WITH_BROKER</span>    <span class="hljs-keyword">bool</span> is_dropping;    <span class="hljs-keyword">bool</span> is_bridge;    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">mqtt3_bridge</span> *<span class="hljs-title">bridge</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mosquitto_client_msg</span> *<span class="hljs-title">msgs</span>;</span><span class="hljs-comment">/*用于暂时存储发往该context的消息。*/</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mosquitto_client_msg</span> *<span class="hljs-title">last_msg</span>;</span>    <span class="hljs-keyword">int</span> msg_count;    <span class="hljs-keyword">int</span> msg_count12;    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">mosquitto_acl_user</span> *<span class="hljs-title">acl_list</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">mqtt3_listener</span> *<span class="hljs-title">listener</span>;</span>    <span class="hljs-keyword">time_t</span> <span class="hljs-keyword">disconnect_t</span>;    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">mosquitto_packet</span> *<span class="hljs-title">out_packet_last</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">mosquitto_subhier</span> **<span class="hljs-title">subs</span>;</span>    <span class="hljs-keyword">int</span> sub_count;    <span class="hljs-keyword">int</span> pollfd_index;...};</code></pre><p>常用的相关函数如下：</p><table><thead><tr><th>函数名称</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>mosquitto_lib_init()</td><td>使用mosquitto库的函数前，要先进行初始化</td><td></td></tr><tr><td>mosquitto_lib_cleanup()</td><td>使用完mosquitto库的函数后，要进行相关的清除操作</td><td></td></tr><tr><td>mosquitto_new()</td><td>创建一个新的mosquitto客户端实例，使用完后一定要使用mosquitto_destroy()释放相关内存</td><td>id需要设置一下，否则可能出现意想不到的错误。设置为 true 可指示代理在断开连接时清除所有消息和订阅，设置为 false 以指示代理保留它们。</td></tr><tr><td>mosquitto_destroy()</td><td>用于释放与 mosquitto 客户端实例关联的内存</td><td></td></tr><tr><td>mosquitto_connect_callback_set()</td><td>设置连接回调。当代理发送 CONNECCT ACK 消息以响应连接时，将调用此消息</td><td>第二个参数为回调函数</td></tr><tr><td>mosquitto_disconnect_callback_set()</td><td>设置断开连接回调。当代理收到断开连接命令并断开客户端连接时，将调用此选项</td><td>第二个参数为回调函数</td></tr><tr><td>mosquitto_publish_callback_set()</td><td>设置发布回调。当使用 mosquitto_publish 启动的消息已成功发送到代理时，将调用此选项</td><td>第二个参数为回调函数</td></tr><tr><td>mosquitto_subscribe_callback_set()</td><td>设置订阅回调。当代理响应订阅请求时，将调用此函数</td><td>第二个参数为回调函数</td></tr><tr><td>mosquitto_message_callback_set()</td><td>设设置消息回调。当从代理接收到消息时，将调用此函数</td><td>第二个参数为回调函数</td></tr><tr><td>mosquitto_loop_forever()</td><td>此函数在无限阻塞循环中调用 loop（）。对于只想在程序中运行 MQTT 客户机循环的情况，它非常有用。它处理服务器连接丢失时的重新连接。如果在回调中调用 mosquitto_disconnect（），它将返回</td><td></td></tr><tr><td>mosquitto_loop_start()</td><td>网络事件循环处理函数，客户端通过创建新的线程不断调用mosquitto_loop()函数来处理网络事件，该函数<strong>非阻塞</strong></td><td></td></tr><tr><td>mosquitto_loop_stop()</td><td>这是线程化客户端接口的一部分。调用此命令一次以停止以前使用mosquitto_loop_start创建的网络线程。此调用将<strong>阻塞</strong>，直到网络线程完成。要结束网络线程，必须先前调用 mosquitto_disconnect 或已将 force 参数设置为 true</td><td></td></tr></tbody></table><h2 id="五、参考资料">五、参考资料</h2><p>[1] <a href="https://blog.csdn.net/qq_57398262/article/details/124231147">mosquitto库常用的相关函数解析</a></p><p>[2] <a href="https://blog.csdn.net/Dancer__Sky/article/details/77855249?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-6-77855249-blog-123193183.pc_relevant_aa2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-6-77855249-blog-123193183.pc_relevant_aa2&amp;utm_relevant_index=7">基于MQTT协议的Mosquitto的使用及libmosquitto客户端编程</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关键字static</title>
    <link href="/Wuhlan3/2022/09/14/%E5%85%B3%E9%94%AE%E5%AD%97static/"/>
    <url>/Wuhlan3/2022/09/14/%E5%85%B3%E9%94%AE%E5%AD%97static/</url>
    
    <content type="html"><![CDATA[<h1>关键字static</h1><blockquote><p>最近的面试都有涉及到，所以来深入汇总一下它的特点</p></blockquote><ol><li>三大特性</li><li>生命周期</li><li>作用范围</li><li>类中的特点</li></ol><h2 id="1-三大特性">1. 三大特性</h2><h4 id="1-1-隐藏">1.1 隐藏</h4><blockquote><p>const关键字也和static一样，有隐藏的作用。仅作用于本文件，避免同名的冲突。</p></blockquote><p>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</p><h4 id="1-2-初始化为0">1.2 初始化为0</h4><p>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。</p><h4 id="1-3-持久化">1.3 持久化</h4><p>（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在<strong>静态存储区</strong>：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。</p><h2 id="2-生命周期">2. 生命周期</h2><ul><li><strong>非静态局部变量</strong>的生命周期是：进入作用域生命周期开始，出作用域生命周期结束</li><li><strong>全局变量</strong>和<strong>静态变量</strong>的生命周期是：整个程序的生命周期</li></ul><table><thead><tr><th>生命周期</th><th>无static</th><th>有static</th></tr></thead><tbody><tr><td>局部变量</td><td>进入作用域生命周期开始，出作用域生命周期结束</td><td>整个程序的生命周期</td></tr><tr><td>全局变量</td><td>整个程序的生命周期</td><td>整个程序的生命周期</td></tr><tr><td>类中成员变量</td><td>每个对象都有一份拷贝</td><td>属于整个类所有，所有对象只有一份拷贝</td></tr></tbody></table><h2 id="3-作用范围">3. 作用范围</h2><ul><li>静态与非静态局部变量限制在局部范围内，</li><li>非静态全局变量作用于整个工程，静态全局变量作用于当前文件；</li><li>非静态函数，可在其他文件中引用；静态函数只能在当前文件中使用</li></ul><table><thead><tr><th>作用范围</th><th>无static</th><th>有static</th></tr></thead><tbody><tr><td>局部变量</td><td>局部范围</td><td>局部范围</td></tr><tr><td>全局变量</td><td>整个工程</td><td>当前文件</td></tr><tr><td>函数</td><td>可在其他文件中引用</td><td>仅在当前文件中使用</td></tr><tr><td>类成员变量</td><td>与对象绑定</td><td>可直接调用，不需要new一个对象</td></tr><tr><td>类成员函数</td><td>与对象绑定</td><td>可直接调用，不需要new一个对象</td></tr></tbody></table><h2 id="4-类中的static其他特性">4. 类中的static其他特性</h2><ol><li>static<strong>类成员变量</strong>必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；</li><li>由于static修饰的<strong>类成员函数</strong>属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。<strong>正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员</strong>；非static函数，既可以访问非static成员也可以访问static成员</li><li>static<strong>类成员函数</strong>不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，<code>this-&gt;vptr-&gt;ctable-&gt;virtual function</code></li></ol><p>可以看一下static典型的使用例子，饿汉式的单例模式：</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>{</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>{<span class="hljs-comment">//static成员函数只能够访问static成员变量</span>        <span class="hljs-keyword">return</span> &amp;s_instance;    }<span class="hljs-keyword">private</span>:    Singleton(){}    ~Singleton(){}    Singleton(<span class="hljs-keyword">const</span> Singleton &amp;) = <span class="hljs-keyword">delete</span>;   Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Singleton &amp;) = <span class="hljs-keyword">delete</span>;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">static</span> Singleton s_instance;};Singleton Singleton::s_instance;<span class="hljs-comment">//在程序入口之前就完成单例对象的初始化</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抖声项目汇总</title>
    <link href="/Wuhlan3/2022/08/07/%E6%8A%96%E5%A3%B0%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/Wuhlan3/2022/08/07/%E6%8A%96%E5%A3%B0%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1>抖声项目汇总</h1><p>单体架构仓库：<a href="https://github.com/Wuhlan3/dousheng">https://github.com/Wuhlan3/dousheng</a></p><p>微服务架构仓库：<a href="https://github.com/Wuhlan3/kitexdousheng">https://github.com/Wuhlan3/kitexdousheng</a></p><h2 id="一、简单介绍一下你的项目？">一、简单介绍一下你的项目？</h2><p>本项目的一些素材来源于字节跳动后端训练营，他们提供了一个抖声客户端，并且规范了可以实现的一些接口，包括用户登陆与注册、视频流、评论功能、点赞功能、关注功能等等。在训练营期间，我曾担任小组的队长，由于同小组有较多大一大二的同学，所以负责了该项目单体架构的设计、数据库表的设计、大部分接口的功能实现。最终该项目取得了较好的成绩。之后，我和舍友也尝试使用在青训营所学的知识，使用字节跳动的微服务架构KiteX框架来重新实现该项目，并且完善缓存机制、单元测试，完善了视频流的一些功能包括使用使用FFmpeg截取视频的封面、将视频通过存储桶来进行管理等等。</p><h2 id="二、你主要做了哪些工作呢？">二、你主要做了哪些工作呢？</h2><ol><li>项目的整体设计（这主要是参考了一下KiteX框架下提供的一个笔记服务的样例，参照其文件的架构设计的）</li><li>数据库的设计和ER图的绘制也是我做的；</li><li>较完善的参数校验，对密码进行加密，使用JWT鉴权；</li><li>视频流的相关实现计包括将视频和封面上传到腾讯云COS对象存储桶，使用FFmpeg截取视频的封面；</li><li>使用Redis来减少访问数据库的次数</li></ol><h2 id="三、本项目你遇到的最大困难是什么，如何解决的？">三、本项目你遇到的最大困难是什么，如何解决的？</h2><p>我认为本项目最复杂的、也是最有必要认真实现的模块就是视频流的设计。</p><ol><li>视频封面的获取，ffmpeg；</li><li>视频的存储方式——上传至腾讯云对象存储，并将对应的URL存放到数据库中（尝试过直接存储云服务器的本地文件夹中，但是由于带宽问题，且管理起来比较混乱，导致效果非常差）</li><li>Redis的设计，涉及到两种数据结构ZSET和HASH，其中ZSET保存了视频的id和发布的时间latestTime(作为score)。在获取视频流的时候，我们首先通过获取最近发布的30个视频，之后根据视频ID再从Redis中获取视频相应的信息；优化之后，通过压力测试可以发现，报文返回的速度从100ms提升到50ms。</li><li>但是发现真正的卡顿问题出现在视频文件的传输上，考虑到我的云服务器是比较小型的服务器，2核2G的，带宽也比较有限，所以我尝试将视频上传到云服务器上。</li><li>同时使用了ffmpeg对视频进行处理，包括格式的转换，视频封面的获取等等。</li><li>最终使得客户端程序在运行的情况体验比较正常</li></ol><h2 id="四、数据库表是如何设计的？">四、数据库表是如何设计的？</h2><p>主要涉及六张表，分别是user、relation、video、favorite、comment和publish。</p><p>其中，我认为最重要的两个实体是用户和视频，其他的表可以看作是这两者之间的关系。</p><p>用户表包括用户ID、账号、密码、关注数、被关注数等信息；</p><p>video表包括ID、视频封面的URL、视频URL、视频名称、上传者的ID、点赞数等信息；</p><p>…</p><p>此外，还对外键依赖、非空、唯一性等约束进行了设计。为了提高查询效率，适当的生成了索引。比如说，视频的上传者ID，点赞表中的 user_id和video_id作为联合索引。</p><h2 id="六、整体架构是怎么设计的？">六、整体架构是怎么设计的？</h2><p>使用了Gin框架来开放HTTP端口，通过封装好的RPC客户端与微服务中的服务端进行通信。</p><p>RPC服务端通过接收客户端的请求，在各自的进程中完成业务逻辑和数据库的交互。</p><p>数据库层面使用了Redis缓存机制，使用MySQL进行持久化。</p><p>序列化手段一般包括JSON、ProtoBuf、thrift等。抖声客户端与服务器的交互直接采用的JSON，而RPC通信过程中使用了ProtoBuf来进行序列化。</p><blockquote><p>JSON，ProtoBuf，thrift之间的区别是什么呢？</p><p>ProtoBuf无论是序列化和反序列化的速度，还是编码后的数据大小，都比JSON优秀很多，但是其可见性较差。因此在微服务之间通信时，protobuf 更合适，在公开 API 或与浏览器通信时JSON 与 xml 更合适。</p><p>protobuf与thrift的对比：</p><table><thead><tr><th></th><th>protobuf</th><th>thrift</th></tr></thead><tbody><tr><td>功能特性</td><td>主要是一种序列化机制</td><td>提供了全套RPC解决方案，包括序列化机制、传输层、并发处理框架等</td></tr><tr><td>支持语言</td><td>C++/Java/Python</td><td>C++, Java, Python, Ruby, Perl, PHP, C#, Erlang, Haskell</td></tr><tr><td>易用性</td><td>语法类似，使用方式等类似</td><td></td></tr><tr><td>生成代码的质量</td><td>可读性都还过得去，执行效率另测</td><td></td></tr><tr><td>升级时版本兼容性</td><td>均支持向后兼容和向前兼容</td><td></td></tr><tr><td>学习成本</td><td>功能单一，容易学习</td><td>功能丰富、学习成本高</td></tr><tr><td>文档&amp;社区</td><td>官方文档较为丰富，google搜索protocol buffer有2000W+结果，google group被墙不能访问</td><td>官方文档较少，没有API文档，google搜索apache thrift仅40W结果，邮件列表不怎么活跃</td></tr></tbody></table></blockquote><h2 id="七、微服务架构相比于单体架构，优点体现在哪里？">七、微服务架构相比于单体架构，优点体现在哪里？</h2><p>微服务架构的优点如下：</p><ol><li><strong>单一职责</strong>。每个服务都有自己独立的业务逻辑，是一个高内聚、低耦合、单一原则的单元。</li><li><strong>轻量级通信</strong>。服务之间用过轻量级的通信机制实现互联互通，通常是语言无关、平台无关的交互方式；</li><li><strong>独立性</strong>。每个服务可以独立地进行开发、测试和部署；</li><li><strong>进程隔离</strong>。每个服务高度自治，可以部署到不同的主机上。当其中一个服务挂掉时，不会影响其他服务。</li></ol><p>使用微服务的一个好处就是，不限定服务的提供方使用什么技术选型，能够实现公司跨团队的技术解耦。但是这样子，如果没有一个统一的服务框架——RPC框架，则各个团队需要各自实现一套序列化、反序列化、网络框架、连接池、收发线程、超时处理等业务之外的重复技术劳动。统一RPC框架将上述的劳动进行了统一处理。</p><h2 id="八、ETCD是什么？">八、ETCD是什么？</h2><p>ETCD是Go语言开发的一个开源的、高可用的分布式key-value存储系统。</p><p>微服务在ETCD注册中心中注册好自己的相关信息，之后api层可以通过ETCD来获取相应微服务的ip地址和端口号，从而发起RPC调用。</p><h2 id="九、有没有对该项目的性能进行测试？">九、有没有对该项目的性能进行测试？</h2><p>由于环境的限制，在两核2G的小型云服务器环境下，在30秒内5000个客户端的情况下，可以处理40000个请求。之后还会继续完善测试。</p><h2 id="十、JWT相关原理">十、JWT相关原理</h2><p>是作为中间件来使用的，大部分的HTTP接口都需要JWT校验通过之后，才能够进行下一步的业务逻辑处理。</p><p>JWT的实现原理：</p><ol><li>用户登录的时候，会将账号和密码发送给服务器；</li><li>服务器验证账号密码的有效性后，会返回签名后的token给客户端；</li><li>客户端将token存储在本地存储中</li><li>之后客户端的请求，都应该携带上token，服务端在对token解码之后，判断其解码的有效性，从而认证客户的身份。</li></ol><blockquote><p>签名的过程：</p><p>首先JWT的结构如下：</p><ul><li>头部：包含了基本信息；基于Base64编码规则</li><li>荷载：包含了签发者、用户、接收方、过期时间等等；基于Base64编码规则</li><li>签名：使用<strong>HS256算法</strong>来对（头部和荷载）进行加密。（作用是防止篡改）</li></ul></blockquote><h2 id="十一、RPC的原理">十一、RPC的原理</h2><p>参考：<a href="https://wuhlan3.gitee.io/wuhlan3/2022/08/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/">https://wuhlan3.gitee.io/wuhlan3/2022/08/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</a></p><h2 id="十二、Gin有什么特点？">十二、Gin有什么特点？</h2><ol><li>路由</li><li>context上下文，方便传递</li><li></li></ol><h2 id="十三、你的项目中使用到了什么设计模式？">十三、你的项目中使用到了什么设计模式？</h2><ol><li><p>在repository层使用了<strong>单例模式</strong>。比如说我们给UserDao绑定了Query、Update等方法，在每次调用的时候，我们都返回userDao这个单例对象，而避免重复生成，消耗额外的资源。（对于每个线程，可共享一个实例）</p></li><li><p>在service层，我们使用了<strong>简单工厂模式</strong>，比如说对于userlogin这个模块，我们定义了一个UserLoginFlow的对象，每次调用它的方法，我们首先要根据所需的参数new出这一个对象，之后做参数校验、逻辑处理等工作。简单工厂模式可以确保我们创建的实例具有需要的参数，进而保证实例的方法可以按预期执行</p><blockquote><ol><li><p>工厂类含有必要的判断逻辑,可以决定在什么时候创建哪一个产品类的实例,<strong>客户端可以免除直接创建产品对象的责任</strong>,而仅仅“消费”产品;</p></li><li><p>简单工厂模式通过这种做法实现了<strong>对责任的分割</strong>,它提供了专门的工厂类用于创建对象。</p></li><li><p>客户端无须知道所创建的具体产品类的类名,<strong>只需要知道具体产品类所对应的参数即可</strong>,对于一些复杂的类名,通过简单工厂模式可以<strong>减少使用者的记忆量</strong>。</p></li><li><p>通过引入配置文件,<strong>可以在不修改任何客户端代码的情况下更换和增加新的具体产品类</strong>,在一定程度上提高了系统的灵活性。</p></li></ol></blockquote></li></ol><h2 id="十四、代码行数">十四、代码行数</h2><pre><code class="hljs arduino"><span class="hljs-comment">//算上kitexgen自动生生成的有9218行</span><span class="hljs-built_in">find</span> . <span class="hljs-string">"("</span> -name <span class="hljs-string">"*.go"</span>  <span class="hljs-string">")"</span> -<span class="hljs-built_in">print</span> | xargs wc -l<span class="hljs-comment">//如果不算，有3702行</span><span class="hljs-built_in">find</span> cmd <span class="hljs-built_in">config</span> pkg <span class="hljs-string">"("</span> -name <span class="hljs-string">"*.go"</span>  <span class="hljs-string">")"</span> -<span class="hljs-built_in">print</span> | xargs wc -l</code></pre><h2 id="十五、怎么测试抖音">十五、怎么测试抖音</h2><blockquote><p>基本思路：</p><ol><li>回答功能层面的测试点（最重要的）</li><li>之后拓展到 UI测试、兼容性测试、易用性测试、可移植性测试、性能测试等等。</li></ol></blockquote><p>功能测试的中的概念就在于寻找输入口：</p><ol><li>上拉测试，视频是否加载、用户名称、title、点赞数、收藏数是否符合预期</li><li>下拉测试；</li><li>多次上拉，查看是否不同的视频</li><li>多次上拉，查看视频是否按照规定的顺序切换：（比如我的项目中采用的是上传时间）</li><li>点赞，查看点赞数是否增加；在关闭程序后，再次查看该视频，看点赞数是否持久化。</li><li>关注，测试过程与点赞类似。但是除了查看我的关注数是否增加外，还需要查看对方的页面，被关注数是否增加。同时还要查看关注和被关注列表</li><li>关闭App后，视频是否会重复推荐，是否影响正常的体验。</li></ol><p>UI测试：UI是否维持它原有的状态；界面是否美观、颜色搭配是否合理、布局是否合理、按钮大小位置是否合适、文字大小颜色搭配是否合适。</p><p>兼容性测试：在不同的手机型号、不同的分辨率下、不同的操作系统，测试效果如何。</p><p>易用性测试：是否由明显的提示，用户是否可以在点击三次鼠标内就达到目的；评论功能的复制粘贴。</p><p>性能测试：视频加载的速度。视频上传的速度。</p><p>安全性测试：登录验证码，记住密码，自动登录，找回密码，SQL注入问题，报文是否加密</p><p>中断测试：退出后再进来</p><p>网络测试：测试下在弱网，无网，4G，5G网络下面，这个功能是否还正常，有对应处理，比如无网就要提示等等。（有用过一些工具比如fiddler去模拟弱网等场景。）</p><h2 id="十六、项目中有没有使用到事务？">十六、项目中有没有使用到事务？</h2><p>有。Gorm中自动开启</p><h2 id="十七、Docker有什么特点？">十七、Docker有什么特点？</h2><p>Docker包括三个基本概念：</p><ol><li>docker镜像：就相当于是一个 root 文件系统。</li><li>docker容器：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li><li>docker仓库：仓库可看成一个代码控制中心，用来保存镜像。</li></ol><p>docker的三大底座：</p><ol><li><p>namespace 命名空间：容器隔离的基础，保证A容器看不到B容器.</p></li><li><p>cgroups 控制组：主要用到的cgroups子系统：cpu，blkio，device，freezer，memory</p><p>实际上 Docker 是使用了很多 Linux 的隔离功能，让容器看起来像一个轻量级虚拟机在独立运行，容器的本质是被限制了的 Namespaces，cgroup，具有逻辑上独立文件系统，网络的一个进程。</p></li><li><p>unionfs 联合文件系统：是一种<strong>轻量级的高性能分层文件系统</strong>，支持将文件系统中的修改进行提交和层层叠加，这个特性使得镜像可以通过分层实现和继承。</p></li></ol><h2 id="十八、Docker和虚拟机的对比">十八、Docker和虚拟机的对比</h2><ol><li>虚拟机需要模拟整个机器包括硬件、库、一个完整的用户操作系统。而Docker是与宿主机共享硬件资源及操作系统，可以实现资源的动态分配。</li><li>虚拟机的启动在分钟级别、docker的启动在秒级别可以做到快速部署</li><li>docker需要的资源更少，在操作系统级别进行虚拟化，容器与内核的交互几乎没有额外的损耗</li><li>docker的隔离性更弱、安全性也更弱。属于进程之间的隔离。虚拟机可实现系统级别的隔离。docker与宿主机共享内核、文件系统等资源，更有可能对其他容器、宿主机造成影响。</li></ol><h2 id="十九、Dockerfile怎么写">十九、Dockerfile怎么写</h2><h2 id="二十、密码怎么加密的，使用了什么算法">二十、密码怎么加密的，使用了什么算法</h2><p>使用的是bcrypt中的一个库函数。就是一个加盐的过程。先生成一个随机数salt，然后和password一起进行hash。</p><blockquote><p>对同一个密码，每次生成的hash不一样，这是因为hash中包含了salt（hash产生过程：先随机生成salt，salt跟password进行hash）；<br>在下次校验时，从hash中取出salt，salt跟password进行hash；得到的结果跟保存在DB中的hash进行比对，compareSync中已经实现了这一过程：bcrypt.compareSync(password, hashFromDB);</p></blockquote><h2 id="二十一、登陆方式">二十一、登陆方式</h2><blockquote><p>cookie和session的查缺补漏</p><p>JWT加密方式：HS256，是对称加密算法</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>后端</tag>
      
      <tag>RPC</tag>
      
      <tag>微服务</tag>
      
      <tag>项目</tag>
      
      <tag>MySQL</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务与RPC问题汇总</title>
    <link href="/Wuhlan3/2022/08/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/Wuhlan3/2022/08/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1>微服务与RPC问题汇总</h1><h2 id="1-什么是微服务？">1. 什么是微服务？</h2><blockquote><p>wiki:<strong>微服务</strong>（英语：Microservices）是一种<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84">软件架构风格</a>，它是以专注于单一责任与功能的小型功能区块 (Small Building Blocks) 为基础，利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关 (Language-Independent/Language agnostic）的<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3">API</a>集相互通信。</p></blockquote><p>简单来说，微服务的架构风格就是将单个应用程序作为一组小型服务来开发，每个服务程序都在自己的进程中运行，并以轻量级通信方式进行通信。这些服务可以使用不同的编程语言编写，使用不同的数据存储技术，并尽量不用集中式方式进行管理。</p><p>用一句话来概括就是“分而治之，合而用之”。</p><h2 id="2-微服务与单体架构的对比？">2. 微服务与单体架构的对比？</h2><p>单体架构的缺点如下：</p><ol><li>复杂度随时间不断变大，代码量到几十万行的大项目难以维护；</li><li>技术债务逐渐上升，留下的bug越来越多；</li><li>耦合度太高，维护成本大——修复bug的时候引入新的bug；</li><li>部署、交付的时间长，新人熟悉环境、业务的时间越来越长；</li><li>技术选型成本高，后面想要引入新的技术或框架，成本和风险都很高；</li><li>可扩展性差。</li></ol><p>微服务架构的<strong>优点</strong>如下：</p><ol><li><strong>单一职责</strong>。每个服务都有自己独立的业务逻辑，是一个高内聚、低耦合、单一原则的单元。</li><li><strong>轻量级通信</strong>。服务之间用过轻量级的通信机制实现互联互通，通常是语言无关、平台无关的交互方式；</li><li><strong>独立性</strong>。每个服务可以独立地进行开发、测试和部署；</li><li><strong>进程隔离</strong>。每个服务高度自治，可以部署到不同的主机上。当其中一个服务挂掉时，不会影响其他服务。</li></ol><p>当然，微服务也有它的<strong>不足之处</strong>：</p><ol><li><strong>运行维护困难</strong>，任意一个模块的问题，可能会影响整个项目，debug困难；</li><li><strong>分布式的复杂性</strong>。会使得项目变得更复杂；</li><li><strong>接口成本高</strong>，若接口发生大变动，所有依赖的微服务都要发生调整；</li><li><strong>重复劳动</strong>。某段业务多个模块共同使用，如果是单体架构，可以抽象为一个工具类。但是微服务架构中每个服务都可能需要，会导致代码重复；</li><li><strong>业务不好分离</strong>。程序员对业务理解可能不同。</li></ol><h2 id="3-什么是RPC？">3. 什么是RPC？</h2><p>RPC(Remote Procedure Call Protocol)是远程过程调用的缩写。它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想。</p><p>比如，我们写这样一个代码：</p><pre><code class="hljs angelscript">Result := Add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</code></pre><p>它会调用远程的（另一个进程，很可能在另一台服务器上）函数：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span><span class="hljs-title">int</span></span>{    <span class="hljs-keyword">return</span> a + b}</code></pre><h2 id="4-为什么微服务需要RPC">4. 为什么微服务需要RPC</h2><p>使用微服务的一个好处就是，不限定服务的提供方使用什么技术选型，能够实现公司跨团队的技术解耦。但是这样子，如果没有一个统一的服务框架——RPC框架，则各个团队需要各自实现一套序列化、反序列化、网络框架、连接池、收发线程、超时处理等业务之外的重复技术劳动。统一RPC框架将上述的劳动进行了统一处理。</p><h2 id="5-RPC的底层原理">5. RPC的底层原理</h2><h3 id="一个完整的RPC主要包括三部分">一个完整的RPC主要包括三部分:</h3><ol><li><p><strong>服务注册中心</strong>（Registry），负责将本地服务发布成远程服务，管理远程服务，提供给服务消费者使用。</p></li><li><p><strong>服务提供者</strong>（RPC Server），负责提供服务接口定义与服务实现类。</p></li><li><p><strong>服务消费者</strong>（RPC Client），负责通过远程代理对象调用远程服务。</p></li></ol><p>服务提供者（Server）启动后主动向服务注册中心（Registry）注册机器IP、端口以及提供的服务列表；服务消费者（Client）启动时向服务注册中心（Registry）获取服务提供方地址列表；服务注册中心（Registry）可实现负载均衡和故障切换。</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/972efe01322d49e5be8a42c2959438bc.png" alt="img"></p><h3 id="RPC调用过程为：">RPC调用过程为：</h3><ol><li>客户端想要发起一个远程过程调用，首先通过调用本地客户端Stub程序的方式调用想要使用的功能方法名；</li><li>客户端Stub程序接收到了客户端的功能调用请求，将客户端请求调用的方法名，携带的参数等信息做序列化操作，并打包成数据包。</li><li>客户端Stub查找到远程服务器程序的IP地址，调用Socket通信协议，通过网络发送给服务端。</li><li>服务端Stub程序接收到客户端发送的数据包信息，并通过约定好的协议将数据进行反序列化，得到请求的方法名和请求参数等信息。</li><li>服务端Stub程序准备相关数据，调用本地Server对应的功能方法进行，并传入相应的参数，进行业务处理。</li><li>服务端程序根据已有业务逻辑执行调用过程，待业务执行结束，将执行结果返回给服务端Stub程序。</li><li>服务端Stub程序将程序调用结果按照约定的协议进行序列化，并通过网络发送回客户端Stub程序。</li><li>客户端Stub程序接收到服务端Stub发送的返回数据，对数据进行反序列化操作，并将调用返回的数据传递给客户端请求发起者。</li><li>客户端请求发起者得到调用结果，整个RPC调用过程结束。</li></ol><h3 id="RPC要面临的三个问题">RPC要面临的三个问题:</h3><p>（1）<strong>Call ID映射</strong>。本地调用中，函数体是直接通过函数指针来指定的，调用函数时，编译器会自动调用它相应的函数指针。但在远程调用中，函数指针是不行的，因为两个进程的地址空间完全不一样。所以，在RPC中所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 ：Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查该表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</p><p>（2）<strong>序列化和反序列化</strong>。客户端如何将参数值传给远程的函数就成了一个问题在本地调用中，只需要把参数压到栈里，函数自己去栈里读即可。在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化（也叫编码和解码）。同理，从服务端返回的值也需要序列化反序列化的过程。</p><p>（3）<strong>网络传输</strong>。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2，Java的Netty也属于这层的东西。</p><h3 id="RPC与HTTP协议的对比">RPC与HTTP协议的对比</h3><table><thead><tr><th></th><th>RPC</th><th>HTTP</th></tr></thead><tbody><tr><td>传输协议</td><td>可以基于TCP协议，也可以基于HTTP协议</td><td>基于HTTP协议</td></tr><tr><td>传输效率</td><td>RPC使用自定义的TCP协议，可以让请求报文体积更小，或者使用HTTP2协议，也可以很好的减少报文的体积，提高传输效率</td><td>如果是基于HTTP1.1的协议，请求中会包含很多无用的内容，如果是基于HTTP2.0，那么简单的封装一下是可以作为一个RPC来使用的，这时标准RPC框架更多的是服务治理</td></tr><tr><td>性能消耗</td><td>可以基于thrift实现高效的二进制传输</td><td>大部分是通过json来实现的，字节大小和序列化耗时都比thrift要更消耗性能</td></tr><tr><td>负载均衡</td><td>基本都自带了负载均衡策略</td><td>需要配置Nginx，HAProxy来实现</td></tr><tr><td>服务治理</td><td>能做到自动通知，不影响上游</td><td>需要事先通知，修改Nginx/HAProxy配置</td></tr><tr><td>总结</td><td>主要用于公司内部的服务调用，性能消耗低，传输效率高，服务治理方便。</td><td>主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。</td></tr></tbody></table><h2 id="6-什么是ProtoBuf">6. 什么是ProtoBuf</h2><p><strong>Protocol Buffers</strong> (Protobuf) 是一种谷歌开发的二进制通信格式，用于序列化结构数据，截至目前，谷歌使用 protobuf 已经超过十年了。<br>Protobuf 的出现并不是为了解决新的问题，而是<strong>用更加现代的方式让网络传输更加高效</strong>，总的来说它有如下几个特点：</p><ol><li>是<strong>二进制格式</strong>，而不是像 JSON 与 XML 是基于文本的，因此非常节省空间。</li><li>对各种模式丰富且易上手的支持。</li><li>支持多种语言下的解析。</li></ol><p><strong>原理</strong>：</p><ul><li><p>使用varint来表示数字，越小的数字占用越少的字节数。</p></li><li><p>使用msb（最高有效位）来进行标识，当msb为1时，下一个字节继续表示这个数字；当msb为0时，这是最后一个字节。</p></li><li><p>对于字符串而言，不需要msb，因为有表示string长度的字段。</p></li></ul><p><strong>具体流程</strong>（以数字2009为例）：</p><ol><li><p>将2009 转换为二进制 11111011001</p></li><li><p>将其分割为 0001111 1011001</p></li><li><p>反转其顺序 1011001 0001111</p></li><li><p>添加 MSB 标识为 01011001 00001111</p></li><li><p>设置MSB ，11011001 00001111</p></li></ol><p>最后用16进制表示为 D9 0F</p><p><strong>小结</strong>：</p><ol><li>在微服务之间通信时，protobuf 更合适，在公开 API 或与浏览器通信时JSON 与 xml 更合适。</li><li>protobuf 更加节省空间，高效。</li><li>protobuf 放弃了可读性。</li><li>protobuf 使用的编码方式可以使数据更加紧凑。</li><li>protobuf 依赖生成的代码，需要一个protobuf 编译器根据你编写的 .proto 定义的数据生成，也称作消息。</li><li>你可以根据生成的代码初始化或解析发生的数据或接受的数据。</li></ol><h2 id="7-几种框架的对比">7. 几种框架的对比</h2><p>待续</p><h1>参考资料</h1><p>[1] <a href="https://blog.csdn.net/weixin_46742102/article/details/112169275">https://blog.csdn.net/weixin_46742102/article/details/112169275</a></p><p>[2] <a href="https://blog.csdn.net/weixin_41667472/article/details/124703669">https://blog.csdn.net/weixin_41667472/article/details/124703669</a></p><p>[3] <a href="https://zh.wikipedia.org/zh-cn/%E5%BE%AE%E6%9C%8D%E5%8B%99">https://zh.wikipedia.org/zh-cn/%E5%BE%AE%E6%9C%8D%E5%8B%99</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>RPC</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pprof性能分析</title>
    <link href="/Wuhlan3/2022/07/31/pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <url>/Wuhlan3/2022/07/31/pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1>pprof 性能分析</h1><p>benchmark(基准测试) 可以度量某个函数或方法的性能，也就是说，如果我们知道性能的瓶颈点在哪里，benchmark 是一个非常好的方式。但是面对一个未知的程序，如何去分析这个程序的性能，并找到瓶颈点呢？</p><p>pprof 就是用来解决这个问题的。pprof 包含两部分：</p><ul><li>编译到程序中的 <code>runtime/pprof</code> 包</li><li>性能剖析工具 <code>go tool pprof</code></li></ul><p>windows本地查看腾讯云云服务器上的pprof测试结果，只需远程安装：</p><pre><code class="hljs bash">sudo yum install graphviz</code></pre><h2 id="一、CPU性能分析">一、CPU性能分析</h2><p>启动 CPU 分析时，运行时(runtime) 将每隔 10ms 中断一次（为什么是10ms呢？后面会提到），记录此时正在运行的协程(goroutines) 的堆栈信息。启动 CPU 分析时，运行时(runtime) 将每隔 10ms 中断一次，记录此时正在运行的协程(goroutines) 的堆栈信息。程序运行结束后，可以分析记录的数据找到最热代码路径(hottest code paths)。</p><blockquote><p>编译器热路径是编译器中的代码执行路径，大部分执行时间都花在了这些路径上，并且可能会非常频繁地执行这些路径。</p></blockquote><p>一个函数在性能分析过程中出现的次数越多，说明执行该函数的代码路径(code path)花费的时间占总运行时间的比重越大。</p><h3 id="具体实现方式">具体实现方式</h3><p>在main函数之前添加这两句，可以将性能数据输出到cpu.pprof</p><pre><code class="hljs go">f, _ := os.OpenFile(<span class="hljs-string">"cpu.pprof"</span>, os.O_CREATE|os.O_RDWR, <span class="hljs-number">0644</span>)<span class="hljs-keyword">defer</span> f.Close()pprof.StartCPUProfile(f)<span class="hljs-comment">//源码中提到：当频率大于500Hz，可能会影响本身的效率，而经过测试，最适合的频率是100Hz，不会影响且会提供有价值的数据。</span><span class="hljs-keyword">defer</span> pprof.StopCPUProfile()</code></pre><p>对数据及进行分析：</p><pre><code class="hljs routeros">$ go<span class="hljs-built_in"> tool </span>pprof <span class="hljs-attribute">-http</span>=127.0.0.1:6060 cpu.pprof</code></pre><p>之后会自动打开浏览器，如下，可以通过不同的方式查看结果：</p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220731201857858.png" alt="image-20220731201857858" style="zoom:50%;"><p>也可以直接通过命令行来分析：</p><pre><code class="hljs routeros">[root@VM-16-2-centos pprof-test]# go<span class="hljs-built_in"> tool </span>pprof cpu.pprofFile: mainType: cpuTime: Jul 31, 2022 at 3:58pm (CST)Duration: 17.34s, Total samples = 17.25s (99.46%)Entering interactive mode (type <span class="hljs-string">"help"</span> <span class="hljs-keyword">for</span> commands, <span class="hljs-string">"o"</span> <span class="hljs-keyword">for</span> options)(pprof) topShowing nodes<span class="hljs-built_in"> accounting </span><span class="hljs-keyword">for</span> 17.18s, 99.59% of 17.25s totalDropped 17 nodes (cum &lt;= 0.09s)      flat  flat%   sum%        cum   cum%    17.18s 99.59% 99.59%     17.21s 99.77%  main.bubbleSort (inline)         0     0% 99.59%     17.22s 99.83%  main.main         0     0% 99.59%     17.22s 99.83%  runtime.main(pprof) top -cumShowing nodes<span class="hljs-built_in"> accounting </span><span class="hljs-keyword">for</span> 17.18s, 99.59% of 17.25s totalDropped 17 nodes (cum &lt;= 0.09s)      flat  flat%   sum%        cum   cum%         0     0%     0%     17.22s 99.83%  main.main         0     0%     0%     17.22s 99.83%  runtime.main    17.18s 99.59% 99.59%     17.21s 99.77%  main.bubbleSort (inline)(pprof) help  Commands:    callgrind        Outputs a graph <span class="hljs-keyword">in</span> callgrind format    comments         Output all<span class="hljs-built_in"> profile </span>comments    disasm           Output assembly listings annotated with samples    dot              Outputs a graph <span class="hljs-keyword">in</span> DOT format    eog              Visualize graph through eog    evince           Visualize graph through evince    gif              Outputs a graph image <span class="hljs-keyword">in</span> GIF format    gv               Visualize graph through gv    kcachegrind      Visualize report <span class="hljs-keyword">in</span> KCachegrind    list             Output annotated source <span class="hljs-keyword">for</span> functions matching regexp    pdf              Outputs a graph <span class="hljs-keyword">in</span> PDF format    peek             Output callers/callees of functions matching regexp    png              Outputs a graph image <span class="hljs-keyword">in</span> PNG format    proto            Outputs the<span class="hljs-built_in"> profile </span><span class="hljs-keyword">in</span> compressed protobuf format    ps               Outputs a graph <span class="hljs-keyword">in</span> PS format   <span class="hljs-built_in"> raw </span>             Outputs a text representation of the<span class="hljs-built_in"> raw </span>profile    svg              Outputs a graph <span class="hljs-keyword">in</span> SVG format    tags             Outputs all tags <span class="hljs-keyword">in</span> the profile    text             Outputs top entries <span class="hljs-keyword">in</span> text form    top              Outputs top entries <span class="hljs-keyword">in</span> text form    topproto         Outputs top entries <span class="hljs-keyword">in</span> compressed protobuf format    traces           Outputs all<span class="hljs-built_in"> profile </span>samples <span class="hljs-keyword">in</span> text form    tree             Outputs a text rendering of call graph    web              Visualize graph through web browser    weblist          Display annotated source <span class="hljs-keyword">in</span> a web browser    o/options        List options <span class="hljs-keyword">and</span> their current values    q/quit/exit/^D   Exit pprof</code></pre><h2 id="二、内存分析">二、内存分析</h2><p>内存性能分析(Memory profiling) 记录堆内存分配时的堆栈信息，忽略栈内存分配信息。</p><p>内存性能分析启用时，默认每1000次采样1次，这个比例是可以调整的。因为内存性能分析是基于采样的，因此基于内存分析数据来判断程序所有的内存使用情况是很困难的。</p><h3 id="具体实现方式-2">具体实现方式</h3><p>需要导入<code>"github.com/pkg/profile"</code>然后在main函数之前添加：</p><pre><code class="hljs css"><span class="hljs-selector-tag">defer</span> <span class="hljs-selector-tag">profile</span><span class="hljs-selector-class">.Start</span>(<span class="hljs-selector-tag">profile</span><span class="hljs-selector-class">.MemProfile</span>, <span class="hljs-selector-tag">profile</span><span class="hljs-selector-class">.MemProfileRate</span>(1))<span class="hljs-selector-class">.Stop</span>()</code></pre><p>对数据及进行分析：</p><pre><code class="hljs routeros">go<span class="hljs-built_in"> tool </span>pprof <span class="hljs-attribute">-http</span>=127.0.0.1:6060 /tmp/profile2738765321/mem.pprof</code></pre><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220731204427226.png" alt="image-20220731204427226" style="zoom: 50%;"><h2 id="三、针对web程序">三、针对web程序</h2><p>针对一直运行的后台服务，比如 web 应用或者分布式应用，我们可以使用 net/http/pprof 库，它能够在应用提供 HTTP 服务时进行分析。</p><p>pprof 采集后台服务，如果使用了默认的 <code>http.DefaultServeMux</code>，通常是代码直接使用<code> http.ListenAndServe(“0.0.0.0:8000”, nil)</code>，这种情况则比较简单，只需要导入包即可。</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> (    _ <span class="hljs-string">"net/http/pprof"</span>)</code></pre><p>注意该包利用下划线"_"导入，意味着我们只需要该包运行其init()函数即可，如此该包将自动完成信息采集并保存在内存中。</p><p>如果你使用自定义的 ServerMux复用器，则需要手动注册一些路由规则：</p><pre><code class="hljs go">r.HandleFunc(<span class="hljs-string">"/debug/pprof/"</span>, pprof.Index)r.HandleFunc(<span class="hljs-string">"/debug/pprof/heap"</span>, pprof.Index)r.HandleFunc(<span class="hljs-string">"/debug/pprof/cmdline"</span>, pprof.Cmdline)r.HandleFunc(<span class="hljs-string">"/debug/pprof/profile"</span>, pprof.Profile)r.HandleFunc(<span class="hljs-string">"/debug/pprof/symbol"</span>, pprof.Symbol)r.HandleFunc(<span class="hljs-string">"/debug/pprof/trace"</span>, pprof.Trace)</code></pre><p>这些路径分别表示：</p><ul><li>/debug/pprof/profile：访问这个链接会自动进行 CPU profiling，持续 30s，并生成一个文件供下载，可以通过带参数?=seconds=60进行60秒的数据采集。</li><li>/debug/pprof/block：Goroutine阻塞事件的记录。默认每发生一次阻塞事件时取样一次。</li><li>/debug/pprof/goroutines：活跃Goroutine的信息的记录。仅在获取时取样一次。</li><li>/debug/pprof/heap： 堆内存分配情况的记录。默认每分配512K字节时取样一次。</li><li>/debug/pprof/mutex: 查看争用互斥锁的持有者。</li><li>/debug/pprof/threadcreate: 系统线程创建情况的记录。 仅在获取时取样一次。</li></ul><h3 id="在Gin框架中使用pprof">在Gin框架中使用pprof</h3><p>可以导入包<code>go get github.com/gin-contrib/pprof</code>，之后就可以看到一些新的接口生成：</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220731222053015.png" alt="image-20220731222053015"></p><p>profile文件保存在/root/pprof/pprof.api.samples.cpu.001.pb.gz，之后直接使用上述的分析方式即可在windows界面打开：</p><pre><code class="hljs angelscript">[<span class="hljs-symbol">root@</span>VM<span class="hljs-number">-16</span><span class="hljs-number">-2</span>-centos api]# go tool pprof -http=<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6060</span> /root/pprof/pprof.api.samples.cpu<span class="hljs-number">.001</span>.pb.gzServing web UI on http:<span class="hljs-comment">//127.0.0.1:6060</span></code></pre><blockquote><p>关于火焰图的基本理解方法：</p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220731222622729.png" alt="image-20220731222622729" style="zoom:67%;"></blockquote><h2 id="参考资料">参考资料</h2><p>[1] <a href="https://geektutu.com/post/hpg-pprof.html">https://geektutu.com/post/hpg-pprof.html</a></p><p>[2] <a href="https://bbs.huaweicloud.com/blogs/289818">https://bbs.huaweicloud.com/blogs/289818</a></p><p>[3] <a href="https://bytedancecampus1.feishu.cn/docs/doccn4F3nKRdd9Uq7RGl6JPPFWg#">https://bytedancecampus1.feishu.cn/docs/doccn4F3nKRdd9Uq7RGl6JPPFWg#</a></p><p>[4] <a href="http://liumurong.org/2019/12/gin_pprof/">http://liumurong.org/2019/12/gin_pprof/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言基础-Proxy实现</title>
    <link href="/Wuhlan3/2022/05/14/goproxy/"/>
    <url>/Wuhlan3/2022/05/14/goproxy/</url>
    
    <content type="html"><![CDATA[<h1 id="Go语言基础-Proxy的实现"><a href="#Go语言基础-Proxy的实现" class="headerlink" title="Go语言基础-Proxy的实现"></a>Go语言基础-Proxy的实现</h1><h2 id="一、前置知识：SOCKS5代理"><a href="#一、前置知识：SOCKS5代理" class="headerlink" title="一、前置知识：SOCKS5代理"></a>一、前置知识：SOCKS5代理</h2><p><strong>SOCKS</strong>是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是“SOCKet Secure”的缩写。</p><blockquote><p>某些企业为了安全性，设置了很强的防火墙，带来的副作用是哪怕你是管理员，访问资源也很麻烦。SOCKS5就是开了一个小口子，用来访问资源的。</p></blockquote><p>防火墙内的客户端想要访问外部的服务器时，会跟SOCKS代理服务器进行连接。客户端的请求会通过代理服务器发送到外部的服务器，最终响应也会通过代理服务器发送回客户端。</p><h3 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h3><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220514220424129.png" alt="image-20220514220424129" style="zoom: 50%;"></p><h3 id="协商过程（认证）"><a href="#协商过程（认证）" class="headerlink" title="协商过程（认证）"></a>协商过程（认证）</h3><p>SOCKS5比SOCKS4a多了验证、IPv6、UDP支持。</p><p>建立与SOCKS5服务器的TCP连接后客户端需要先发送请求来确认协议版本及认证方式，格式为（以字节为单位）：</p><div class="table-container"><table><thead><tr><th>VER</th><th>NMETHODS</th><th>METHODS</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1-255</td></tr></tbody></table></div><ul><li>VER是SOCKS版本，这里应该是0x05；</li><li>NMETHODS是METHODS部分的长度；</li><li>METHODS是客户端支持的认证方式列表，每个方法占1字节。基本的有：<ul><li>0x00 不需要认证</li><li>0x01 GSSAPI</li><li>0x02 用户名、密码认证</li></ul></li></ul><p>服务器从客户端提供的方法中选择一个并通过以下消息通知客户端（以字节为单位）：</p><div class="table-container"><table><thead><tr><th>VER</th><th>METHOD</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr></tbody></table></div><ul><li>VER是SOCKS版本，这里应该是0x05；</li><li>METHOD是服务端选中的方法。如果返回0xFF表示没有一个认证方法被选中，客户端需要关闭连接。</li></ul><h3 id="请求阶段"><a href="#请求阶段" class="headerlink" title="请求阶段"></a>请求阶段</h3><p><strong>客户端发送请求的格式</strong></p><p>认证结束后客户端就可以发送请求信息。如果认证方法有特殊封装要求，请求必须按照方法所定义的方式进行封装。</p><p>SOCKS5请求格式（以字节为单位）：</p><div class="table-container"><table><thead><tr><th>VER</th><th>CMD</th><th>RSV</th><th>ATYP</th><th>DST.ADDR</th><th>DST.PORT</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0x00</td><td>1</td><td>动态</td><td>2</td></tr></tbody></table></div><ul><li>VER是SOCKS版本，这里应该是0x05；</li><li>CMD是SOCK的命令码<ul><li>0x01表示CONNECT请求</li><li>0x02表示BIND请求</li><li>0x03表示UDP转发</li></ul></li><li>RSV 0x00，保留</li><li>ATYP DST.ADDR类型<ul><li>0x01 IPv4地址，DST.ADDR部分4字节长度</li><li>0x03 域名，DST.ADDR部分第一个字节为域名长度，DST.ADDR剩余的内容为域名，没有\0结尾。</li><li>0x04 IPv6地址，16个字节长度。</li></ul></li><li>DST.ADDR 目的地址</li><li>DST.PORT 网络字节序表示的目的端口</li></ul><p><strong>服务器响应的格式</strong></p><p>服务器按以下格式回应客户端的请求（以字节为单位）：</p><div class="table-container"><table><thead><tr><th>VER</th><th>REP</th><th>RSV</th><th>ATYP</th><th>BND.ADDR</th><th>BND.PORT</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0x00</td><td>1</td><td>动态</td><td>2</td></tr></tbody></table></div><ul><li>VER是SOCKS版本，这里应该是0x05；</li><li><p>REP应答字段</p><ul><li>0x00表示成功</li><li>0x01普通SOCKS服务器连接失败</li><li>0x02现有规则不允许连接</li><li>0x03网络不可达</li><li>0x04主机不可达</li><li>0x05连接被拒</li><li>0x06 TTL超时</li><li>0x07不支持的命令</li><li>0x08不支持的地址类型</li><li>0x09 - 0xFF未定义</li></ul></li><li><p>RSV 0x00，保留</p></li><li><p>ATYP BND.ADDR类型</p><ul><li>0x01 IPv4地址，DST.ADDR部分4字节长度</li><li>0x03域名，DST.ADDR部分第一个字节为域名长度，DST.ADDR剩余的内容为域名，没有\0结尾。</li><li>0x04 IPv6地址，16个字节长度。</li></ul></li><li><p>BND.ADDR 服务器绑定的地址</p></li><li>BND.PORT 网络字节序表示的服务器绑定的端口</li></ul><h2 id="二、前置知识：bufio包的使用"><a href="#二、前置知识：bufio包的使用" class="headerlink" title="二、前置知识：bufio包的使用"></a>二、前置知识：bufio包的使用</h2><p>bufio是有缓存的io，避免因为多次写操作而降低程序的性能。</p><p>具体可以参考这个文章：<a href="https://zhuanlan.zhihu.com/p/129781512">https://zhuanlan.zhihu.com/p/129781512</a></p><p>有时间，再自己总结吧…</p><h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><h3 id="1-v1：简易的echo-server"><a href="#1-v1：简易的echo-server" class="headerlink" title="1. v1：简易的echo server"></a>1. v1：简易的echo server</h3><p>与linuxC++的实现过程类似。</p><ul><li>首先监听IP地址和端口号，调用net.Listen()；</li><li>调用server.Accept()等待并建立连接；</li><li>当有连接建立之后，启动一个协程，来处理这个连接的数据</li></ul><pre><code class="hljs Go"><span class="hljs-comment">//process部分就不放出了，就是一个简单的数据读取和输出的过程</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {   server, err := net.Listen(<span class="hljs-string">"tcp"</span>, <span class="hljs-string">"127.0.0.1:1080"</span>)   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {      <span class="hljs-built_in">panic</span>(err)   }   <span class="hljs-keyword">for</span> {      client, err := server.Accept()      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {         log.Printf(<span class="hljs-string">"Accept failed %v"</span>, err)         <span class="hljs-keyword">continue</span>      }      <span class="hljs-keyword">go</span> process(client)   }}</code></pre><p>nc安装教程如下：<a href="https://www.cnblogs.com/linyufeng/p/13206252.html">https://www.cnblogs.com/linyufeng/p/13206252.html</a></p><p>使用nc命令可以直接和一个ip端口建立tcp连接。</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220514214450225.png" alt="image-20220514214450225" style="zoom:100%;"></p><h3 id="2-v2：协商阶段"><a href="#2-v2：协商阶段" class="headerlink" title="2. v2：协商阶段"></a>2. v2：协商阶段</h3><p>main函数不需要修改，在process函数中新增鉴权的部分：</p><pre><code class="hljs Go"><span class="hljs-comment">//新增的鉴权过程</span>err := auth(reader, conn)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {   log.Printf(<span class="hljs-string">"client %v auth failed:%v"</span>, conn.RemoteAddr(), err)   <span class="hljs-keyword">return</span>}</code></pre><p>auth函数的实现流程如下：</p><ol><li>使用reader.ReadByte将版本号读取出来；</li><li>使用reader.ReadByte将mthodsize读取出来，并建立相应大小的method数组；</li><li>使用io.ReadFull将method填充完全；</li><li>往连接中写入版本号和方法<code>conn.Write([]byte{socks5Ver, 0x00})</code></li></ol><p>运行程序后，在终端执行<code>curl --socks5 127.0.0.1:1080 -v http://www.qq.com</code>，可以显示出版本号、method和认证成功。</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220514220635063.png" alt="image-20220514220635063" style="zoom: 80%;"></p><h3 id="3-v3：请求阶段"><a href="#3-v3：请求阶段" class="headerlink" title="3. v3：请求阶段"></a>3. v3：请求阶段</h3><p>我们在auth下面再实现一个connect函数，该函数用于读取客户端发送的数据，然后与服务器进行tcp连接；之后将连接的信息发送回给客户端。</p><pre><code class="hljs Perl">err = <span class="hljs-keyword">connect</span>(reader, conn)<span class="hljs-keyword">if</span> err != nil {   log.Printf(<span class="hljs-string">"client %v auth failed:%v"</span>, conn.RemoteAddr(), err)   <span class="hljs-keyword">return</span>}</code></pre><p>读取客户端的数据主要包括版本号Ver、命令码CMD、保留字RSB、ATYP目标地址类型、DST.ADDR 一个可变长度的值、DST.PORT 目标端口。</p><p>写回给客户端的过程属性类似，略。</p><p>运行程序后，可以正确返回ip地址和端口号：</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220514220524235.png" alt="image-20220514220524235" style="zoom:80%;"></p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220514220512876.png" alt="image-20220514220512876" style="zoom:80%;"></p><h3 id="4-v4：relay阶段"><a href="#4-v4：relay阶段" class="headerlink" title="4. v4：relay阶段"></a>4. v4：relay阶段</h3><p>将客户端的请求发送到服务器，将服务器的响应发送回给客户端。</p><pre><code class="hljs go"><span class="hljs-comment">//使用ctx机制来进行同步</span>ctx, cancel := context.WithCancel(context.Background())<span class="hljs-keyword">defer</span> cancel()<span class="hljs-comment">//使用io.Copy——死循环将src中的数据读取到dest中</span><span class="hljs-comment">//两个goroutine的方向不一样，一个是从浏览器拷贝到服务器，一个是从服务器拷贝到浏览器</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {    _, _ = io.Copy(dest, reader)    cancel()}()<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {    _, _ = io.Copy(conn, dest)    cancel()}()<span class="hljs-comment">//使用ctx的机制，来进行同步一下</span>    &lt;-ctx.Done()</code></pre><p>运行程序如下所示：</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220514215014797.png" alt="image-20220514215014797" style="zoom: 80%;"></p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220514220556547.png" alt="image-20220514220556547" style="zoom:50%;"></p><h3 id="5-使用插件进行测试"><a href="#5-使用插件进行测试" class="headerlink" title="5.使用插件进行测试"></a>5.使用插件进行测试</h3><p>可以使用Proxy SwitchyOmega插件。</p><p>该软件本身不提供给代理服务器，需要连接我们自己的代理服务器。</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220514215111141.png" alt="image-20220514215111141" style="zoom: 33%;"><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220514215047480.png" alt="image-20220514215047480" style="zoom:67%;"></p><p>在启动右上角的小圈圈后，浏览器访问的网页都会经过我们的代理服务器。</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220514215030250.png" alt="image-20220514215030250" style="zoom:50%;"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/129781512">https://zhuanlan.zhihu.com/p/129781512</a></p><p>[2] <a href="https://zh.m.wikipedia.org/zh-hans/SOCKS">https://zh.m.wikipedia.org/zh-hans/SOCKS</a></p><p>[3] 字节青训营《Go语言上手 - 基础语言》</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>青训营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go依赖管理</title>
    <link href="/Wuhlan3/2022/05/09/Go%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"/>
    <url>/Wuhlan3/2022/05/09/Go%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Go依赖管理"><a href="#Go依赖管理" class="headerlink" title="Go依赖管理"></a>Go依赖管理</h1><p>实际开发过程中，工程项目不可能都从0到1地开发。所以，依赖库的管理非常重要。</p><h1 id="一、Go依赖管理的演进"><a href="#一、Go依赖管理的演进" class="headerlink" title="一、Go依赖管理的演进"></a>一、Go依赖管理的演进</h1><ol><li>GOPATH</li><li>Go Vender</li><li>Go Module</li></ol><p>主要解决两个问题：不同环境依赖的版本不同；控制依赖库的版本</p><h2 id="1-GOPATH"><a href="#1-GOPATH" class="headerlink" title="1.GOPATH"></a>1.GOPATH</h2><p>GOPATH是一个环境变量，是Go的一个工作区。在go的早期版本里，需要将代码放在<code>$GOPATH/src</code>下，而且go get产生的依赖也会自动下载到<code>$GOPATH/src</code>。</p><pre><code class="hljs jboss-cli">GOPATH├── bin        <span class="hljs-comment">#项目编译的二进制文件</span>├── pkg        <span class="hljs-comment">#项目编译的中间产物，加速编译</span>├── src        <span class="hljs-comment">#项目源码</span>    ├── github.com    <span class="hljs-string">...</span></code></pre><p>GOPATH呈现的特点是：</p><ul><li>项目代码直接依赖src下的代码</li><li>Go get下载最新版本的包到src目录下</li></ul><p>GOPATH的弊端也很明显：就是当projectA依赖于某个包的v1版本，而projectB又依赖于该包的v2版本，就会出现问题——<strong>无法实现package的多版本控制</strong></p><p><img width="500" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e785f4283acf43908ab920827907c5c1~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="2-Go-Vender"><a href="#2-Go-Vender" class="headerlink" title="2.Go Vender"></a>2.Go Vender</h2><p>随着Go的依赖包越来越丰富，版本越来越多。Go 官方在 Go 1.5 的时候提出了实验性质的 vendor 机制——<strong>每个项目都可以有一个</strong><code>``vendor/`` </code><strong>目录来存放项目所需版本依赖的拷贝</strong>。</p><ul><li>在项目目录下，增加vendor文件夹，所有依赖包副本形式放在$ProjectRoot/vendor；</li><li>依赖寻址方式：首先查找vendor，再查找GOPATH；</li><li>通过每个项目引入一份依赖符本，解决了多个项目需要同一个package依赖的冲突问题</li></ul><p>Go Vendor依然存在一些弊端——<strong>同一个项目中的package可能依赖于不同版本的包，这也会产生冲突</strong>。</p><p><img width="500" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06c7f720da094c1c8e4c186cee352556~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="3-Go-Module"><a href="#3-Go-Module" class="headerlink" title="3.Go Module"></a>3.Go Module</h2><ul><li>通过go.mod文件管理依赖包版本</li><li>通过go get/go mod指令工具管理依赖包</li></ul><p>Go Module实现了最终的目标：<strong>可以定义版本规则和管理项目依赖关系</strong></p><h1 id="二、依赖管理"><a href="#二、依赖管理" class="headerlink" title="二、依赖管理"></a>二、依赖管理</h1><h2 id="1-依赖管理的三要素"><a href="#1-依赖管理的三要素" class="headerlink" title="1.依赖管理的三要素"></a>1.依赖管理的三要素</h2><ol><li>配置文件，描述依赖 go.mod</li><li>中心仓库管理依赖库 Proxy</li><li>本地工具 go get/go mod</li></ol><h2 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.配置文件"></a><strong>2.配置文件</strong></h2><p>go.mod结构如下, 其中version分为两种，语义化版本；基于commit的伪版本</p><p><img width="500" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb99b58a026d46fb8d248154a3ea2ff2~tplv-k3u1fbpfcp-zoom-1.image"></p><blockquote><p><code>go.mod</code>文件中出现 <code>+incompatible</code>，说明你引用了一个不规范的 Module，正常情况下，只能说明这个 Module 版本未遵循版本化语义规范。可能会有一些风险</p></blockquote><h2 id="3-中心仓库管理依赖库"><a href="#3-中心仓库管理依赖库" class="headerlink" title="3.中心仓库管理依赖库"></a><strong>3.中心仓库管理依赖库</strong></h2><p>Go mod中的依赖都可以对应到github上的某一个提交的代码版本，这样就可以直接下载代码来完成依赖分发。但是过度依赖代码托管平台又会导致以下几个问题：</p><ul><li>无法保证构建稳定性：增加/修改/删除软件版本</li><li>无法保证依赖可用性：代码的作者可以删除软件</li><li>增加第三方压力：代码托管平台负载问题</li></ul><p>所以我们可以在中间增加一个proxy，它负责缓存软件版本，保证了依赖的稳定性。</p><p>我们使用GOPROXY来管理proxy的配置：</p><pre><code class="hljs vala">GOPROXY=<span class="hljs-string">"https://proxy1.cn, https://proxy2.cn, direct"</span><span class="hljs-meta">#服务站点URL列表，“direct”表示源站</span><span class="hljs-meta">#proxy1-&gt;proxy2-&gt;Direct</span><span class="hljs-meta">#即会先从proxy1查找依赖，再到proxy2查找依赖，最后回到源站查找</span></code></pre><h2 id="4-工具go-get"><a href="#4-工具go-get" class="headerlink" title="4.工具go get"></a><strong>4.工具go get</strong></h2><p>go get命令可以借助代码管理工具通过远程拉取或更新代码包及其依赖包,并自动完成编译和安装</p><pre><code class="hljs maxima"><span class="hljs-built_in">go</span> <span class="hljs-built_in">get</span> <span class="hljs-built_in">example</span>.org/pkg</code></pre><pre><code class="hljs shell">@update  默认@node    删除依赖@v1.1.2  tag版本，语义版本@23dfdd5 特定的commit@master  分支的最新commit</code></pre><h2 id="5-工具go-mod"><a href="#5-工具go-mod" class="headerlink" title="5.工具go mod"></a><strong>5.工具go mod</strong></h2><h3 id="go-mod-init"><a href="#go-mod-init" class="headerlink" title="go mod init"></a>go mod init</h3><p>创建空项目后，可以执行这个命令。</p><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-keyword">mod</span> init gitee.<span class="hljs-keyword">com</span>/biexiaoyansudian/my.<span class="hljs-keyword">cn</span>#指定了模块导入路径为 gitee.<span class="hljs-keyword">com</span>/biexiaoyansudian/my.<span class="hljs-keyword">cn</span></code></pre><p>这个 init 指定的路径作用是：</p><ul><li><p>作为模块的标识</p></li><li><p>作为模块的import path，当其他项目引用这个模块下的 package 时都会以该 import path 作为共同的前缀<code>import "``gitee.com/biexiaoyansudian/my.cn/mypkg``"</code></p></li></ul><p>go mod init 执行完毕，就初始化了使用 Go modules 的项目，会多出来一个 <strong>go.mod 文件</strong>。它记录了当前项目的模块信息，每一行都以一个关键词开头。</p><h3 id="go-mod-download"><a href="#go-mod-download" class="headerlink" title="go mod download"></a>go mod download</h3><p>下载依赖包</p><h3 id="go-mod-tidy"><a href="#go-mod-tidy" class="headerlink" title="go mod tidy"></a>go mod tidy</h3><p>拉取缺少的依赖，移除不用的依赖</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a href="https://www.infoq.cn/article/xyjhjja87y7pvu1iwhz3">https://www.infoq.cn/article/xyjhjja87y7pvu1iwhz3</a></p><p>[2] 字节跳动青训营——Go语言上手 - 工程实践</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>青训营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git基本用法</title>
    <link href="/Wuhlan3/2022/05/01/git%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <url>/Wuhlan3/2022/05/01/git%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="git基本用法"><a href="#git基本用法" class="headerlink" title="git基本用法"></a>git基本用法</h1><h2 id="一、本地仓库操作"><a href="#一、本地仓库操作" class="headerlink" title="一、本地仓库操作"></a>一、本地仓库操作</h2><h3 id="1-仓库初始化"><a href="#1-仓库初始化" class="headerlink" title="1.仓库初始化"></a>1.仓库初始化</h3><pre><code class="hljs properties"><span class="hljs-attr">mkdir</span> <span class="hljs-string">gitTraining</span><span class="hljs-attr">cd</span> <span class="hljs-string">gitTraining</span><span class="hljs-attr">git</span> <span class="hljs-string">init</span></code></pre><h3 id="2-将修改保存到暂存区"><a href="#2-将修改保存到暂存区" class="headerlink" title="2.将修改保存到暂存区"></a>2.将修改保存到暂存区</h3><pre><code class="hljs dockerfile"><span class="hljs-comment">#添加所有修改  </span>git <span class="hljs-keyword">add</span><span class="bash"> .  </span><span class="hljs-comment">#添加hello.txt文件  </span>git <span class="hljs-keyword">add</span><span class="bash"> hello.txt </span></code></pre><p>查看暂存区状态</p><pre><code class="hljs ebnf"><span class="hljs-attribute">git status</span></code></pre><p>但是如果你不小心把不想添加的东西添加到暂存区，或者想丢弃已经添加的内容，这个时候你该怎么办呢？不用着急，这个时候<code>git checkout</code>命令就可以大显身手了。丢弃添加的内容：</p><pre><code class="hljs css"><span class="hljs-selector-tag">git</span> <span class="hljs-selector-tag">checkout</span> <span class="hljs-selector-tag">hello</span><span class="hljs-selector-class">.txt</span></code></pre><h3 id="3-将修改提交到本地仓库"><a href="#3-将修改提交到本地仓库" class="headerlink" title="3.将修改提交到本地仓库"></a>3.将修改提交到本地仓库</h3><p>当执行完<code>git commit</code>后，如果你试着执行以下<code>git log</code>你可能会得到如下的输出：</p><pre><code class="hljs angelscript">commit <span class="hljs-number">37302</span>ce99137cf30fabc14784d23ea63cadb928b  Author: educoder &lt;<span class="hljs-symbol">educoder@</span><span class="hljs-number">163.</span>com&gt;  Date:   Sun Dec <span class="hljs-number">24</span> <span class="hljs-number">23</span>:<span class="hljs-number">35</span>:<span class="hljs-number">48</span> <span class="hljs-number">2017</span> +<span class="hljs-number">0800</span>    添加helloGit.txt</code></pre><p>其中：  </p><ul><li><code>“commit 37302ce99137cf30fabc14784d23ea63cadb928b”</code>中的后面这一串字符就是完整的<code>commit id</code>；</li><li><code>“Author”</code>就是这次提交的作者，它就是我们在<code>git config</code>中配置的<code>user.name</code>；</li><li>最后输出的<code>“添加helloGit.txt”</code>，是我们在提交时添加的信息。</li></ul><p>如果有多次提交即<code>commit</code>，在执行<code>git log</code>时，会输出每一次的提交的具体信息。这样的话，什么时候（<code>Date</code>）由什么人（<code>Author</code>）提交了什么内容（“添加<code>helloGit.txt</code>”）就一目了然了。</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220504195643301.png" alt="image-20220504195643301"></p><h2 id="二、远程仓库操作"><a href="#二、远程仓库操作" class="headerlink" title="二、远程仓库操作"></a>二、远程仓库操作</h2><h3 id="1-克隆远程版本库"><a href="#1-克隆远程版本库" class="headerlink" title="1.克隆远程版本库"></a>1.克隆远程版本库</h3><pre><code class="hljs crmsh"><span class="hljs-comment">##克隆到当前路径</span>git <span class="hljs-keyword">clone</span> <span class="hljs-title">xxx</span>.git<span class="hljs-comment">##也可以指定克隆到某个目录</span>git <span class="hljs-keyword">clone</span> <span class="hljs-title">xxx</span>.git <span class="hljs-string">"指定目录"</span></code></pre><p>在团队开发中，<strong>我们必须选用一台主机做为<code>Git</code>服务器来存放远程版本库。</strong>这样团队中的每个开发者，就可以基于一个共同的远程版本库进行开发。目前提供代码托管（即可以将远程版本库存放于其上的）的平台有<code>Github</code>、<code>Gitee</code>等，同时我们也可以<strong>搭建一台私有的运行<code>Git</code>的服务器</strong>，来做为远程<code>Git</code>服务器。<code>Github</code>等平台的使用，及本地<code>Git</code>服务器的搭建，会在后续的实训中具体介绍。本地<code>Git</code>服务器，可以配置不同的连接方式，如<code>shell</code>、<code>git</code>或<code>bash</code>。为了给挑战者提供一个便利的实训环境，我们为每个人配置了一台本地<code>Git</code>服务器，并允许以<code>bash</code>方式进行操作，即可以通过类似于<code>/home/sample.git</code>这种形式的地址，做为远程仓库地址进行操作，而不是像<code>https://sample.git</code>这种形式。</p><h3 id="2-添加到远程版本库"><a href="#2-添加到远程版本库" class="headerlink" title="2.添加到远程版本库"></a>2.添加到远程版本库</h3><blockquote><p>现在你要自己启动一个项目了，你需要将你的代码保存到远程版本中。那么你要做的第一件事就是，需要为你的本地版本库添加一个远程仓库，然后整个团队才能基于这个远程版本库进行协同开发。</p></blockquote><p>添加远程版本库需要用到的命令是<code>git remote add</code>，其命令格式为：  </p><pre><code class="hljs dockerfile">git remote <span class="hljs-keyword">add</span><span class="bash"> “远程仓库名” “远程仓库地址”  </span></code></pre><p>使用示例如下：  </p><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> remote <span class="hljs-keyword">add</span> origin https:<span class="hljs-comment">//sample.git  </span></code></pre><p>这样就将<code>https://sample.git</code>添加为远程仓库，并将其命名为<code>origin</code>。   ###编程要求<br>本关的编程任务是，补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的脚本。通过执行你所编写的脚本，来完成为本地仓库添加远程仓库的任务。远程仓库的地址为<code>/tmp/sample.git</code>。具体要求如下：</p><ul><li>创建一个本地版本库；</li><li>为创建的本地仓库添加远程仓库，且将其命名为<code>git</code>。</li></ul><h3 id="3-推送本地仓库到远程仓库"><a href="#3-推送本地仓库到远程仓库" class="headerlink" title="3.推送本地仓库到远程仓库"></a>3.推送本地仓库到远程仓库</h3><p>推送本地内容时，会将所有未推送至远程仓库的内容，都提到远程仓库。它用到的命令是<code>git push</code>，使用方法如下：  </p><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> 远程仓库名 本地分支名 远程分支名</code></pre><p>具体的使用方法如下：  </p><pre><code class="hljs crmsh">git push origin <span class="hljs-keyword">master</span> <span class="hljs-title">master</span></code></pre><p>这样就将本地分支的内容，推送到远程仓库<code>origin</code>的<code>master</code>分支了。</p><h4 id="参数-u的作用"><a href="#参数-u的作用" class="headerlink" title="参数-u的作用"></a>参数-u的作用</h4><p><code>git push</code>的另外一种用法如下：  </p><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> -u 远程仓库名 本地分支名 远程分支名</code></pre><p><code>-u</code>参数的作用是，建立起本地<code>master</code>分支和远程<code>master</code>分支之间的对应关系，下一次如果再推送<code>master</code>分支，就可以忽略远程分支名了，如下所示：  </p><pre><code class="hljs crmsh"><span class="hljs-comment">#初次推送  </span>git push -u origin <span class="hljs-keyword">master</span> <span class="hljs-title">master</span>  <span class="hljs-comment">#再次推送  </span>git push origin <span class="hljs-keyword">master</span>  <span class="hljs-title"></span></code></pre><h3 id="4-拉取远程分支到本地"><a href="#4-拉取远程分支到本地" class="headerlink" title="4.拉取远程分支到本地"></a>4.拉取远程分支到本地</h3><p>拉取远程仓库的内容到本地，需要使用<code>git pull</code>命令，其命令格式为：  </p><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> pull 远程主机名 远程分支名 本地分支名</code></pre><p>其使用示例如下：  </p><pre><code class="hljs crmsh"><span class="hljs-comment">#将远程仓库origin的master分支的内容拉取到本地master分支  </span>git pull origin <span class="hljs-literal">master</span>:<span class="hljs-keyword">master</span>  <span class="hljs-title"></span></code></pre><h4 id="pull过程可能产生冲突"><a href="#pull过程可能产生冲突" class="headerlink" title="pull过程可能产生冲突"></a>pull过程可能产生冲突</h4><p>但是，在使用过程中，也可能会出现一种情况：远程分支和本地分支对同一内容做了修改，这就会导致将远程分支的修改，合并到本地分支的时候发生冲突。这个时候，可以选择解决冲突，然后合并（解决冲突会在后续的实训中介绍）。也可以选择直接强制拉取，使用远程分支的修改，覆盖本地分支的修改。强制拉取需要用到<code>-f</code>参数，语法格式如下：  </p><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> pull 远程主机名 远程分支名 本地分支名 -f</code></pre><p>具体的使用示例如下：  </p><pre><code class="hljs crmsh"><span class="hljs-comment">#将远程仓库origin的master分支的内容拉取到本地master分支  </span>git pull origin <span class="hljs-literal">master</span>:<span class="hljs-keyword">master</span> <span class="hljs-title">-f</span></code></pre><h2 id="三、分支管理"><a href="#三、分支管理" class="headerlink" title="三、分支管理"></a>三、分支管理</h2><h3 id="1-创建-切换本地分支"><a href="#1-创建-切换本地分支" class="headerlink" title="1.创建/切换本地分支"></a>1.创建/切换本地分支</h3><blockquote><p>当你进入一个团队，在获得产品的完整代码之后，你首先要做的就是，在本地创建一个属于自己的分支，然后才能在自己的分支上进行开发。</p></blockquote><p>我们在<code>master</code>分支上，进行了<code>C1</code>、<code>C2</code>、<code>C3</code>三次提交，且当前指针指向<code>C3</code>提交。<br>一般情况下，我们只会将已经成熟的代码存放到<code>master</code>分支，而将正在开发的代码或者测试版的代码放到其他分支。这时，我们就需要新建分支，以在该分支进行开发。如下图：  </p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220504204122931.png" alt="image-20220504204122931">  </p><p>当我们在主分支进行了<code>C2</code>提交后，新建了<code>develop</code>分支，并在其上进行了两次提交。此时，工作区指针<code>HEAD</code>指向<code>develop</code>分支。<br>创建本地分支用到的命令是<code>git branch</code>，而分支切换用到的命令是<code>git checkout</code>。<code>git checkout</code>是有很多用途的命令，在这里我们只讲它在分支操作中的使用。下面我们详细介绍这两个命令的使用。  </p><ul><li><p><strong>分支切换</strong><br>可以使用<code>git checkout</code> 命令切换到其他分支。如你本地有<code>master</code>分支和<code>develop</code>分支，目前你正处于<code>develop</code>分支进行开发，现在你想切换到<code>master</code>去，则可以执行下面的操作：<br><code>git checkout master</code><br>这样就能切换到<code>master</code>分支继续进行开发。</p></li><li><p><strong>创建新的分支</strong></p><p>当你需要创建一个新的分支的时候，可以使用<code>git branch</code>命令，其具体使用格式为：</p><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span>新的分支名字</code></pre><p>使用示例如下：</p><pre><code class="hljs vala"><span class="hljs-meta">#创建名为new_branch的新分支  git branch new_branch  </span></code></pre></li><li><p><strong>创建新分支的同时切换</strong><br>切换到一个新的分支，有一个更为简洁的命令：<code>git checkout -b</code>，它的使用格式为：<br><code>git checkout -b 新的分支 名字</code><br>其具体使用方法如下：<br><code>git checkout -b new_branch</code><br>这样就可以创建，并切换到了<code>new_branch</code>分支。</p></li></ul><h3 id="2-删除本地分支"><a href="#2-删除本地分支" class="headerlink" title="2.删除本地分支"></a>2.删除本地分支</h3><p>在开发过程中，很可能出现的一个情况是：你为了解决一个紧急<code>bug</code>，而临时创建了一个分支或者分支过于混乱需要丢弃。这时你就需要进行分支删除操作。</p><p>本关任务：删除本地分支。</p><h4 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h4><p>现在我们来看一个实际的例子。请看下图：  </p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220504210335362.png" alt="image-20220504210335362" style="zoom:67%;">  </p><p>首先，我们在<code>master</code>工作到 <code>C1</code>，然后开始一个新分支<code>develop</code>分支，做为测试版的代码分支。提交到<code>C5</code>的时候，又需要临时解决一个问题，于是从<code>C5</code>的地方又分出一个分支<code>issue</code>。提交到<code>C7</code>的时候，该<code>issue</code>被解决。<code>issue</code>分支已经失去其意义，则需要将其删除，以保持本地版本库分支树的干净。我们将<code>issue</code>分支上的代码，合并到<code>develop</code>上之后，就可将<code>issue</code>分支删除。删除<code>issue</code>分支后的分支树如下：</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220504210346301.png" alt="image-20220504210346301" style="zoom:67%;">  </p><p>其中，<code>C8</code>为合并<code>issue</code>分支所进行的提交。</p><p>删除本地分支，需要用到<code>git branch</code>命令，且需要<code>-D</code>参数，具体命令格式为：<br></p><pre><code class="hljs mathematica">git branch -<span class="hljs-keyword">D</span> 需要删除的分支的名字</code></pre><p></p><p>具体使用示例如下：  </p><pre><code class="hljs mipsasm"><span class="hljs-comment">#删除develop分支  </span>git <span class="hljs-keyword">branch </span>-D develop</code></pre><p>示例中的命令，能够将本地分支<code>develop</code>删除。</p><h3 id="3-删除远程分支"><a href="#3-删除远程分支" class="headerlink" title="3.删除远程分支"></a>3.删除远程分支</h3><blockquote><p>在开发过程中，有时可能由于产品变更，或者版本变更，而需要丢弃远程版本库中某个分支的内容。这个时候，你就需要一系列操作，来确保安全有效地删除远程分支。</p></blockquote><h4 id="两种删除方法"><a href="#两种删除方法" class="headerlink" title="两种删除方法"></a>两种删除方法</h4><p>删除分支用到的<code>git</code>命令是<code>git push</code>，在具体的使用过程中有不同的用法。  </p><ol><li><strong>通过推送空分支到远程分支，实现删除</strong>：</li></ol><p>一个删除远程分支的方法是，推送一个空分支到远程指定分支，以实现删除。推送本地分支到远程分支的方法是：<br><code>git push 远程主机名 本地分支:远程分支</code></p><p>与之类似，推送空分支实现删除的方法是：<br>　　<code>git push 远程主机名 :远程分支</code><br>即<code>：</code>前没有指定本地分支名。具体的使用示例如下：  </p><pre><code class="hljs maxima">#删除远程develop分支，其中<span class="hljs-built_in">origin</span>为远程仓库名  git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> :develop</code></pre><ol><li><strong>通过<code>delete</code>参数删除远程分支</strong>：</li></ol><p>除了推送空分支到远程分支外，也可以通过<code>delete</code>参数实现删除。具体的命令格式为：</p><pre><code class="hljs gauss">git <span class="hljs-keyword">push</span> 远程主机名 --<span class="hljs-keyword">delete</span> 远程分支名</code></pre><p>具体使用示例如下：</p><pre><code class="hljs maxima">#删除远程develop分支,其中<span class="hljs-built_in">origin</span>为远程主机名  git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --<span class="hljs-built_in">delete</span> develop</code></pre><h3 id="4-本地分支合并"><a href="#4-本地分支合并" class="headerlink" title="4.本地分支合并"></a>4.本地分支合并</h3><blockquote><p>在协作开发中，团队中每个人可能都只负责一个模块。所以，很有可能，你在开发过程中，需要用到别人所开发的功能。这个时候就需要将别人分支的内容，合并到你自己的分支；或者，<code>develop</code>分支或者<code>master</code>分支有更新，你也需要将它们的修改，合并到你的分支，以跟上产品开发进程；也有可能你为了解决一个<code>bug</code>，创建临时分支，完成开发后，需要将其合并到你的分支。这些都需要分支合并的知识。</p></blockquote><p>分支合并需要用到<code>git merge</code>命令，具体的命令格式为：</p><pre><code class="hljs cos">git <span class="hljs-keyword">merge</span> 需要合并的分支</code></pre><p>在具体使用中，如当前处于<code>master</code>分支，需要将<code>develop</code>分支合并到<code>master</code>分支，则具体的使用方式如下：</p><pre><code class="hljs cos">git <span class="hljs-keyword">merge</span> develop</code></pre><p>同时，分支合并也分为正常合并和快进式合并，通过为<code>git merge</code>添加参数，即可实现不同操作。</p><ul><li><strong>快进式合并</strong></li></ul><p>具体命令如下：</p><pre><code class="hljs livecodeserver">git <span class="hljs-built_in">merge</span> <span class="hljs-comment">--no-ff develop</span></code></pre><p>默认情况下，<code>Git</code>执行”快进式合并”，即<code>fast-farward merge</code>，会直接将被合并的分支指向需要合并的分支。如下图：</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220504211936606.png" alt="image-20220504211936606" style="zoom: 50%;"></p><ul><li><strong>正常合并</strong></li></ul><p>命令具体如下：</p><pre><code class="hljs cos">git <span class="hljs-keyword">merge</span> develop</code></pre><p>正常合并的方式如下图：</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220504212319049.png" alt="image-20220504212319049" style="zoom:50%;"></p><p>如图所示，<code>Master</code>分支上产生了一次新的提交，也就是说生成一个新节点完成了合并，这样的话，版本演进更清晰。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>下面我们以一个具体的例子，来演示一下这两种合并方式的区别：  </p><ol><li>创建<code>master</code>分支，并在其上提交<code>hello</code>文件；</li><li>从<code>master</code>分支切换到新分支<code>develop</code>，并进行两次提交，分别将<code>hello1</code>、<code>hello2</code>两个文件提交到<code>develop</code>分支；</li><li>切换回<code>master</code>分支，执行<code>git merge develop</code>进行快进式合并，然后查看<code>master</code>分支的日志，得到如下提示信息：</li></ol><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220504212558452.png" alt="image-20220504212558452"></p><p>如上图可知，<code>master</code>分支多了<code>develop</code>分支上的两次提交信息。</p><ol><li>将<code>master</code>分支回退到合并前状态，再次执行<code>git merge --no-ff develop</code>，进行非快进式合并，然后再次查看日志：   </li></ol><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220504212613766.png" alt="image-20220504212613766"></p><h2 id="四、日志与版本回退"><a href="#四、日志与版本回退" class="headerlink" title="四、日志与版本回退"></a>四、日志与版本回退</h2><h3 id="1-回到前一次提交"><a href="#1-回到前一次提交" class="headerlink" title="1.回到前一次提交"></a>1.回到前一次提交</h3><blockquote><p>如果提交到本地仓库中的代码发现了<code>bug</code>，就必须将代码回到上一个版本。而在<code>Git</code>中，一次提交就对应着一个版本，因此可以根据日志信息进行版本回退。</p></blockquote><h4 id="日志的基本用法"><a href="#日志的基本用法" class="headerlink" title="日志的基本用法"></a>日志的基本用法</h4><p>在之前，我们已经介绍了<code>git log</code>的基本使用方法，这里我们要进一步介绍<code>git log</code>的使用。  </p><ul><li>查看提交的内容差异<br><code>git log</code>提供了<code>-p</code>参数，用于查看每次提交之间的内容差异。<code>git log -p</code>即可显示每次提交之间的变化。</li><li>而如果想限制显示的范围，则可以再添加参数用于限定：<code>git log -p -2</code>这样，则仅显示最近的两次更新。</li><li>其他<code>git log</code>选项：  <ol><li>单词层面对比<br><code>Git</code>提供了<code>--word-diff</code>选项，可以显示单词层面的差异。当需要在书籍、论文这种很大的文本文件上，进行对比的时候，这个功能就非常有用。</li><li>显示简要的增改行数<br><code>Git</code>提供了<code>--stat</code>选项，则可以仅显示增加或者减少了多少行。</li><li><code>pretty</code>选项<br>使用<code>--pretty</code> 选项选项，可以指定不同的显示属性，如<code>oneline</code> 将每个提交放在一行显示。 <code>short</code>，<code>full</code> 和 <code>fuller</code> 可以指定展示的信息的多少。</li></ol></li></ul><h4 id="git-revert实现版本回退"><a href="#git-revert实现版本回退" class="headerlink" title="git revert实现版本回退"></a>git revert实现版本回退</h4><p>版本回退可以用<code>git revert</code>命令。<code>git revert</code>撤销提交时，会保留所撤销的提交的记录和历史，并将撤销操作做为一次新的提交。即提交一个新的版本，将需要<code>revert</code>的版本的内容再反向修改回去，版本会递增，不影响之前提交的内容。其具体的使用方法如下：<br>    * git revert HEAD          撤销前一次 commit<br>    * git revert HEAD^         撤销前前一次 commit<br>    * git revert commit （比如：fa042ce57ebbe5b）撤销指定的版本，撤销也会作为一次提交进行保存</p><h4 id="git-reset实现版本回退"><a href="#git-reset实现版本回退" class="headerlink" title="git reset实现版本回退"></a>git reset实现版本回退</h4><p><code>git reset</code>也能实现版本回退，但是<code>git revert</code> 和 <code>git reset</code>也存在一定的区别 ：  </p><ul><li><code>git revert</code>是用一次新的<code>commit</code>来回滚之前的<code>commit</code>，<code>git reset</code>是直接删除指定的<code>commit</code>；</li><li>在回滚这一操作上看，效果差不多。但是，在日后继续<code>merge</code>以前的老版本时有区别。因为<code>git revert</code>是用一次逆向的<code>commit</code>，“中和”之前的提交，因此日后合并老的<code>branch</code>时，导致这部分改变不会再次出现。但是<code>git reset</code>是把某些<code>commit</code>在某个<code>branch</code>上删除，因而和老的<code>branch</code>再次<code>merge</code>时，这些被回滚的<code>commit</code>应该还会被引入；</li><li><code>git reset</code> 是把<code>HEAD</code>向后移动了一下，而<code>git revert</code>是<code>HEAD</code>继续前进，只是新的<code>commit</code>的内容和要<code>revert</code>的内容正好相反，能够抵消要被<code>revert</code>的内容。</li></ul><p><code>git reset</code>用法如下：  </p><ul><li><code>git reset HEAD</code><br>回到前一次 <code>commit</code>。也可以用于将错误的文件添加进暂存区后，想回退取消，如：<br>　　<code>git reset HEAD 文件名</code>  </li><li><code>git reset HEAD^</code><br>回到前前一次 <code>commit</code>。  </li><li><code>git reset commit</code><br>比如：<code>commit = fa042ce57ebbe5b</code>，回到指定的版本，撤销也会作为一次提交进行保存。</li></ul><p>另外<code>git reset</code>也可以指定<code>reset</code>的模式：<code>hard</code>、<code>soft</code>、<code>mixed</code>、<code>merged</code>、<code>keep</code>。   这几种模式的差别如下：  </p><ul><li><code>--soft</code> 缓存区和工作目录都不会被改变；</li><li><code>--mixed</code> – 默认选项。缓存区和你指定的提交同步，但工作目录不受影响；</li><li><code>--hard</code> – 缓存区和工作目录，都同步到你指定的提交。</li></ul><p>几种模式的具体使用方法如下：  </p><pre><code class="hljs sql"><span class="hljs-comment">#直接丢弃工作区和暂存区的修改  </span>git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD  </span><span class="hljs-comment">#暂存区内容保留，工作区修改丢弃  </span>git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--mixed HEAD  </span><span class="hljs-comment">#暂存区和工作区内容都保留  </span>git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--soft HEAD  </span></code></pre><h3 id="2-删除文件"><a href="#2-删除文件" class="headerlink" title="2.删除文件"></a>2.删除文件</h3><blockquote><p>在Git使用过程中，涉及到撤回的操作，还有从暂存区或者分支删除文件。比如你错误地将测试过程中产生的日志文件提交到了暂存区或者分支上面去了，那么你可能就需要删除文件。</p></blockquote><p>删除文件需要用到的命令是<code>git rm</code>，且<code>git rm</code>有参数<code>--cached</code>。   当我们需要删除暂存区或分支上的文件，同时工作区也不再需要这个文件了，可以使用：<br><code>git rm 文件路径</code><br>当我们需要删除暂存区或分支上的文件，<strong>但本地又需要使用</strong>， 只是不希望这个文件被提交到版本库，可以使用：<br><code>git rm --cached 文件路径</code></p><blockquote><p>简单来说就是，一般情况下使用<code>git rm 文件路径</code>；想要保留工作区（本地）的时候，添加—cached。</p></blockquote><h2 id="五、标签"><a href="#五、标签" class="headerlink" title="五、标签"></a>五、标签</h2><h2 id="六、高阶操作"><a href="#六、高阶操作" class="headerlink" title="六、高阶操作"></a>六、高阶操作</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://www.educoder.net/paths/41">https://www.educoder.net/paths/41</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探讨智能指针</title>
    <link href="/Wuhlan3/2022/04/17/%E6%8E%A2%E8%AE%A8%E4%B8%80%E4%B8%8B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/Wuhlan3/2022/04/17/%E6%8E%A2%E8%AE%A8%E4%B8%80%E4%B8%8B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1>探讨智能指针</h1><p>C++中，动态内存的管理需要依靠一对运算符来完成：<strong>new</strong>，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化；<strong>delete</strong>，接受一个动态对象的指针，销毁该对象，释放与之关联的内存。</p><p>但是，动态内存的使用很容易出现问题。</p><ul><li>当忘记释放内存时，就会造成内存泄漏；</li><li>若上有指针引用内存，我们就提前释放了该内存，就会产生引用了非法内存的指针（悬空指针）。</li></ul><p>为了更容易地使用动态内存，新的标准库提供了两种智能指针类型来管理动态对象。（定义在memory头文件中）</p><ul><li><code>shared_ptr</code> 允许多个指针指向同一个对象；</li><li><code>unique_ptr</code> 则独占所指向的对象；</li><li><code>weak_ptr</code>，是一种弱引用，指向<code>shared_ptr</code> 管理的对象。</li></ul><h2 id="shared-ptr">shared_ptr</h2><pre><code class="hljs cpp"><span class="hljs-comment">//空智能指针，</span><span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; p1;<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; p2;<span class="hljs-comment">//使用的时候需要判断，是否为空</span><span class="hljs-keyword">if</span>(p1  &amp;&amp; p1-&gt;empty())    *p1 = <span class="hljs-string">"hi"</span>;    <span class="hljs-comment">//更加安全的创建方法是使用make_shared&lt;T&gt;函数</span><span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p3 = make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">42</span>);<span class="hljs-comment">//指向值为42的对象</span><span class="hljs-keyword">auto</span> p4 = make_shared&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">10</span>,<span class="hljs-string">'9'</span>);<span class="hljs-comment">//指向"9999999999"字符串</span><span class="hljs-keyword">auto</span> p5 = make_shared&lt;<span class="hljs-keyword">int</span>&gt;();<span class="hljs-comment">//值为0</span><span class="hljs-comment">//拷贝构造</span><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">p6</span><span class="hljs-params">(p5)</span></span>;<span class="hljs-comment">//赋值运算符</span>p3 = p6;</code></pre><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220415222039697.png" alt="image-20220415222039697" style="zoom:50%;"><div class="note note-success">            <p>需要特别注意的是，当调用拷贝构造函数后，引用计数递增。相当于有两个指针指向对象；</p><p>当进行赋值运算时，如<code>p=q</code>，q的引用计数递增，p的引用计数递减。两个指针都指向q的所指对象。</p>          </div><p><strong>shared_ptr自动销毁所管理的对象</strong><br>当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象，它是通过析构函数完成销毁工作的。shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它所占用的内存。</p><pre><code class="hljs c++"><span class="hljs-comment">//p离开作用域，指向的内存会被自动释放掉</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T arg)</span></span>{    <span class="hljs-built_in">shared_ptr</span>&lt;Foo&gt; p = factory(arg);}<span class="hljs-comment">//但是p作为返回值时，内存不会被立刻释放掉</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T arg)</span></span>{    <span class="hljs-built_in">shared_ptr</span>&lt;Foo&gt; p = factory(arg);    <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//当返回p时，引用计数进行了递增操作</span>}<span class="hljs-comment">//p离开了作用域，但它指向的内存不会被释放掉</span></code></pre><p><strong>shared_ptr还会自动释放相关联的内存</strong><br>当动态对象不再被使用时，shared_ptr类还会自动释放动态对象，这一特性使得动态内存的使用变得非常容易。如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的那些元素。</p><p><strong>程序使用动态内存的原因</strong>：<br>（1）程序不知道自己需要使用多少对象<br>（2）程序不知道所需对象的准确类型<br>（3）程序需要在多个对象间共享数据</p><p><strong>定义和改变shared_ptr的其他方法</strong>：</p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220415225733681.png" alt="image-20220415225733681" style="zoom:80%;"><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220415225811513.png" alt="image-20220415225811513" style="zoom:80%;"><h2 id="unique-ptr">unique_ptr</h2><p>一个unique_ptr“拥有”它所指向的对象，某个时刻只能有一个unique_ptr指向一个给定的对象。没有类似<code>make_shared</code>的函数，所以定义unique_ptr的时候要绑定到一个new返回的指针上。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>))</span></span>;</code></pre><div class="note note-success">            <p>unique_ptr不支持拷贝、赋值操作</p>          </div><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220415230616073.png" alt="image-20220415230616073" style="zoom: 33%;"><p><strong>unique_ptr所有权的转移</strong></p><pre><code class="hljs c++"><span class="hljs-comment">//所有权从p1转移给p2</span><span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p1.release())</span></span>;<span class="hljs-comment">//将p3所有权转移给p2</span><span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">"Tom"</span>))</span></span>;p2.reset(p3.release());<span class="hljs-comment">//reset释放了p2原来指向的内存</span></code></pre><p>不能拷贝unique_ptr有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr.最常见的例子是从函数返回一个unique_ptr.</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">//正确：从int*创建一个unique_ptr&lt;int&gt;</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(p));}</code></pre><p>还可以返回一个局部对象的拷贝：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span><span class="hljs-function"></span>{    <span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(p))</span></span>;    <span class="hljs-keyword">return</span> ret;}</code></pre><h2 id="weak-ptr">weak_ptr</h2><p>weak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个由shared_ptr管理的对象。将一个weak_ptr绑定到shared_ptr不会改变引用计数。</p><p>主要是用于解决shared_ptr循环引用的问题。</p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/image-20220415231814811.png" alt="image-20220415231814811" style="zoom: 33%;"><pre><code class="hljs angelscript"><span class="hljs-built_in">auto</span> p = make_shared&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">42</span>);weak_ptr&lt;<span class="hljs-built_in">int</span>&gt; wp(p);</code></pre><p>由于对象可能不存在，我们<strong>不能使用weak_ptr直接访问对象</strong>，而必须调用lock，此函数检查weak_ptr指向的对象是否存在。如果存在，lock返回一个指向共享对象的shared_ptr,如果不存在，lock将返回一个空指针。</p><div class="note note-success">            <p>面试官曾经问过。如果shared_ptr都已经释放掉了，那么weak_ptr还能够访问哪个对象吗？</p><p>将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象也还是会被释放。在实际访问中，可以根据lock的返回值来判断对象是否还存在。</p>          </div><p><strong>shared_ptr可以直接赋值给一个weak_ptr，那么如何使用weak_ptr初始化一个shared_ptr呢？</strong></p><p>使用lock函数</p><pre><code class="hljs c++"><span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; ptr = make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">10</span>);  weak_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr1 = ptr; <span class="hljs-comment">// 必须使用shared_ptr初始化weak_ptr  </span><span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; ptr2 = ptr1.lock(); <span class="hljs-comment">// 利用返回的shared_ptr初始化 </span></code></pre><h2 id="其他问题">其他问题</h2><h2 id="参考资料">参考资料</h2><p>[1]《C++ Primer中文版 第五版》</p><p>[2] <a href="https://blog.csdn.net/flowing_wind/article/details/81301001">https://blog.csdn.net/flowing_wind/article/details/81301001</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文解决位运算</title>
    <link href="/Wuhlan3/2022/04/15/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/Wuhlan3/2022/04/15/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="一文解决位运算"><a href="#一文解决位运算" class="headerlink" title="一文解决位运算"></a>一文解决位运算</h1><h2 id="技法1：减一与"><a href="#技法1：减一与" class="headerlink" title="技法1：减一与"></a>技法1：减一与</h2><p>我们先来关注一个特性：</p><pre><code class="hljs asciidoc">对于数字1111001000，对其减一可得：1111000111将两个数字做与运算，可得11110000000<span class="hljs-code">1111001000</span>&amp;1111000111---------------<span class="hljs-code">11110000000</span>我们会发现，经过n = n&amp;(n-1)之后，我们可以将最后的一个1消去</code></pre><p>有了这个特性，我们可以解决下面这些题目：</p><h3 id="231-2-的幂"><a href="#231-2-的幂" class="headerlink" title="231. 2 的幂"></a><a href="https://leetcode-cn.com/problems/power-of-two/">231. 2 的幂</a></h3><p>解：2的幂特点就是，1、100、10000、10000000。只有1个“1”。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{    <span class="hljs-keyword">return</span> (n&gt;<span class="hljs-number">0</span>)&amp;&amp;(n&amp;(n<span class="hljs-number">-1</span>))==<span class="hljs-number">0</span>;}</code></pre><h3 id="342-4的幂"><a href="#342-4的幂" class="headerlink" title="342. 4的幂"></a><a href="https://leetcode-cn.com/problems/power-of-four/">342. 4的幂</a></h3><p>解：在2的幂基础上，分类讨论。其中$2^{2x+1}mod3==2$、$2^{2x}mod3==1$</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPowerOfFour</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{    <span class="hljs-keyword">return</span> n&gt;<span class="hljs-number">0</span> &amp;&amp; (n&amp;(n<span class="hljs-number">-1</span>))==<span class="hljs-number">0</span> &amp;&amp; (n%<span class="hljs-number">3</span> == <span class="hljs-number">1</span>);}</code></pre><h3 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a><a href="https://leetcode-cn.com/problems/number-of-1-bits/">191. 位1的个数</a></h3><p>解：循环地将最后一个1消去，即可数出1的个数。</p><h3 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a><a href="https://leetcode-cn.com/problems/hamming-distance/">461. 汉明距离</a></h3><p>解：先取异或，然后统计1的个数。</p><h2 id="技法2：异或相消"><a href="#技法2：异或相消" class="headerlink" title="技法2：异或相消"></a>技法2：异或相消</h2><pre><code class="hljs tp">假设a <span class="hljs-comment">!= b</span><span class="hljs-comment">那么 a ^ b ^ a = b;</span></code></pre><h3 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></h3><blockquote><p>进阶（虽然没有用到异或相消原则）</p><h3 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137. 只出现一次的数字 II"></a><a href="https://leetcode-cn.com/problems/single-number-ii/">137. 只出现一次的数字 II</a></h3><p>统计每个位是否为3的倍数，如果是，则ans的该位数字为1</p><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">32</span>; i ++){    <span class="hljs-built_in">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">auto</span> x : nums){        sum  += (x &gt;&gt; i)&amp;<span class="hljs-number">1</span>;    }    ans += sum%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>? <span class="hljs-number">0</span> : <span class="hljs-number">1</span> &lt;&lt; i;}<span class="hljs-keyword">return</span> ans;</code></pre></blockquote><h2 id="技法3：正负值异或"><a href="#技法3：正负值异或" class="headerlink" title="技法3：正负值异或"></a>技法3：正负值异或</h2><pre><code class="hljs ini"><span class="hljs-attr">low</span> = n &amp; (-n)<span class="hljs-comment">;</span></code></pre><p>这样可以获取最低位的1。可以解决下面这样的问题：</p><h3 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260. 只出现一次的数字 III"></a><a href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a></h3><h2 id="技法4：数字交换"><a href="#技法4：数字交换" class="headerlink" title="技法4：数字交换"></a>技法4：数字交换</h2><p><strong>加减数字交换</strong>(可能产生溢出)</p><pre><code class="hljs ini"><span class="hljs-attr">a</span> = a + b<span class="hljs-comment">;</span><span class="hljs-attr">b</span> = a - b<span class="hljs-comment">;</span><span class="hljs-attr">a</span> = a - b<span class="hljs-comment">;</span></code></pre><p><strong>异或数字交换</strong></p><pre><code class="hljs ini"><span class="hljs-attr">a</span> = a^b<span class="hljs-comment">;</span><span class="hljs-attr">b</span> = a^b<span class="hljs-comment">;</span><span class="hljs-attr">a</span> = a^b<span class="hljs-comment">;</span></code></pre><p>为什么可以呢？我们展开来看看：</p><pre><code class="hljs ini"><span class="hljs-attr">a</span> = a^b<span class="hljs-comment">;</span><span class="hljs-attr">b</span> = a^b = a^b^b = a<span class="hljs-comment">;</span><span class="hljs-attr">a</span> = a^b = a^b^a = b<span class="hljs-comment">;</span></code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="693-交替位二进制数"><a href="#693-交替位二进制数" class="headerlink" title="693. 交替位二进制数"></a><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/">693. 交替位二进制数</a></h3><p>解：可以使用3（二进制为11）来循环作与运算</p><h3 id="371-两整数之和"><a href="#371-两整数之和" class="headerlink" title="371. 两整数之和"></a><a href="https://leetcode-cn.com/problems/sum-of-two-integers/">371. 两整数之和</a></h3><p>解：使用与来计算进位，使用异或来计算当前为的数字。</p><h3 id="面试题-05-01-插入"><a href="#面试题-05-01-插入" class="headerlink" title="面试题 05.01. 插入"></a><a href="https://leetcode-cn.com/problems/insert-into-bits-lcci/">面试题 05.01. 插入</a></h3>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/Wuhlan3/2022/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/Wuhlan3/2022/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h2><p>单例模式是指整个系统生命周期内，保证一个类只能产生一个实例，确保该类的唯一性。</p><blockquote><p>例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。</p><p>在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。</p></blockquote><h2 id="单例模式有什么特点呢？"><a href="#单例模式有什么特点呢？" class="headerlink" title="单例模式有什么特点呢？"></a>单例模式有什么特点呢？</h2><p>构造函数和析构函数为私有类型，目的是禁止外部构造和析构。</p><ul><li>构造函数和析构函数为私有类型，目的是禁止外部构造和析构。</li><li>拷贝构造函数和赋值构造函数是私有类型，目的是禁止外部拷贝和赋值，确保实例的唯一性。</li><li>类中有一个获取实例的静态方法，可以全局访问。</li></ul><h2 id="C-单例模式的三种实现"><a href="#C-单例模式的三种实现" class="headerlink" title="C++单例模式的三种实现"></a>C++单例模式的三种实现</h2><h3 id="1-普通懒汉式单例（线程不安全）"><a href="#1-普通懒汉式单例（线程不安全）" class="headerlink" title="1.普通懒汉式单例（线程不安全）"></a>1.普通懒汉式单例（线程不安全）</h3><p>懒汉式：单例实例在第一次被使用时才进行初始化。</p><p>第一次使用实例对象时，创建对象。进程启动无负载。多个单例实例启动顺序自由控制。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span><span class="hljs-class">{</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">static</span> Singleton* s_instance;<span class="hljs-keyword">private</span>:    Singleton() {};    ~Singleton() {};    Singleton(<span class="hljs-keyword">const</span> Singleton&amp;);    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Singleton&amp;);<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span><span class="hljs-function">    </span>{        <span class="hljs-keyword">if</span>(s_instance == <span class="hljs-literal">nullptr</span>)             s_instance = <span class="hljs-keyword">new</span> Singleton();        <span class="hljs-keyword">return</span> s_instance;    }    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteInstance</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">if</span> (s_instance)        {            <span class="hljs-keyword">delete</span> s_instance;            s_instance = <span class="hljs-literal">nullptr</span>;        }    }};Singleton* Singleton::s_instance = <span class="hljs-literal">nullptr</span>;</code></pre><blockquote><p>补充一下，类中static函数的作用：</p><p>在类里的函数前加static，则这个函数就与对象无关了，这个类产生的所有对象共用这一个静态成员函数，<br>静态成员函数可以在尚未创建任何对象时就被调用，他只可以操作类中的静态数据成员。</p></blockquote><h3 id="2-加锁的懒汉式单例（双检锁）"><a href="#2-加锁的懒汉式单例（双检锁）" class="headerlink" title="2.加锁的懒汉式单例（双检锁）"></a>2.加锁的懒汉式单例（双检锁）</h3><p>双检锁，既保证了效率又保证了安全。</p><p>为什么要双检锁呢？假设有两个线程同时调用<code>getInstance()</code>，那么很有可能两个线程都通过了第一个判空，之后两个线程在争抢锁。这个时候里面就需要再次判空。外层的判空，是为了减少争抢锁排队的情况；内层的判空，是为了确保只new一个实例（重复new会导致内存泄漏，且违背单例模式）。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;mutex&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span><span class="hljs-class">{</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">static</span> Singleton* s_instance;    <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::mutex s_mutex;<span class="hljs-keyword">private</span>:    Singleton() {};    ~Singleton() {};    Singleton(<span class="hljs-keyword">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<span class="hljs-keyword">public</span>:    <span class="hljs-comment">//双检锁，第一次调用时，实例化</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span><span class="hljs-function">    </span>{        <span class="hljs-keyword">if</span>(s_instance == <span class="hljs-literal">nullptr</span>){            <span class="hljs-function"><span class="hljs-built_in">std</span>::unique_lock&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(s_mutex)</span></span>;            <span class="hljs-keyword">if</span>(s_instance == <span class="hljs-literal">nullptr</span>){                s_instance = <span class="hljs-keyword">new</span> Singleton();            }        }         <span class="hljs-keyword">return</span> s_instance;    }    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteInstance</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-function"><span class="hljs-built_in">std</span>::unique_lock&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(s_mutex)</span></span>;        <span class="hljs-keyword">if</span> (s_instance)        {            <span class="hljs-keyword">delete</span> s_instance;            s_instance = <span class="hljs-literal">nullptr</span>;        }    }};<span class="hljs-built_in">std</span>::mutex Singleton::s_mutex;Singleton* Singleton::s_instance = <span class="hljs-literal">nullptr</span>;</code></pre><h3 id="3-饿汉模式"><a href="#3-饿汉模式" class="headerlink" title="3.饿汉模式"></a>3.饿汉模式</h3><p>程序启动时就创建一个唯一的实例对象。</p><p>可能会导致进程启动慢，且如果有多个单例类对象实例启动顺序不确定。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span><span class="hljs-class">{</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> &amp;s_instance;    }<span class="hljs-keyword">private</span>:    Singleton(){};    Singleton(Singleton <span class="hljs-keyword">const</span>&amp;) = <span class="hljs-keyword">delete</span>;    Singleton&amp; <span class="hljs-keyword">operator</span>=(Singleton <span class="hljs-keyword">const</span>&amp;) = <span class="hljs-keyword">delete</span>;    <span class="hljs-keyword">static</span> Singleton s_instance;};Singleton Singleton::s_instance; <span class="hljs-comment">// 在程序入口之前就完成单例对象的初始化</span></code></pre><h3 id="单例模式是否会被破坏？"><a href="#单例模式是否会被破坏？" class="headerlink" title="单例模式是否会被破坏？"></a>单例模式是否会被破坏？</h3><ul><li>反射（虽然C++没有这个机制，但可以了解一下）</li><li>序列化（反序列化的过程中可能再创一个对象）</li><li>克隆</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【加密】2022旧章</title>
    <link href="/Wuhlan3/2022/04/10/%E6%97%A5%E8%AE%B0/"/>
    <url>/Wuhlan3/2022/04/10/%E6%97%A5%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="ac7525fe010cff0c9eb581952098706acccff506ef019d52d6d50655b0c447dc">bf0a02ce0d42d253ca5b05eb9d127de9b173997fd80e4b7458304cf2ed11d0d65a6f5ac855c63cafb1afea4841dfe1b24e838352a4a288c9e0234c25f98a97cc959ec7ceba7dcc0bed9be26d276bb6da98d6a33ea15749fe37f143118df2ac6ebc6498857ff3235b0243cc1ae648ef07d9f837f2ca005acf28f08efb4c81cb4cae8df9c7b25380fbef8c389c10a562cf1aca2d893bb58fe6fe11b07328888da5e7630bd05dbdc1d7cdf8497e5e24d85e2876fb78e849cc7444189c12eedeac9d48f73743f845ba1b5c838f4b553bc436b615b3926ae10237d7ed048a78ea683ccbacd140a0b4277948f94a38f96e18a01740cbcd085deed06ec19938b9db48cd05f047aa32d38d596772e1c69649d2306ec9d205505047bd1b0f34d4ed26e974009a8c88f3f16edd7160068b4a9fee8fa23c5372dd1b7d2011c38931a070fe954822d61dca114712c807c66bd30fdf1864dbea859f8ea3c891725eb4342b3318608ff294409e832f36d62d9da6c347d3adec355156a5591f389b83fe225a24402157425ecde7652c6b555fd10760a5d3d926b59183034f41b913c308daebc4b5904ec54ce06a16ca0223323dfe559f9d770e45f06a325b7a859ff94b9cb03549f74c32aaef0f40088134fd881e6f18417f9a88bf6932d3b538d976ea4b4d9e8d5c992e8e755751b71bd31ea7b9bef7f6f723dce70113f9ec5774daa212dda00398d284682f598e53fea068b9c392b394e6f76dd7182500918c74bd75de0adff93fa868ec91db7a1dce66d369d3bcba7a06019e133d5058197164c14e7784436a0cbcb1670f0118df94f84d8b3c6dca5197bb082356c8fe7f8199303a39d225acfbdf0c30d281f9985d7646702c596c7c5e6d1f11ae4c907d3187d43d19313b951854483b376dfb5fcc0fd3c6ef6e5b614a6e705bf40cabc5baec194264f601f5ef58c3aefbc05be933263a767994511c24e509a8b8afa5074ffef6ce713cb4e981d4e1ea7c99b0c2ba6a8ae81595f3fa0aa3e30911562b2c715e721d75160b7a8b2c32bf66229559a461b562013eafeb88c8a5d3f39250f716de6480267cd19ea2ad6cc5399cc716bd1b792f42a024c137687e26572e19336959b69dc7f2a3f1c830fd6f97182f8d7263b8ca2ad7366066b30217870bfe71b3806cdc3f78f365af3b4622f26d0388e67c634a482bc405898efd04817239a23ba1696902f315411261e75b82f718970311ee2688e3fd31a98b106e25f48112aac334c303053f9a57810ca00fa0dae98e50928136bf688ec262d35bdc623b158ca145f288fe4b6246f5c81b1537fc740511bca783fccaaf1edf560848b5865a093e67972fe83054091786eb2e00c6f0f8bcebd0e5811453ac0f0ac8c7ae04c37b665fc5a20aac33deac623b8d1826cd67b43ea2abcc05ad6de09cfb41fc7143db446c801e6b7818dbf979a2166f34ff74be6fbcf473508677d73ebd9f9edb436b62d3ecdab125a6f9783e6a588e7ba7aef0b816ba63c71e232ca4463f290c601b93dd64a905e9ad4fe0057e5094e855e26257fa2fa6a3d165b864d4edcd280491029b6e020ac787ca4b8772a270e6b1c7d18d23cf3231f6e2759b94384231144b28c76233643af74ff5ca41a37b67adb324fa44d99155bd259d68148acf0818958c4ead46b4e8e541448367024a156e57649329fe325884c3dea28f14ff30c5d6549569440ccc3dc86ee9d4fd8079ae70d8586e23ddaeee6cfd8eb0046312f655786ba2452d67452e6aedd8db3efd4c0937dfbf0419489c3fa78b8d73d98ec8ffe6f1519c1bced56e88ba41fde7afc8c1559e32ebe436868f0c6e01cd9579fd8458fdae25e2a83673c34ae08b338490d2b273f49e896ab4b0a8bed7fda5d510f9e9fb8f2496cef3d2a9f2be863acc2cc445ebe3eb9b95424497b4f4afcc3a20fb01ad8c1e654c22e7aeffe52a5ebd93e2013bede3e577c82ae26e5eed8730d9d0f1a4ccfb8eee355f9b1963215cf9576d847ee8c11fc5c5e2cbdc0335e6dbc6f81d171f9c5f89fe0be9eb2ba6a9b92f3d229065aaf50ecc875783999a2cd083019689c11b3df1098e6d80a0480bdc6d2719cfc99fb26df03ef3f555b6f713adaee132e5b84658341f66eed0a3f16b0cd1dbe889234b2efb6d2e672063ab61fd7495f2a6e1e7524fb1547e96ad34d7c000a95cd8618ffa4057cf6f6b79f606cf6791397d8ea44e29617bf1dec61083fbb0fc1e646fb19fdc46f585b37d7abd88ba6540843ffa9e52ec8a1383f14c208c6439f79e6cf576e59273a7f1dbc0fb111ba442aecc73fa1867a57340e24a5511bddd215597796c7e30089028075c64332d314f74d2ab4993dd173ce2103ccc5b57cb90da8f2a98e929c06443d9bdf47170f9303ebfeb96c237fc67330c2b18e4e38ca265939eb549a12027b9784a82fabc73aabe4085bfcf6fea9702dc0efadc995315e14dd03b2be57d88205a26c34d9f0605bfedb2a496ecabe602cc2fa4fc9ddcbe8d0ac4a55abca572fbcc45b2d3488071e3fae0456bcdfb658f4310a205b9547d412b95f30069d87442ec5cb874f734780680560fd526e8dd8c510da3976072497d3085abf521e4ef65685e52c3482380cf93385a0583fa5a77566393ad1bc8557959abbd5d3a5cba0604f24cbdce7f0f38a9b789b3d22cc3736184e16861faee74353e0ac9b2e6454c957c2967db634e43a979b5edcf2c9a9a424698c4459a4398d0ab3dc110534f78e47ace97cbfc9754e93b6473bda6920e6aa8ebd904d7966df09c46cd6b730e7c941ddfd60077ce1d73a873c783ac99a5cf4d1cd2b3f2f280ac4c0b294b5ca52d5ce91089991b842a49d8fe8b61991167c39eca3b54919d3f93b165d5543cc3c2beb55c485cc071700f750ce0f8d6ea5cb250232abfb33ca778307abd9ecf756b2ee1bcb10e368d456054001c83b8ca7e7a75f418298431f71c93200656995cc7a90be64e97c0cd7f05ea8f37698dd6da9e073d542ea5dd933d47b2d9557c0d1ae123fad65aef8bf4efd343f27a9ee2b6e0dfee1676ad4c43dc4daa8cc01502b9d1b91c02b752ef5603e1108c7a760b808c913f7b75c7223614843e9751b526d72e38bbd042966251bb67df90112c0a783ca959e15a49b76d42ba1871563a83ef73b50ba71ba882295edd10f7fcf27caa8bd43d5a3ceda1d6636a307596ff88dd0c7e3614ec2ea5c6956d349f431ff65f85f91b669ac1b6fc6f6fed481f97d1466083fef9e4559d1166924e0bb5bce6bf494ab385fc11c77abc577a37850d14afb9f305b6e0811059f698db41eebcc98de1f6d1437b4dcb20cb36f2c4fe7f192e4740b0297518f4284312fe2aca56526f05f84c71de55d501066b78060b9a67ba4212d341177f3146b2df24614c1ee7b61bbc1d9242624b46ed7c1c764318eb32bb035318cf633deae4b7b8b31eaf847852aecc87b855891cf0033db1b3021c99cc8555ee3efe2dc01bb0772319692081f1bce743922d613aef070960da00e0b45a6450e0df7e74e1aaf91b51a46e7f09272fc3f8f72a2987166b005ae0fa6facae8928a73870c4341a193bb18794e0fffde9dc1605756fe5afc3d880d54fab4f466bad991de3e463e54eccbec519341d48c29fe8c2f84e3b0a543873d084ecc5d88f5ed389a044071436acfe4fada27d943eaa1f7c1f1d3655c5f56d42e7eeb63e3b930ef5e59f8814193ce510543ecb60a74723a40b69d8b7274765de8fd49790353074a22c7bd621e11daa1f464111a98eba338029997556b26751edfa4d9300fb7933895deb7cedb3409957901713fdea345708cdddae73e52a8eb76db2d059e799b732ad88d79956a7cee668399ffc2ebac72f9ad53c0e72b0497e28738944a6ac8e5361181999e58e02490aa47fc7a3ed4c878ab84c8c7f3162ab83643e95d754aa3239b229224132436311163bb2bce69cdc7ae92459c8dbea09eb876c3ef81b822c2189bcdab7b51a40e918c0963b126e45c2d6606af241346cdb1b57f179c1dee1387ac8d0753d9ea824b83e5deb1253b18ab0219b5eab6b120daf59fc512726bdd75c9635847ce9526b8c2bbb96c1a4bb1543cd220d4ec9af4892ce7287f9ed60577911b86dab6cd192a05fa9e17b69d3b4b201998e14c06b9cd8190afa33e64f1847489229c531c5568cbeb1b68135fe99555859e6a62d6d09407a6b4ae96181d0ab18b572455a3f36e9222afcb0d2e54d1314f0932046a58ef973a2be57babf8436a737f986422ddcb370676ea4d4748a3435cf438e71520fd69fac17534a21a85f52c2956a951a15640c5933de093862a3ee283f50d99cbcf4a7283a87d69e021ac65e1a6507b9ca98bd08756f1b7614e1e59b3bfb122f29a6e9c858d447b0e152d71cee77d143faec1db2bafce76475146fb2e9b99be3810da5c430f3322a76503a1757ea9e65efa7f744d32d839890cd61ea304fb99906be2784c95f7eaaad93c27c6599b8ef7258aa65682e71eb80bca724bcc39c1779abe75a16ea3d520a1be8b95e846f3331c03e00027479ca916291f758fc8e2d6a7a56b43bd5cf65931aff68164aaa4ff892314e0e2a00dbc7a57a8ff692a8ef00c8a63cc6aeb00f918c5814bbbd86f4a8bf627e16453e5a853c826dc46f506c272a819f28bf3adcaf5e3ff1e866acb98cf825026e6f7faa71012aa8f447dfe7fd1f725a2ebe17d77fbd4388f6a83b908b605b9d82a7e7d6933e6b9dc02437ceabae35c549692144ad51a5e7daf56d7b046c1da4d8c8fafa4ad260034480345b52b9cf5bdc5d806e8d10f0f920a4c204b4de4be96f0ed19bc5b787cb741361ed007bccd8d9253b212f44e84eb27378b64befc4d783e69d090f0ace3d3cf48d536b6258deed3c6a7b8f92573ea1a2d2f6ffee37d113dc5a9ea468174a1b39a4cc8a008e5d8a6af9c588b0c86ef3c8f7f8919b9e5266b3ec8a3721f8146cdd1a0c4ee429c0130635dcf500e8f0c4730cfa13deddf96dc27ddb207ebb6b85f87ad1769c9da0c3c38393c6617ae885e204a3ce3e34c0d4b3445c46ecd3c38c339f3f215c1d850ecf68f9cda4df7f43ae704f932885e6f4ed64d4df3bdc6324b613f6bead656d6d363394437b8c30c9d5d995d3d0227a1714ba6f9c60482b099037944fcea2e414ef69356f722c37dad4ddc83475f8e44bdcaedb79e1663a1899e86e9cee6c55679fbab9d56f77f66467bd3a0d795c0263cbbcd78c2dfc1e54f7df164c9b25ecb1d7f44e69f16bf7032a54ed8900361da8535b3c5fbaf1e6cc9e34258d974fc43ba18db0535e17a69cae95b2b9437efdc54bd1004f75ce9716b0b2d2d26db4542694a38b79c673e44ef1698afd81fb77022d4edabe2f0deb2718bbe08ae58fb97ab959e8c46a35b956c671ce8c4ff4cd92c6f312808bc0e16211274b1f00acb4f578a96a83c15f83160e1d8355649c53f36dc8dfc5028d95782278aa6933596dfeec94a6e33aafdf148dd46f935ddc241393ec5616e98d93d07ee3a52cf34cbed69d14294c4d1ffb37816cf01dcad468cf9cf1aec07ef222cf5e750ee9c1a47b891a13ebc5ee140369e1d7b6553b04e223af80373d829d3515e77e4534cde897b42d8d9fd5a4f33e6509e35b681c4f19595bd3ca51bbeb06bf7f71c6730f5dc6543cb3110cd713d0c4c894f8c93f1ece7708da8e8c33f27c36dc248285780b9339cb260a29cc9f2a3e7df51ce18a67ecaae1038aa3427af88e50743bac70e576c0ef34ca1a1c26010186f3e8146d7a3bbc27ba744850fd26a1c9990824462f62a48a385a03cbfaefae1b6b680abc6697ee95606c725118a3504805a249755b4eb75b31fa4068f7eaeaccc37b1bb0fd072cefba9b87e87a001f10ea3c10048c55f01900d0b4a56ad57f9262535301cde7a221b67e4f76eac753c25481a1cb6e2a2d99a73bef05e42874676964b986321c852c2a9794fedd105fef331935c98ee8d32c5249fb91f486bab87695c2cdd47bd68a1a7a57ed0648c5b1522e17a301faefb7d4d00f6099600b3919070eb4a37536358b356af30ac7f00d973e1f8db93a0647fdfc4268b8493e5f09998f541a0a2929c3ca5eced04050148533f49cf354dc2ec34adb7b6fe1ee4282034a7c8baaef9665195f5ee371c884bebedaacd4cd52f6aa6bfe909845a34bd76aadd792ae1b5a2c06a0e1e0b642327592683ccd9510fcf84edf51c4ee03ef0762f27300cd4154090756d44bbe0a285d272d69184dbe0b48d32708e1c8b80bd308f15b284091d7c3c1608ac331ac71d1ee5b9924ab428a9bf55f8fa9f7781942fb9bc6db7de2fbae1d80a19b51b48ba59f398f48154e406ab08eab7e6499e5ca9925a1ba1ceca41ade86975ab181f0ffcdaacc2abbe1c1407413b97370491e6f1a5e358ba4cc76a7ebc79985379434368c685e370effddda6a0702184974e8475292e418b8061fc5cc25c74850c8808241f969f7f72335c3ab8b021bb002353c6e6ba89347d4e65ee66d36a263af5196bfbe4683d1006256bb34e6fb47ee4c816ebbd126e5f3b5dc9cee9e5f003c4f90e1673fbdda274b57de0eeff0f6b3841e08e9bd4899cad007b12d13c52f2e9b7d95ab812f55182ba21ba19ce59fd2469b53e3252cbd11c8946440df7ff68d653c0b99d17f768570bc11e4b8d3e35efa542592ceb254ae7ee260315cae79255305c956cf0126b29ab81dab912ab3c24f5952a3f188fba8188b59bc6020e95a6a6f8b94f39a80c409a0bac7a3740cb433789d56b689bc315ad1475ae05426335a89b4ea7459e5b27df60a1318dfbbd6cde9e41242caca0d824a1c55cc546adba43440762823450f8b6a6648c1faaa7ee246fcc5b6d588b14b997d0ad2f59b199e1b7202220716d1dfce1469b38f287cf94c5244df0e975837c24ffe03d4da5066ad1a60ce0afa3fd9210d70e8afb524d34b78005e730e2783771edb849a9f3a303ed4c2b87f452612601b09637de8bffdf9b39ad9241e97dacfa44475b96a12ead915e1e4a0db5cfad0c4f85a072106524528f25321ab49f96848e6c720bc0bb19142022d11391a25c4c0cd34f67f3fd50595e0ecf12eb360779447773ad26100107c105451226790c4dd3e9615f9b5dd04b1fa105979818b5ebaaab815e832bf74907aa3bffb274eb0851a4e157cca41206f5f09de980f6b0f61b9ee07c29e444ca16ceb756925ee41471eed7431551306656b17ad1f138fe9309e09e8a946b83bdd12019401bc6d82a8bbe7554aad95e1fd834bebbec91b0a5e7d7fcff848802823e1962bcb44c9b91f225e2f3ec8e6571b25e73a46f4d76382b7542906d33fcc752bd776090c0a056afa0dd568d49823da98f693f167465c24458f2e5bc37f51727c3f05f74dceab1b5735138ead257cbd61036d818b2d4e909c64f833c3308c497153f687f416deab3b0d5d7edafc21ab4c5c4ce7b0490e490f8d0a267f80fd1ba0e06a84de96ae7cf968532a32578a40ba08d1016ad06ad02b506b9cfecd6f25c1b87e3fce18573ddf3109aadd868bad98972b4f09fe599fce54ac950b77db2b798b85feb4a116c81c7fbfcad7e2ad5e12ff3ef90c5168cf95e648cffd49f51c8fc0cf12bd583fd2ef3f36edf225fef12c37d5882b33324706bef24a86d62eb16577078bbe7f7b5b970062df70543137544a58fb88939d65f6b88afa56630408a47b5b9acf37facd71e544e0e4b6dc6897d567b338b7ebf2d00f693fd4766a27d6ca389bf2181a8b76fbcfd04393cb431137f558a63c2f8839730fedc69187c6552ca0d594ed4c02356e9b85ee65c054f3f997fe996920b6cb2f6c6ca1e3bc0fecbff60107b77ed70adaa4637ac46633414befbe72f810cd7995a6881c692ec579c22126d1ac2d119827bbc2ad88ba47ee7d6be1f425c23b1d2da6d744bc624af91797e5b8ae29a6a0d5759e119a5e7de940d35fcf4fac3fdeaf74f336daade018d834c95dfbbcd18c7226c04cf86cd69f36f9fe181b2bfffa61b68992af3d4a44ae75e81a9b30202e1e79fda96b711f6c7d2b7a4d0a22ad6a79b5d0b51a221608e91c7a30bfb62e38236999b2b78233f2167075550550d8d947a67574272b2d3bde56ac7c3b180d6209bc516d0c2008e80980760ea5e915b0300b24e1cc3cc356cbdfd46b22af544b929ee9ae2f8b4c1b1218fe28d744337826748bf857756cb1df1de64344f0f2407664c4306160d46e7e78216bd2760805a1efb6a66ab8caa4a7461f39b18cbfe55aee27f8f3c2b1b1531dd9de2baab06c36a54eec272e1c19a3cb73e039d7f53785e8d3dc47eb9afbc40f07c302c1b3dd619175b0aa217f2d724401697efea7e35c96f1235bd97494a8ce7e13699fbedcb6df523e7a51a09a61e1ee9524b9731e477a8ab53bc4f55c2426a50c41c35114784e7dcd68db9aed05a3c5a568e3e6bed0c4bf1209fb5783844c63d99274a9d1be33809182d600fc9a3ca6c2424589e252164599b5ea380b8dbff26ab1fad8f82b852b1c88a06ed20be532c92a5a7046a7283c245e9904f5977b6fe798b3396676b856b0c3872c05765e958c78349af70165d24c1d91eacdc1beea9b745cdd92830a298059e01aed95f946212eb31240e3139de1b84eb7e27d103c136c3433b7d7c357a5eed609c37c59df3d3edde93c634b6500cfaf6d99309bde713a3f472228b7020457c3cbe228d9c06b391d5041cc79518aa1b5bfacd885d012121d3abd5c1780c2ae605a647452e77200a5e7fc3c347def454ffbab202d60e088a5b32639a1af18bb442260d35506892c37906ce06fb1ba802d20cb3c42e58bbd3cdc2a2129228b5dacc04e91ec7e03fb40fad099deeba3efe7e759cc4e8e668a6b16d373bfbb67013f8dc74198bdc5373dc9abad9e6d56c25ca821df4fc60aa708c8018a2b7823d26bf124f20e588639bf6b69fc9f5bbcc8e6ffc1b01e68953838182fe85e692d258999f0fb609772de7eb3c11e0e916f0d225d6d5c651f03835d2778cab48d7f7d370f7e50b2eb08ef7e274685fb7b8f83e48070d2b0acc0b8984b66d05d70f3605529aec438fa07824b809d6996c995fd585e396bee3bd11538c67e0b5aafc7b4cd296772e4c0d56e20fbe17f013996619f53f3bbce3412870d3b77fcb25c2a7a8a1ff9c4afd2ceb4f8b9295e8682e79be0b3f40ed5b58b6b9cf559e499c00ec1f0ab190b6235c0157ab826d883149ac2ebfd861cdbeb0f349c5c021bb5cc6fe0e3d77f2dc200bd7ea1805a943b4d47378e8f8c5148597d9b4e323a1e62605002e17c5a20102c88df16c1596112ad6f5abfe0b620a7ca2d319a805f3e897f72f08bd11324b99f61c9cab50936196b5a6c131f8e947954b90ab7a4b79fd5a91c30b70c609060f541cbebe703bd28c5c8da8eecdee8d00b24e5c6fe4b6c47a07af0318437c2e7b5fb52a2cd568a69351a91f1025c188cea54c533e28827daf5098c5504cfb3b2c5120304dcbfa090b0f6c2d041bade10bb9b9050424c74159f0e4c72e5c6b89718eed0719fc11987174c85495f55b75ad694a7d6e5d17eba61dc489b97ef0a0d61fcd6f23fce095115ea24095fa94ee95895009d65d30474ebd1accb85391a64a428a4ae7744f1035202c06caf80d78cdbf9f1ddb3341352e52ec2aee0acb57e986203f516052c1491cfd3a646066033e5f2c35529f4bf7bd98d9b4ed9013e93e1c2e85691e9b487d54be429eb019e9d023c2d84aa52b10f1b5a1d1ecd1d5e908aa878bcda167696541426f9310acad28328c1204b7c677a365506ce7f787ab66dd48617a94177866bb6bef4632ca12166f613f786cc9e425c87c62c996f381f7dbacff864c84b80fdbb79a29620349c89b08238eb2768198abb7347e9ee2d5de8bb20f971dcfd4d59162885a272751c6614278a36203d57748a5ca5bc7742df2ba3af788686fc40b5bfdc75a029c0729f30fffa73bf5bb1d42ae081eb3d4396b314d7792fb390da22d01b19b9c34abbabdad9eb4db1eed0d7a919a38c9c667a1017361516ecb9e789c3c29715b818c56a979ad9cb449309365dc99ff11436d34339f3a15c03452f51733a0706bdedabbb1c381b712c9000cfdced58198a35d722f19f1936160a890eab032430a3bfdf64de6166fd2712a57264c45989e67cd5027a53543198077ff7e51f5e17fdbdc8fffcc30b4292538ab1d1cee059847d07c8b674abd2574ce4cac5425da5e05bd47f3c90932000f5e73471e6adb65adba6df2936e28229c3c02191ee35649c35d14c7430c5b0a1fe1b0a50ee5adfac4ddf185501a6c1027786a80168ef76245f23c4e2278cb1dae262899e65513baa5f9c9dd41505a49a8e99eaf308fe04a4b0e7f6be5ebd50d92434ef0d590e732fd27d3453748fba9e1701c2bd8712f7cd9cb0ba25bf9f5d32f9925eaa5bc5b5623f83c840d5d9425fd11295f7c14c1b9f486bfe5f2b2e2c6f853922ee336372139bb00b5a5803ecaf82c350c5440953001cc9e50f7b42ec201da5b8781e9501c8ae440388e28f65b91783c2644ea89ce6319681cf81211414543da9eb16517b86aa7685c863a224e40adb73756ff58b3ad869bfbc13ec815c93dcdcbc050314c4b67298467443a83b44b6500bc2393ee5c352cfa5eb6014a43c30601e48de4f834913b4d3ca81c81f474c8aa0cf4476625258495b119a7a7ee0018e15e718e6a7c055eef0a81efc59a508bf8c174d435f05c28d0e6ada02c2ccf514891b027b31926bcc4fbbc50a1ca16325ee4884f1dab3d5207dc311209021fc3344b290575619455457f3201aa3b3d5b2079c7a09ce0c6b874db8b65324af0380eb536da2b165b879c351367fa807986bdf3ed025d05e4bc1c00ebc0d84322cddff7492bb841336c4df4d40dc0ab679ba8c4b9d8a239bdf34a0249cb341eb66cfe46f8183c3d9e2addc41d816d4779efc60922f5c17155e45d7b804289b9f766b09ef4b25cd6a16aa8a2a6c03406101d4ded6a44df40cb4a09295b55dbff8ccc0fa5973bd33304d3c633c498cef6df8b342e348da4d1326662a52253c7a8c1e2c036c82145b98e9a74208b088d9bf8688cebdaee542fbdc48d92ed247259512a8876632fe73626f14dacb2fa906c2bac75c36ce3fc627be76d537f2cf42167887382fe3bcbff2acc74bfe2f19d0a2afbb87c494dd4507727c7ebd97eebd6d1580d84e31c7491578e13f866cb02fdf0114d8326fc07230d1ae2a4ce7022eb0917623ef8da2ef5c8d3aeef78caeafa5ce0045d546a4cd9e6f25a77bbef5c57ce31ff0e9512614a774cf61e3db9fb0e1ab4584eddd8cd0c2ad90aaa8d40ee7fdb56e738b344db8ee8e4ab56a4747bdff10ea04289c48d2f0ef22f29c82ed285f9e54d79269bc3034e4effc9fc990c21564a5f3e726fb848eefe4d8dfccf1b1088187347e1bab69546d60cdf52f2f3c59fa6d2659f4ba2f77c98303ea66273366fcb1ab3fb32cecfac5e358198b70ed5ae1c81675879ed61850adac56f794b89ae34ab6ef3718360e79a3a89184305ae4be3008b6d3b1a94bb75a3f7f97618d1fd31e16c3a731480afb576b6caa844b727808ac4779da1f4cefc7d05db8f01d674b338f5dd6a058c235ba79e02dd7f784fe900f35f042129c08ec3b60c85f10bf558a92f6afb5a8f881292064f2dc10b22024ba0d7fd676eb81859b8d7dadb9281696b785a56bd1aace109e4257b54c6f92f6164dc3b164eff12c0470969579c0bc0af13bc8a0bd35e0a0b5238ff97cbb7ed86d3b97925ed3843d5e44ffc156a6060a455429e3720b5579826333a90d6cc0d973f2be71fe9c326c25c9ca22b7e0543d2174696b8f1e8027dcb1cc6c6606711a6b3bb81495eaab9ca88f359bef04745bfca03aaddfab4a374533bbc48b1079a68c68439f12f6087a59fef97418a7dab2c561369726290f2398ded68dfa96d9bc20e8834daaea7d225dd24f39055aab871ebbcb0ea4bb54c0c43c022c3c3b129fd99fac3d1fdb93492164de980bcd27f1f44d283076746fc1e9ff86ace77d2433d583908a766d758952d5bd94cfd1772bc8f0b1c0240b6e08d92e8201c49764b2264133dd5f6c22dc7a465b6fcd40f997180dd66bcc43431cf63213afdd0749b430785a7888e4f708b10529bb7b015f3b7f9c8a8298bc613062a5adb5aed731d5fe051f059dd5ffa16a578484bc4d6d2693f0ca2633af4123e702b0120ccf41aeaabda7e76eeb411638ee3dcb451c6e864927d7b684401f0d3fd2f5abc2a72f8ae5a9d4fc893a88dbd8b5b2069a990c26d53df7690f5e3d7e2f02831a3fddf25b6fb31c018343949348cb5508bd63d9b42080915d16761250adbb097ea1823999956ff7cffd28dfd09f4113bc772c97b9d44fef9be4f7d255ab9f25a9a53a0f52d3284eb968ac6375c18df7749c3b85c977a6deddb974a7c51cbd5e35635898c6e6abd3ed5e7d48dd18988309b52af1bc28fdeaba4034f7bff7b0f08964052b2850851accba49bc240ea87eb78d15cb8b5257d5e5b50c4e8edd9f41c095d889ef16c42664b5bfb1e1ab610c926767c19ed89c7526ef157dfabc422cfff3007779403c41b747e3b0b1194295e0a78ac6bf0ff57ccf8ba8a1ebd8498cd8ea19ae7f8700a4882fbc3094407f45180abe9a890fba761d2310d7a7f00a99010dcafc4f11696524ab71be94fb5a72744fa367dc8b3cab299a89ff410d25b3c37e60520f9bd291d204064851d90fd21ede090318a2275548df1674c242790fb5daf114eaa93342a74ae4c0d388dce3ca2803e7c6c79e26d238410810908b4fa99435eb59de6f72917f92a7b48d75188e720b4b193d5c23eb45fffe5522891d3182d064a2acd634b96588bb095b055ef67f75a60043ec49b8dd3c27bc900b3c00d7544343d9f6be8d0e97323d4e72e6978cfb4867f982fa61786b922212c062ab2b1999f367f28a9ed9967c9781bbd8b8a167b62e359766e1f720249bfee71763442d9d8a231470e7aa498999fe477d4caa10b94987d1887dc08c20ac11f42deabe2290f47841d0d3d07718ce1a4b30c451ab0bb510f98e2b62f2aee4bcf0614233768b7aeafcd9ec80d0f3c9ae275ca0f2e2868d3429328868f4ef6d648984abae608b8c4d1b731242ce1cad39ad02a90f6ae3cc627d26d62973b6d3a58db4ab6f1c6a6e0973fd80500e5531e4829863c759c28cc032d9c5c140bd282644c02547ff11442185e4975532839194eeddc4afea716d47411d03b3b55b67628a8ccad379685d4580febea75f17e943b3319d3729723892d5bf4d5abd469db238115a9281520233775508c23c750d6ad4b519be27d014f4d3e2a54f30a3cbf9a1db536e73c6bdd1b035b287f7e59d6f4a87e0ee95461509674686b1e233103511a50aa99fac9d0558e2f2acf9bce97574ccb0e3342cfe04f41a93a3467021f5f61f5d8a77b16d411778b03d53813435b326df13278b90aa3cc13db15fc382ef17e9dc7d1650d683210f1491e913287cd726b637025d69615f39ac41c333705fd98c732ac3aaa2d7b43f8491ae88110896cf615c7c5a7f74519a99ddd01a1109fdd8685b6b91ec660cac42cd1872a9a84ff3c4e2591bc015a33ad5ba91ce404d3e4769617cd9f72f5e373e3d2b14b98f9e80bfd068dfb18ae37d63cb92bddf764f44eccfa8cb7971c9e80c2d3c8c1675cce1925af2bd2c728d4d0c0b6033587a6e77ea28ee1bf7ac614eb6d410ef5dc8840dc8e4ae05bd3cfc9935c527226f6e7d53c15d0c62ab827cae04f707c4d90290433dac8d3c0e134d563f77319fe453ebef970c9e4aad296e19b2c9f981f888a2d332a946fd6961ebc9b816cad94e99a92d37e9200efc265da18f0d59bee85b26e0fd1bc5fb1dd7e97432471d5886e7d7ebd5af4cdac12b8e16377de4acd5642b8ec4aae1c6424551ccdd9138c4c664448b39f9b6b5730316944b7e67a35e0ea4af67b0956ba27092843640fbbd6d4db8062633f8e41e7ac1ccfcc05bbd087735e50b8e5016f31b699ceb0703ba9babbc56d35be9a1654394a76251c594864e4e9f055246b78d588a08ff64de2dfa725a76af5af737d9d70585633af156cf1237ebeba06237c7b0a5e65cd892d292d0f03be61e20a2e118d406ec9429c3d581353ae0c47c8a471683db731a8f12f69c586ed03960e493d7a2528c516e05d23ee2f269e70dbad2329fe2fbf10d41dbf1381434b91a9bb0f6fc22e6459c2c4b5910758f495c55c44cefb53db1726c9d528b7b216de47c7eeccba6aa52a558383ed0f92fef90fcca1911b34fda78d2ed25932ab0919c5a6ac707a0d7436be1049109a57e22527332ac3875138b4c75aa7a0b15364ab5a42d4385afc34ae5c49b8a00660b270178a148bc662bfeaeef4befd4d0fc723af44f280bf6402db721980544e81e72e9db57cdce3e9bd16f9ce15f46c544c6f8a1799a37a88823e665da4a61eb76de04214cb8a227ee33d05b533b551e1f81732a8c9e94ae31fb2d20959f0423c710a9733cc6fb9e0638bafc8ddcbf47e2e678e9ae415ade20e18a76f599813e2831275b3a72a2210ceffe7fa20e6ef3b99ca0b4a9a9f12d6bf17972e7d8e30aef4e91a2fa2507216cbace82054fd45f15099c93d46d899211be249e03b4051fc1bf9d53300e5fbdf7f76d836c3bd5e3ad478a5ea7ab9dcb30d9c28676ad08ff249a51d1e452757e03f797de286e3f18a8ef622653db2a6f28368617a674834df9f7d15cbedb86c091cd5c2cebc8db8bf6988bc5ec06b4224f8b0b3c3f5f2fee83bc893c507c5e3513c8a4015217b3aeded701413ca0ef40d0c1f8893ae2631f4b445799a53377f1e760d285f7a616ea3a33630b35ac012332a58f8b51cc4ceb7023d4541afc3d20195633c585e7b40c53334895b481ef453194b50ba356706c572adee3a27fad6dc1edb0b8391585ed0926edf62793ce204e24f091371c7aab89f3b825fcd607a3085555dfb0d4b8535abba662b4a0597e01149156e5243e3f936aabc23d7bd7b818ff2971fcfe84482dfd66a2e59461ed53809fd350949407dd9718eb4c328d887a81e72f96398cc72d0c2a98b83758165288c6acc947ecbe4523b01995435980c9b9de121ac6ec674dbe52c7069d7ad9dd8cbbfc939bd2a1830c81aca478a0ed00738fb59dbb2e03a5b20c963882bc74c4cf9b5d43af26450c0392d099ea97f7bfe9dc04e2bcbec65fe3fc967c0902158c57d312d9e846db6b1ad338a1cee9199beb1afe6aa15abd164c7dbc8f961a6d3493e0bc2c3b97bbda20b49315e3cb1af0c9ad250ff84e7b821d7bcd222ed4321126ba3d79b62cee8d6b2bc4e1adefcfd62c741ac44105b5fe18d27204105d35ef472a2db044b1c4e8e88af7f38b24a9c26ea1897a7833638cc95c863a1039911bab4e4f9ff1f80f58ed93cf8f231a8127444fa967d9cc3c6e5b7cfa80431b6868cd0d61b98694e838fbb87470ee5a1f359cac777ed9182bae531cca391ecde51ce3f3356948759b7e1d1530729e25477d72f70d0968dd5f96507c5defc62890d8eb02a6d8b070337dae973d8c7b4bf82f63d41ef336c8f6143ccc8514de7c5f51e0701d7ac4e74d10e1a004e350a4660b82443853e3892831b3e7c4d765968363728851f417a5eb43ba6a4328c64c7df25434ef4b193d4d5f66e6f39fcbcf70c8152f93c416a67904170359b5f72dbde9560111a6db31a9de90be7a9123c4394465369114c9837e30c7881519da8e03ff2a235dac4db396943c4e562c0533b7cd2070387744d108f3749a9d824832fb10d2ceeb13b4142e68c033a9a7f9026926456a9214d7e9481d2533ec20a3435bf90fc015c834f549e85fdf7f00e96d7c7521c55620f32651f08d3a1a16f760d341324873bf339c18f70c22603b0561be96daebcb9c5437f99a21824c365684aeada6c15236cdcb4829de9f11eaeb8660087f12de08c0dd2d7e5a6e9166058385d148761a5d372ab0b2aee772e6fee4b0ec4510346910cf861a1fe0c1586df83ee50299687b87d5cd2e2a87cb696ccb0782d5f788a364828fbdb13ec57c785d53ad326af2280c7edfc958b7040cba8b527b4388a4e45e82ba1b075e1e079ebbba7c6d02c9d650e6a3b463b05234723564c34fe60e9b1d5980734ff2c15281f6cd0cfaaf39f09367f937fd4b0fb5945043705f5088a7a24a91bcac8ed407fbf7b644ac93c5c50cb49d3e956658cbed6fe26cd838af424a1cc2d5581db526d97b9e54012987b645aaf2ec6487940015e47fc7dd5cc886f582c53b6992e9fde19781de76ee5904e6bea114bde139a9b89e2141d0dcf006823c864866bc52f05aea12f7734d63b9853f67065913100d0ab592e008f0a3a68e22ded8ceb98c8052578cd5e43a241265e1eb377fd4139c873df1c5d690791fa98a3d753f4e166fd4bee2657c560ce72a00487578218109442a379d99869f83524d6ae407145ac82ceaec1933afe5941fea404ae487f73de848e4e393aa085096254aafac7bf0b2214f8e3f14977b8c4db4ce4842850d6fa7f4cf6d1cd4db0124b32e9572a176cc77bb7b280b0dfd9d84cf71c825280feea7f9187eb8a9e658c5d1012c0a124892529f195f612139b8bbcba8d792270e4cdfbac779d61063bdeeec1c51dbc53674844f0e88a8abe6717848b259083afd5a6a5d125f0b26474c044cc397c4cc250e0debdb1fec597107e1263d14f1b5a43d1635eeb94fd6744bd5389631acb5c6f75a9b528cb0cebf91d0854f52b0b6254bf4a35b0bc31004aeb42be6cefef75620c5d9a1c8e18a39dc49126304cf4dc560f2589eb1dd819984a4b1490050fa9501d0cc710e112ca14cf1bf677e246ebdefdd04c9acc768b594e47d338ec05d4d6a532d91bcc3aee689cb85de091eaabd7c929c2953b9050e092478fad429651d0b0b8b4d677fcfa7c61853915c53d5aafb5755079f605194aeab5289dbf984ec1875c6a96de1c98304e227dec111eed29537a2e31d1a4345658cdba920ddbd0924d1b263af7ff52d2977c5d6e52086f9072eaf868b29a48814a2446df4e1abd71f09910a0b3ecd39399644f9553093dc9c6204c739806037295ded573903acd944acd45ecbcf5d5d2192b89a26658cff6df79ec59f9bc740e1da8fd70231ebf41d38613d90e9b3b9cd994da981ad4e04a07d5bcbd2b8e3ef769529fc279bcebcdd9cfb0e8ab12f76d195020fa2442660fcabc0dc5a088c9338a022fe23d11750853ef512b33631bde27ff80bf091237182395f443ccf7ea60251717cfc6b81155a0f8d693eadde4cc79ffc2267326a8385892d60ff1e83db4610a2364df4013d979d057800cbf6ddb757bf257161e71417db0b18ebf890ee0f451bb298c4324ca86a949ca63a043bb830eb0b9c6e8c2aede58045e39cedf7c875483a0712e90c9124452f5c831953ffc7c07271664c2f98213bbb4dec78ebfa9f0d30ab241e64c93b8f8dc693f5539ef4a5becd4094c2d45472ab7741b605043c49dbaa1b846ec6ea24beae521e4b32a7a9b867be097cc35b880f4418c6925c2bd2c7ec604992e7e6a360b09e3da614993be3d4898e9163c9889846f3872197456ab500f35f764d0b467ee6e1ee1c47cfe183ba03356768c18650a3512fb1f3094d30d54cbb1c45390a4366f1776767463d556b57e3b2a9220d825e96e19d8c686b3fac33420a3be3e4279665b7ebfcbe1033607d885a34ace83fc44951ad0f9301e5ec2a49354a75b45f741bd660c683295a81c7ef8ce8f4985224193bcbdedf5a1069719ccb82d9690f8ce862bede803c11e501006491f6970e3046e00a19522d2ed2cf22b78a920c4be1ccf03fdfa5279184c540631f9619d062788c370398ddab7852a68ff61902f011b4db4ba29d09d9f4f93b42f356e2b86b3d2e412fdb51082fb01c9fc68ed3acad921ed89634d06aac0b645dd67ba2f2756b58d5a0f583ad0c840ca2a54211aa0503cf655e8706108e5574a3acf7f3f8f06a52b4a07026432eafb21e5291243566f18b5953296f0694d8490de4c8631ed647fa4c87cdde7655ec35d033db9f1c8e395dddade93bdc6d1f38e872ec13489ffa5cb2c6ae4af040c7d864e96cc973cd8111952d7e989affa0e906160043c7044e03ee74a7371e6df028c1551fec7f889fa6902c6f6cc366920dd60f1f650708b4c7222bb072e778dd9a58aff9e68594f3db36e178982767e69419506435db9a15b2a4166d94972a8366be7172afcdbb882a1984e2a5b636f91d4306a688438384e584e782e4b9e5741aa11fdcf542c9d7344b76fa62ad3c535b3de5f56080235983367b1ce29f6b3e5d594274b98ea7c2bfc8a923db5dc600ab18a9facbb02ab1953529147b63f0c9767cf7e1f4f27bd0b30e60d7748392b537b242645e7c8c086399bf637efe5d0dd977d1f391c520abdff73a0e254980cafa254851733df5f690137c85840c2bccbb6c1644eb1ee2e03f58f1e6644c1f0cf13e4d2dc4bd1dc8e6efc14f55816d2d417414aadc79ac3b3490bb5bc6125c77679e93f583904792fbb36a9c1916e19eee479b8667eb66b5e644e0e529286de86f8bfbea162ca6266014e25bd1073b5fd2ce217e04c3d3a3b4a1e7e4d7654bda24cef22df400e97bba1a2873f736e5131bcad8d8189d21d1c84a997c91f066c94d6f1f88d0eec004eb260d1e8e2339e1a0c5ac847274ff05faaa2c825104a28b8d13e878810dca37dce34bcddb50921a6eeb9c7b2eba9f67d0501d6f2e6b8b386f84b6a9a1f8b6869658ac9039538f05283653f4270690fd652205c1a8044846507f97320bc40860647ccded7f8b5866d5e115a1bba88ff74d9ae3e7df4758afd083af4dac00286334a33389b729c8b219324e86e96cf03a5fca6980ed30377babaf03b8cb2f55a5c6a05b0e1b83b788060488642d7f826dfa8deee1296319d1350013963d0ebde5ab745c04e63e292bbe8a7f914b98f4e23ef627c49700b4e0e82db4b736ee26400bb0f253de885292dd5c70ab9690171f1e5f84e48286e3954d3e62a10030752d8c2fa21af3ce59afff7e22a7891b1e4a6f7a62e4e2204fba108ebe79f1a7aa92776053ebe823c2052de60c9b66ecb4fe5a5a116487bf7046c685f397ff5521ea7d4100153d9f009bee2500561ad7d18dd0a322f4b39c47a365219fcc390c94e5b75656343a8d6fcb8aad9177dd0718e4b62a6120117e726c04518f5be04f4dedeeda8c59cd34cc40163dff82cd528303d223b47d9444ad62836a49f7ab452e662d25b99e20006ec87e3716070d84080ea1121171cb8109e504e0868a4d6dbbe527b5bb41d59a017fbd53d8fd1434ea4fd1ec663d4cfad5586b969bee66c01831424be1f1b757a8805ff50c2d9020904271130926a935511ad51095ffb10575907db150eedfe2f45d01eaca5d63b45fb1aea05d7f84074a9d38f2592a93dae87f44c3dc6c7271b62f0a37e8f40e4c10ab00b543f307420b0030ccc7fa4bcdfe26b5e42ae1a2d29017b61e7844dc3903b9647d0a7e6abb0a46cb9f225dfabce4b91ebe3d3f0b04d46e6b8cc27405401b4c89210f6a7a84d6ffece8e02b748c996f0328d28b5964d3dcbea3c47ed96848510f75eafc29ddb62d524d8b394dc92113c73cc596ef0613f4b7a44961709d503677c7c6e0122906b9000699674a7c3409144abc596cae90a84e577f6c7ea52c45b45d6db35b70d518826755ed4deb96832d271c656f8e0aed0082f2ee561ad6de187c78086fc9604f8740809d021f240f842eedccce88c94cf394707a3f8eba187f24d36d71159495bc097938308549d658a040b6269878ae60adecf9ba2fec762bff3269c611d1f29d50fd0de6d820d6c63ad7246502445f3a1aa9d530e8bcf7ba2b4e8d68782dcba1634ab7252c84f3d1e548cb4b437055ba635ae84a4294b4747deb8504c938c5b88b2b2908059823ddd4a0490c214f8c8bf999dc182fc61a65812906433bde421c7eff1cca3237cf2b92b82f8fdf632e957dde7f0e77ca6ff99ebc40dab4b46ab34b3d372b2a8be303231ff121efbe09d64961117c5523f5da07dd1f8ca63eec2b3419ae1fe845cf585d1bb9d5884d7daa5d23868dce201656806ee1ed0779886fbedbec03626ce9bfb6d6503f3dca997e9c89a88e4c919f444128d2feb534a4b84a428578ac5af4e04b9888c28d7add6fd756394d4b71765eb1c5596e139475ebd8e983379233745c0710c76131702896ef0ce23e995e29c1b521a728f76997e2fac8d513d9d0873ed764375b033224a804c9f744fcfbfb77bc4707a941e8b7baf0121d705d37e920e947d2ea630569392dd61bbc12466e11a0c1ee06b83217aee6e5c38d19bc6ab4a4b4253825f9fae2c8056243a42e0fe0007f561331e849ad0bdddfc7f10ea969f6c1d0adeaa09490ba51d38fa18dc5792ec1e7c6891469bdb7acd18a47ea66ca2bac231e73003794018509f5d5beae0a66e7a298b121a9f1ff9da14b4684159a2ee2dac7336aa142f906eeac3e669a7825a7b22bc2e7951b1db5ad4f7536cc224fbef23ae2694c3ab6422a0c3d0ede5990fcf7479bf310321ca9e843488593b4f61907ae50c92809869fd321092378255e3e16e2a91f05092d4a7a2087deaf71b255b96dfccb93c17ba0e8a17f80522e602a7647de51a4a1e3dbf703f55aa14dc98811c466c2a1bd3cf90e93352636650ddb2af3fe7d64bab0535eac01504a852dc27e4da76288150acbd9bd5ccbb7be402810a6db788046c5983af960608b1c053916ad361cf8017c48b02e4892c97d87c80966bddb660e62559a6e7bed9b90de275e3ddef0cb7a7c4ea7603dfbd74cca8fe56d6b6f55cbe64c517c5483967e1280061d67921f459e93c458ee8c60bfcdbc8da88b148dbc5de2d842e54d8ffbe1b82c88a204e8300ee2113db4d6190e4799ecb0f20756a3e249fa169595dc8e906945de48586609b8d3bbc03ef446beb71a5089ab794aaf14308aa65e13cfa768fbc9caffb4360fc9fcdae3202f32b91a4d5540055c0fc6f48e5ea7e2b865d6821a728ea2303957608ce6932ebf59ffac4b0898d03745ac94b97ac433fe83215478c750e9601140942aace409749c8888d8974109013c9b3234dc4a6aecda5533198e7567b808f65f585fdf50dc1a359d53e38d0a066c6f0f784f1d14aed4f14a2c5a0bd2979d355c8710156be8b1337d12e69bce9c51f67364fb1d8d0132a438d7f5f476785760937190e3cd571db2f9bb4bde9347e79c3e321efe50e048aea0153b26b65a2a656a00a09fedcc2b75de123ca47f28f41826759cc9945e7b624394a0ecf837df225e1721b4dfd7680056ab998ae13d47066386bb6d908bf552a4989623d4fd63c65eb39badf75b103d428b5542cda872f7c7fc75e407ee906fb875a1078263d2738b5a84f0d5d48b14d8fc74e1df9a55884bab438d3f6f153a44ada5fcda4ea5ff6515f2d40acf7c6b52d5e2ff1b632911535e5c80e6e5a887ace2134484859708567d0ac5fa41e285894e51d0c68ffb011651fc8c034280b17f2b5554c14d13aaf9f8c88e6c17946ff3eb5433d0c59aca27f891e64364e35eaab2669e2a8e0b5b7b6d4794a6b5ef24b5e9884519effde5a6a1fe6f1e3956bd95399a31d1fe4839f98c7d5f939666770dc123f4928549a2906897f10cc2ecb0a106e035da8efe907e95f08745e5f0c3631447d1525119859a2e626829ad1925d7cd381f160b913001039731e0cc38513defe8ad2b384661bf69e91689a448171b34e5b319334b8e5235367bf68e2ad50b627561b66224f970415d0b0741486c9fb27bbc67943259ec6d84befc769ffad0099e8e4d4963658c0f88b5723702e364629f9ca6de27fad173c37d21020fedec50aff0607c1569f97df0f4ede309798b974c7491085ea1e4729db460409e27dc91c7a188b3bb6084e9055721e1aa366e3676e6d5ee76a05c1fdb9a19855f1dd09f825c738b34ff1958bf126e147638a07488617b99ef14aeb1326a34e7ccac99ad5a43ca70024cd2285800ee56732c2d33ec77d7cc965eb9082c8bae698b1e7cd7402b73cae7223c6614b2641404f40ff90ec130cb8644847c5ae26ecc965e4de18db1688bf54fb237da97d66cff722e58fe657428a3d574ba034bebbaca07b31f9707e32503a47ccf91b94a51052f5af743398782e85477683e987dec48c031ffb41109874385acadf2ecb48c68db538e5506879bb96227a52a1abc61635c31ff08e2e84f58929872fb1879ebbdc7b5fad7909bbf1e5a47970239800fd2ae3c94aecd39cfffd30571c7ec36740d75a50a65213ddcca587af88c137afbb23c0e02bdd82b2a77b83d8e129575e4afd5066fece6710cd7c7032eaf2d295913ee45154a6c17ee46e2decf6d6986e077ec587c47a0541978c31a3ec427de4b9cafe1a6fd1c85a6330db66b4da3ae0ce159524bd8317d28c27d2a7c2bdab40de6f706d68f687fc3951db2a10dc403685d4fad52dce14b9eed0af2ffce9115fee64a27226192717cd2dad3bd0175d6d2bc30d57aa6cbb86e88e16bb22a56e564000939dd32a78b26ac7ac01ab6e1a2f92bc2ffaf36e1393cf1e5abc0b261015143fd97b06c6358a665c0410056dfce1dbc9cf37c06a1f29b2ea2864c1d13602aa70cb96359e269bfb5b948838b4de824fc4bd9b67f8119f5b48de5af90fe0aa66e8c538b8a293c4c0b2fad28b327a1809682c38effd824a5ea2549f33617b428ca3fc9677cffc61ac4878a2dba71252d55fcaac86a73215bb7963c2596231b36971abd3ec45fcc1329a3a179a679db5257365abc779a46348b9b084c532206823f0834872e933b53c730646f5537fc94fe736482d613eae8033e893bb82b024f8d5e83aee21f567572dd6a85358ff4ad5e223053d5df1d952e0193d183cdb415f8c1f90e0dd0a80ed253606944f07aeb2dd14459d0f45dfc49eff2c6f151526827dea73856bc61b58be325a4922cddd688ed74b7a9a222907c5bbd9102412fc9a86048036a0479404a4a18ebaba28bc4e96ddce4727c059ce542f29d69b4552c4ea57fc8c89f6a69fafebac6c05e446dfcb04c96310c69b32cb6e2cbff77804564ea315e49a77720b1638715b0def29c1e85d84a6e4235a4186290143fcc6ff720e608f7e755f270cbac4beef41118f448d984e47bb5491fc89df21dea21e0bf53dad4fa8d73e035e248ef1ee8be7ef648b7d00101094e72b5adeb0b00186c375a6386796b9e590c3463ee9f6308ff04fad02ef55046959b299e713eb844d0e85923ea788bb77115ffe9931d4586d68f0deb2a1227f5f1e7ae685a2d9583ffaab4a3efff8e3cc910fde0de1c702726a84a4c38fe185ba6ad5430f1b25909f273163882730d7e032f1e411f4ef7388a613a17a8c0a728165975a9aad855f59cae9ccf37a909676033d812ef33783fd0e74c288782d6a02167df5e11224d4fbf811f27fbe5b387c9dec7874795166dc006e42d5f636f034bb38fe219cafb2d3b39dfb6c6800e0020a4d4ca127b379ca840bf163801e1feee26c7a57df1c7b4a3e5a1390b945d28f8243c772b9474226efb7c390d8988af4328ab834eddabd1c65d579cbeaa2b776af3402f689ec5a18bc418482ad1825301bbf406500744b11dbd9aae3097174e021fa18890b4ec4f1de130fd76d19818c8b33efa1dc5693b9449f809c046a379466d62526920abee7ab1b174e61d318d5e252daf2e4147c9384882edb7b40e5b53bb1ab020f94bd17dd3b758a5ee2050d7eb8d63f69a0cab4c687275495b5193ea5806ad175f907a4e35f894ba2aa66d6a877b6f4baaec3b6df1ea693bedd90f749141d044608b129c2695f1e0cf053fc8ceafd52ad4c19c499197dfafb990eed5016947eedc650174e2b7891145f9f90f0ec8e1eafa0aa810a9d2eca6edec0e05e1abc14ddc1d47ec47b016a5d7fbaab706630d537f443fc7d7f7596a527bf715de1e1540c9f08b94b711d5743457a831534fc07879d22d8f8143ffc8de2ba869290533a300eed681207ff04a58342ce1247daa84fd0a1f89332b04f37b4fe756767b8fbc95a259f067fe98d637f68731a49098b128003fd781f5441c455fee5f371e1f5e73634eb1c6fb6b04f4828edac2a32ceb35c2ff46dc3bbd305a974e8626af7cc1174978f866a7c9fd8ea642907d2768ea2a5e087ea3f7c6ddba57290d533c50dd3f463159267759a70bb3111ec4cd729c605f1b85d5e8dda2022fec05cdf508ef547722fb8cca6a3ea0a3ea7dbc1536f0df4bb7e4a3c983342f013519db70be312ea0f2675b7d45f2ca9bee33101427345186c3d1a0d537d06c5ac38ead16a456959a4dab072da5bd52e043c1e3b69910649085cbf3f7145489dac3077ba132c1885450c0f2ff7a28dc52114485fbb599092e69d880ea6ff9f7a7902cf9f01c6a29e40e2465f7512efc5e53b2745a35531840d7a667184ff13fc64c28bd4d436c692a79850f4eb2177f15d8efd30b1b7ec33a86d97c27a2581384ccbde5ce4f6f0ef057716589d91c95bec68a3c8ab0267416e6418488e6e91d0dff8d1b567747e6a711376e9924ee30b182b06debac766ee9fb7851533e078a913a948a42309ecaad1fb03950cbbbeb40571a0480cf312122bc145d73078a7c2c6a667cc0fc5651134de448d175cb27319456276807c901fa892b424e5123e1b3d748f431770d31f47f0ad3ad5e34daa2b55d1cc320b6d8505f1249303ba42b70eb253b3a87068e01445976f6222b6008420200ea32eff5b71cbd38c6dcf335ed34c2364bf5bfd7d66c47c2b8774da306514d240979f30d785b2f4cc3d6c26273617108c02808678ccaef386b3078f81fddbd2e45cde94f93711b3918540c89741a941d3163483d1f07ec7540ccad38567f8832641442c54a88f117dcf47fc621564c5454772911f410dd8dd79d8a18f1cda52185a3c77a0399220037899016d37c433dbc55ce3eed9e3774bbcafb81db10016455819625301050039edbd8bd97a508092745fdb68b47e35358a11e5017f1de040dc1040a7c4ec59242b22c697004347d5b3184bd1c64a732c78b318d5b056e11399d6be83a86f43baadb5e835fcb4f6f0a92a697eb2c8646dc7da394130a83aa53337c1a67856ce6ad4a8878ab81347e58d01a8184d8495967fb80d8d245f733ad3079c120c084e7de5a151142a4e47731bd60cf414f5c9e34bc5b7c22b78c06b86757103dc2605ebee202a167b7ad4ee03e853833066349c135796f8a679c3ad1a9b96cfaced9702ea568ced742c7203f4f9e39a60cd6602e87e0a81c74f6852fb9c275e8ba191c8b779af45b1432f513045155af47d97a09e95b56fe132148197083c123833914a689a74404f6d0b06d807b99ad742cb3d9d0564e02e7445eecd9f870f7b9dabeaa58d4cdf467e1b79778d67438999115d3f912909dba42b47a41191bf7218fbb0e521f1ae8899309cb707c2b13678a9afb16e9238bc80f52c6824e12c0bae3fbfe132ec1993c2521596026d13158d961003e720c0ea7f4100a24b2c6414d8b17a9813eb0f838ff41ff6ba587a701eb753890e58e2b6d888491240cd55ec6aba138aabbe44d9f31944b8f269bed4c093af2a282dce83f894b8d00151ece7091a6375b099fc78a36a7b743719e36cb30444f4a3d0d386785d5e63bc00202707e39c266601c5dd69ae2945b98c976aafc3b6815603fc59f27b225819271622dbc20e152af7aff6c1f154f0f8ca4b54c45a4865a75d84ecb30d47dab428c1fa86210f0ec577351ed1a445f8ad3f0e62a8d2523f014f187db586c8fa5fb56454f4c5dc230b57bc69295daa99daa5d9f37b93ca0fa612cb05bf4c1b2829ebbc76ad950cd819b97ac9df1ea08dccdaadd1fbb4f8f0bfe8ef77dc45c28f7cb2a7d6dfc6bb2f570e5eea04e66f7bae8fcdc57dde67eb0bb810d19d294750edbf7356773187800f08db7e636c6d59a229d3a63d901e22251131da7abc5f0e8f26daf44afd9d8bde083312a66e2149cfb871f26da21de16574297ef1891ff4cdb0ebe30ac1e560ce17151333aa718daefbe9c0048b543072e9bad6573a71ff578febd4f06943b49d99713b5ec7a228ede714e279443ca0a0f35e19feebeed31e484a41228843921a20154367d589db9cb999cc466bc95e298ad44d4706093165f37dc698db39a58fd941836781ec618ff1ae74118028d3dbe555fb127248b13f67f481a67f23052218b8cc5adf57faba7be7e9b970ad43c1b8d8501bdbd9cab1528177526c4c8ddecad97cfe498f9c30dbe8fa74ac0ff00b3e0549910684b3c3af9e9474a54952d9aee6231fed211ef98a0c96553a05224271f76110ef62b5307e31902971e96dab2199ac7187b37ce0fa4a4a6e01c13c063b54f778ed44648847e1b0de5c8ac59e2d7579c65d60530b39979354e85abaf0b216a0ca243ca6edb2713c576e4cf6275fa05579d4e985716f107dbc9036160b98a0655290d30bb52c17cbbce54a7686bf40f0047d571c39601bfca66f6e2feea8b5cfd5e52d447522d528d781a3622fd53774c62dbf5df7f7c63bcb89a6a0fb60e92f8d5a58f08efab9e9bee0d6f1e0a8702d2983455c3ba97cbad81ba7b3a4ad54ebecd1669a256a95b6f685c7f86f207a6dfefc68504664d8f640abd79a45905d31b426f0bbe98cfd75700a4888139d568d29dd57d2353b937e5ea85f25e35799f653a24180701dc280c34b247fe3a2f9cce8e7e1aa35e3ed8171543ff6ab0969648c54c866225b1103c8fc584d12ba688d39ca195f8838e664635ece6a44a92e1dcb73b30a38529ca8a5e17f6f7bd33202c08258ca73854ae0e517d0142f11996f12fef45d7cc20e1057f819938aacc660451968ef847aeee0b738a20a3eed1ef6ab7ded600d1afc535874faf9747fbaf91b01a8fe2bd36ea36d6bce404b3c416f9997acec47bfd92f6e0bbc7f7947f408c5d36db4d2aea3846a72b3f2b212b6f1de9fd801841ad77cd752a71982e2bf7f9f9e60f3a09bb2d6eb4814b243cec9be55841a5b4f20fc1795584cab3a42367cb2bb437ceb34d1582a7c1d68d7cbee5b581220e06bca7959d3253c188d0dd6422c3e98412e9f0b34d243b21937a00f334bb4c68f21c3f3df5802e7eb0c6c5b8dd208a9611b6cfb8add0f22c9a67144659acd29e35a3dcb032edcc60b25923a8379fbe49851e967aabd0e108fae566f08491af3a9ec15f609162c9198196c8d9f21903b1647329d47d1bf2990529b687b3289a148bbb46ad9f7e0a2af0f1971599b29a7746e19fae17fe48b130bfbbe8e43cbfd6e84dd81c62543060dd390e0eb57ed0b5d18277d8a562a9b9f57ae80e1d542312927e8b3cd76843f7d62c0ca0ae847d380fe75301feb862313191b345d65bee165e1e461a5891d99fec9ae6c4b67448352f96b7dcf204fd1284c35695e801c83ad5915b9ab1e7d3bf7258535ea23e74a225a89775ec0f03113616ddef9cba066f673eb12ccffd85c9a119a2e4ca6dd05adb320466ac66630c899d1bc5736ccac77c261922a89266eef3b6604995e8ed1d2c715b873f023261623c191fe362676250e3fe8458cde1e2250e15f1128765108d74b7b740c85dfed902d0e5b19cc42b428bf04118d9054d3c4ccff66c1720f117a1200f4aabd76f8a2baf5a02a66b3f6dd3758797b3b7563126f9a9394b524ac54719260c43e97d7b681beba965612e86a06cf04fd875efdfd0d13ad0e86c17c151bd82426adf1d2eeb7962b343811800b9f8d690cb9dfa6d1ad942084f34a922e131e7602ba4d819f9f3e8c8089437c9ffc58a24ddcda2fb6eb1413ebfc0a52b2ab22741e5de687f8b089696f41b1870ca81b5c9fa896e4c04379fb293fd6d222f01d0fd08933db090490bd7c5cba72ebc530ef8114047f37ea70848336d0d336414f5fd298cee161e1c58137d263d8a4056ae9f72790fdd419aa6a00a69ffeb98fb27807a0966ac36c3bee4d132baced065b4b015694b33002c3dd27513ac107cee33b1c5614492cf479bcf858f038dce36d2e7261858bdd1a8ccddfb3e7e4482ff17b6794443c66e5db7d61b7ae56491c7e5c6ae48dd1a22a3d47c7f2449f11161457a9ed8ae19129d43be6b9495331a44c16c8dbbc0447ce9c95bc622de28af29828a0cec638aa8a53ad8bfc9cfe247cabe8e5ecedd3f5e7a52461acf548f2db66727715a6418a8a9dd2b07f42966e9b3010c1d3d35879d94fa22328bbbad7f0aa70789a82b122362d03197f75fd37a6cc4b9a359fa2d610ca67518ac0b44d058b5ebec5498ea87dc38fadbce082e7a38a4389f11128f8bddbe59deef935f0c6e7a7ea160b33a5e17af8d74dbd7987c0c2073cd8ae0a0ca93c574ca957fd3aff1d7cb1c310543282b29fdccb5320bfeadbe7de9d8e77049c3f12262706180e37473394f94704c38a6e773a8467119224f8d2b240e048292041463283c873f8e5db0172260e2f8ba5f255a0e4144d7308a0cd95545647368e56215af851ffacc64469b68854ef1208acc1f1ee390713ddf8f81650e5af0721efc5593a5939016f7afbb979bdf71e787eb01e2e115859450fe92103becf962858d2426a639bfb23c6674f9be341f9e73fe53470d9235324470a38ffec14908e1bb20aad24627b7e94ac4981cad76ee9d37130520c9bda969e82c95e6321b2ca7ba2e698a40d2d0bfc8e3a3f86ba93f6a92ec683164da112020b3ed7081260edcc079e938a24baa20672610fe582936908be4dbb51398df06f6fad4d090decdd187fbb3f6d471333ad10562f2dddf104285598190a5428a5cf6653b0156f33c7f0676df328d840a1395d73b773645272847714411a04a42282f649517e97dfba36ed0a7694158669025f67e22385f60085bf204034e3d49a5fe624745e857e56c3b1c93cf02ada16fa8be650422b9e94488bde38252ae324ecd0aea27e2e7fa1f4360458b06868edf5829bd0b710e91e93e4e5416a2f7cefd3cf1cff8ab6cb982f1c35b7b2102e60ca4981f3e27fcd470ba1f113b69411fd5589fba2860d2b47af8d6cc9c4700eff0eb4c97e431ba975e645c666de796de2574928e195b573f9ff7fe55e7619f06be1db38747babe9dadd3f842d610fc86cb5d93593f456bd08394fd6cda14bad82193a8b6cfaa46dd920cc306e5920c8effabf4f94dfa8b7f8050481e7812ac8dea0767011c7cc9bddd0efaa053efc340b1b9ec20e4db6da13bfe7d52ef06db3f31d2d7db50a41b2ee7390e73be11cbe98c2b42448103b5aafa12e3b05015561c94a96e6c9c88508f6213dc2c8bc3511023f1f999c9a6894737dbf422990982ff568527f4c012acc059a74477c831ea64a2152a302980822446b26646697a88fec0b50ce3db11c377b35bcef01a830c06c310071c57d8de8a218e8dcfbcd81d425938b16241b3caa3b97e5fabd039cff2146c55ba179f66c2626fbfe2245b872e800e5a9f9a6dd1c3a16e320958b51bfe627c93f1327ca442a5245d6ffa390fbdbbb70fde9e5dcaa1736c871ac79ac459a6254b2af1657b82e3c659b0f8a1f43c0678b3f308fdd21cd7c403871ab392dcb30e7a1e65ab3f1c6d10c5cf2b34e37edc523b3abbb8044456adb12c049b1fb63246b0ae9454fb604913fcb6837bf880258365539a71c5cba295f8eda950d09df941e05f1f7af94452ec3414cc6c7d3d1e81edec86e9772749dfdf229d190278ff5483a0215d69a99fe994d7773906304d14c96a4e9453ab9f65e35eaa83fde742c9dae585cc260aca6e7f2b5fdd9dc426f4a0b1c6cae99afc00dfa1b7022f955449b22a85aff7b4d070eea83de97a3822ea40eab832bcd8e66be847f875b6ef912f2e74bf16e36f009662422a477e37612c473319b9e3c527aa8ba766bab6d1d45e456cffcd2322e2bcd09ffaaff3c49a2beb878235d932cba516fa265dd68e8d110757934e47fb26aace34b6c328ec10fcd102e80c3a320ea70fe58885910f9f61baca2c03ca9ef02ac57481fd5ac49efe97937c817db754f218a0be953ece13b997bfaeebbe5baa558eb53c30b5763359566912f93d64b1faeb2889bd4595dc07b682bf60fe8f24eb2876ea3ea558d6174fc8898b318f3c140f9db825e98d752c7cc5ffbf25394d25e09eb4b83248f73bc6494d771bab0b277d2e3b01d0c1a95240234bfbdd4c397581fb8540d94c61359bac00d835bb8462989767eb5a1be3cc81ccd710a75df749beef912f760698d8f6805c02aafd498dfd5b798777cc7bbd6613387890d5f99703c9321a81299ba0a7c29d136b3c890c5eabfa18ae165c376a70042ba60f7cc747a0ad98345ca0822bdee7676db79eff58beee8bee94a5845d9c9076c3a4c982c453b6b6f600404ee9e0102c1826ffcc3fd13aab008d81645ca8d1e0c41c806fd23bdda01631fa85b956b7c2d9e306d9a88f3aa93de5b4073de1b100246b167b079f7df9e1ed17a974403fc2421425a218460f626a324e9095f58cb1829c9535930e72ede35f6faab23cd5f49b26f8a6686b15869c7deba7ece930c2850ccd8a542f1f85820d00ce0e09daf39b250412d88208898aa8c1f3b9932015680a99b9b8cb19027f524519ab51349808ab07dbfd32224d70992cbdedda2984ef1e733d80eaa3d24f716ae238b610f8a59c0c8552647d2e4c7fe99b00a869fa8968ffb5d72a9aa29846f79be97765abaef6c8dcdd334fee6420f81bdc555ba1dba484c43d1ca66ee955b5401730b33cb3b7ca453d2ba0c59e04712baaf49ba536eef6b8600e7a4eb1dcf98a715bc08f704d472a9b54a69e4f4682d59d4ed710393f69315b9c9edfc6884b5e76cbc1088e13c594ffa19fece8a30c7a90b766256800afa807db4ab131fcb1ba62e7c061fc6f9f1d78390dfc8b90e454fcf8f3f1af06d9e7b9bb71c6b5e859f2b8afdd6ed77dd5477d7e3c649a3e56e17b2941f1be0a4e6a4960e7c55f446588bc2d38d0280001b39baefe6e9312abaf884f59d06a8d7572318ef92af49f1cd51e55211d6241ab1d16bc1f616464d2e97677c6267b86a18f6578b5da8cd5725a6f9aae312ed2c3e740b43f20022e2048a1977545b178dfb76a02efd80fab2f69270eaf7b9e9ed746a7adc19737d021fc704248248d4561b32d853ff4b9bf5d0afa8ebfe6ae7daa1e9427a4194794b2d303cd12f23632f372cfbc7e50887648d98e9f89058030984e6fda6def812fa7fd799361ea0d71708a2b672a22f5449a27ec13db7f73d7f7c192cb68e0b135877b1f5a6654ce1fc4cdb2575a9e8aee61f2d0c66122133390c1a2c550c43b44760cb0029aeb2a75292eca5bdad2fde25d54a2c18c0226529e46c91223c56cc42ed5308a7b885b27f0f482a9ab96797d0145491891ef78404662df23c3c1d527e081d1889f759ee12e61b850cb429e955fcfd61eec0afe77c9c91fe83a147ecd03c49d1175600ae1855e2985afd8ea2f569795a8ce4f2984777c3e54324a09841892db2357aaa35846393fa6d724adce98d344955290711e58300186a8664b825524b6529612d305b5a706e75bc6301d2aa8d3041f508edb9fcb885fe1813fb6a90128fad2683fcb2dda21ea6d6e0c76f8b6766f17ef5de6a661fdcb835d436188c926af52fa22f3a6b1e486fadbc55a9b0faa2338ba477e433279b90b3db7462d3a144c0ff88a26cba52413e455ae2a77727314c57703284204d9315c09c781708b99e33b8a2caf75d8eb308e7c4b4ea2fbf0f37c6e39d906698a2bb9daa38cd7b6d9a13b8bd107a68a23c028806b77b708d58f4eda836d33310b30712263009f1a09283d004e10ff573c45b9d75405ea062c4db2e5f60d48d8592089f83882c44c0e6bce400eb072bb60052bb14399c436047f751c084bdf59b3981cd5def4d8a8e0345e9b709f939207558876656054607fee15f763786b91a4cc96e533ac9fcc3e916ea72639c3a5335e64e1cba630391b17ad14ec9e8099cab84ab8422e9c6d309a2e57782372b540ed23df1abeb414c8539fd2aa6b90fd9341497ec5146e0997e796e23c5b69c77181a223d926ba114a995039ea57b710b61ce9a3534ea4849e1d1cd8d10e589d287b68b954d495d746c16d301c9510861f298ffb447fd9e6fe347953e3b146db1f95c2a774ccb34d400d19392505037440ad9bfbe259568a68a9b47dba9e56daf770b4a6f4e7aa32d3ea6ae120d84d75f9542b3ca65c47275f67153e61040b52406699a3315b23873b1e20bce3e29bf49e6ec36cbb3b7833dad7439fd2a514b6fde61aded1e0d7095dc0af08056588c05ab6b2ddb26f3a00aeb24b43ed2b756145f15e9d32ebfa7119e20c087e14d38f5237fab07e21fd1fac016c40d31e1404f1d484d2edefcf55a293ab175cb7a4f4b0dee4b7ff72b10fe9faab68d824fc40090c00131ffc8fef516049f1b22eeac93b9914fbb2ff22e161e84b6c60ddde013285fb2c5eccb764b54f8f89420d8e3e597d35985e244ea3f931865869555682460760a7f2206ce25c1d18380e757d66e32b2c6585264c71f74aa584ad863bd0d8c98b6b3ef8cf0de1da6ec4563f050cf403f215edb59d5cc0d92c03c60bd872a8367a383dbe97073245bbfb0064f8fe49b9ae4f3d550a7eadcc48a259df5011d91c70395838659d7bc6e6d6e7186b1ddf3a0fd5e7a75bd4bf4275daab854aaee91d715d6d58df407d4ff00f1091b4f4f7f26af30c366c6db16cc7c850820f58e868482ae19efb1033908deb628b62c45022c58ad96ab2bc561996b052ac5904bb9b9eebd1a341facf4baa5c7d87fe9c76b620ea0c0b38326c3658a79ef8817b92c8defd8068aff47b3c25d08557c72676ff5c48d8f2c0f66973e3d042a4d7beba1ec391ca8aea8efceea9a142c4de8f090842d2f7b3fcfa956361356221d5b1b92216289ad2154bd02351bdeb47d4f2737eed017093714b331622a991d714fd2bdfe41003148f5df8c78c64ac8a0e1abb4dbd1e96b7790ec00abe2c84db9d9cfe4999fb5083d6277b273e2fd6ef65382127d6994329ed0f134725897ad9edc45cb7b5ad6123d4febff8c5cddbe66ea0f6cda7d7767c98fcd2cc95254670c997025233eb5b8a1c337f72990ade9ce7e5c68e4020c5254c9446a65b4d47e04222d27a96e352c56d9258f188d7275b0b74985aff72397ffa7570d37b1a3a83b13adae701e90f4cdd5a54e2066d0f1ce4d589b61b5aa63d89df2e258ea50239ebec43d97bad20d506d4f20692c45a3f7a9b0643a9c94eb49432dfdc2c34ade32a1c34c301f1c7ee538aab872e589f36b55fe8445ba3580cd8c7d152c019c078d59cdc3852c18d7dfe63ae193f86e172742d27cb47a46a3b88080cfff8d7b1c8ed24b94a5f673a1bcec075661d96ddf2d1f46953bf84aeeac023599f27b091bda353e893f24dee934f0d44f04d7841bd8a872fba38a1e6483f79d62eec7f4940f4503625f881d3d6baf4b0bca0af0b38a8b6a4532ba402fd6bcfd418b828989678b9b079885bcc7aea91abf79302909dd88047f151759329b9b2fe2de81bced1e6c447c41f1bf3afb90e7665ef6ebf51a0735c2f9eb9d1c4ac6ae2d33f297388af872f72e74b7a143cf737feaffe3a85d511c190860e6771905872a41751149c781ee38fa490121f36a1f2819817f5dd4518d6e7e549544e2901962f8f1296ddc0e18332a555e1383d2df19539bdef448e7454350dd6f1037b34b36ec7075b4c52d957e9a2f35715bb85f9956d5a060743644de09e194c4c34ca07797fff16042c66ca6a494ccc7f61e79953f776bba24923c85c8054ff537f0ce17c72978217738def464114564e177bfd97a7d33b4764228878e39392eb24af9792cc4de7dbbef714aa1d97e77fd7b6bfe16c0ee135b6834adc09e0ea507f59e1766757c2a69a2fcdf10877083594a600996dd46f2d686e921230990e028a9559446d305631594e3843e42302c092531ed3605d7e132eeadd2856f1b09b0e0d7c7178ce84b01e2eabda87f4f02504d844821226c92171d97a969c46d97676fb055855dcfc34fc6eb13bf81ba1c57b9a891280878bce15a26a92be8ea3fa6bd9700aaf340c2ced18d3dbbf2f0132a21daa5f4de37b90e85a0a216271a57f20b50a32f0f5f4a0ce6a0f88d462bd67feb67049b2ba4077dda4dcc4f9d04a5801fe214fe4c7bc6606d7f1b300c550595c26f4c284f931dd5feb7f000634e0576c1d43428282fd446f5a1d55f09491a5c5f5b72a7ff4fc94561e5f08806d7efa0edca0e8c7c71ec00a3f6c4b956f4582f0eda3976e23be9f8f6084c2c65f7edf6acfff08ef9eb552e5818ac48cd82e985399f0544d80713a847615e5b21d30d21948e429ee4abc9b1cb5db4e9f6c6239fc6025caa5ae93f4fa37257facc93ec548d5457cbbf6ddf6e83b16126f3a89bacd996b96b610e15c1665d71166185afafa3c9374dc2ed67e43316bc13d8cc3451fa716a2d01c93a115bc1061be314381de0451ca06cdc238764ad8fa558c59c93b5394129e3ec0c3e620889e294a4e0451c4e140f33f53c50217de4968a7d99114289a5645336120374128de0f1ac404f919b785ea6c3a88182910f757f47d6828868adc1644118012dfa27c641f7db9f936e982bc14b7ea252df8f506f1db3d95a93d3362e6ae4d46e02ca82e46d0727ccc098c862b99b4e23dd68e18acc9c68819525820bf3dbf7f5b33099c61bffe4578890373318bb53f5ae1f902a2454a4b6ac8a91f1b9410497181ba4a1ca32cdb8b81d4aef1e41017348df417d8d4e0d5243e1e1a8027cd4d09c475f78c4f0cc1c2d5a7ebc4b97b864716c5942e551a6612c79a61c7ed9b0cf87e1d224a33df707c4834001fa2bb64804e1084ff7a99c0c5f281078186bb0f6277aec2979eb1f748f4692569074564d2cc383d83590c8e83338130188c69b15f84dc177383f55cfeb0b5f1d3f49176571dac3236e92d4b058d3b5cb09c63cba56cfd95fdfe7f9682e25f829c8f13810d4bde090a4944b503adba14a47a671350e00c7ebeb1bd4d2d54bf10d01a8ff7301a443156746b9ad6c12bab7709e464affa9efa015557502ab8919c28c2e2be09abd1649ae045615b0ef86f4039397c6d52207481993b40ccae440d9316b38dfec0ae008caef49bd546f5b2209f7582d7c34dfb129c42a8dde52db628ded64718d4adea34e82ddf365a23e5648092467a2736c877995a16409d3b56a655d67976b77a987b167c084ab1ef9f3ef16abff69062d46d5643bdc7a33b70751d0f808710445e0f66146ce771f9649034bee85889fc31906e348a3843c4040aacc565c9943ccc3f146aa6e29d6f744faa960dff0974ef8cb1cac226f828a96c8fe6ecba3de2c16a93774fa6310a549ccab24ee09d2884ac8c27a587bb09a9e5aaf574b393b7c0b3c6481697d9b1c0c3c46328937e6539d294d99bdbb1b085c1e645e89775bcbd5141f31c1c7552d8280ea78c714b25a0efd668a5c00356eb759c4d4cbd8cde169f382bc7f63adbf4d93aa8f008b2c3fc7a4097aa9d5f02e5e4a99768c6b73f7e1185a2d34001c9aa48280a4ff49cd217ce416439eda149e0310c4ddcbc815a2028d3343cf6f97062bf087250b5c147ada3737e17f4b2520b211e2c1ed154c008dd29102b198795b1091b38d5d32af22fc124fcb642769ce526483cde6922260959f7ec06ddb8cf5da5211cbf6630abbd46013dfc450e03027b1cc52554f76dc614e1bf3210e3b1456bc66d57a67ccde52ba874bf57f626d1508513cf31791cdfc8023f87144c2bf4e123c48c7ad81b647b155497accbf793b1c1d7fa4265a994bd46c40b6c2a995af2c965edcedf6b1ac05adeca7b7287144714d1722d20733cf675c2bfb53e87d33e5c6198764610e44bfe3979326534767e37e9e9c402fd326489de324af6f297f64537db5524f5bb2c2f24b08b40fb67a95d2e3431ffe94f9c84fdd9e3563eabd9a208650a6e8762273add291ffd28c7c20c7e1d399d111af411da43ab6bec47a152a659a17c8e852c54e38baffb8ee152db2474bb486c2781dd171fee9029e1d7656eeed20d87d15cc32f165e156f245650d62a596504de8d68281ccbf30472bea10596897a418b1a8bab6d2fad0d384b75480b13bb0ed54294be71fde64bf778540a74ecca31685424d704e2ebd13ba731a12d30501fd988f6660929442ca078265ebe0d82513eca612952ed743d064634c68320e1ea34f7323aad06f54fc928754c5c9430607fae3bb21fa4edfbb7934d6a44d2c1b68f2d0d82d8f93b423c8937f35455d8755b770911b7b3a42ddb1cac3884c41f60b799e2572ba71a15b252e468a782af10be39a272186e7fe7a4855f7400e211de042c27bf61b5d6db496f6dd45841920ce8f86a31b681e6d47b8ef609d51a776be53a21c3d2433713b0ce0263132df9354d88f6c217fd2a511e060429ae7e23f1036dbb08ae599ce8ffda802307271e5b9e46fca5dfaefbfc060247dc8db7debc060588c4357305e12f578342d1edf409dfb7be477b3c0e16617e2f3022d43ed658eebf41f7040e7f2a625357aa85746cfec907f9b1d318954a1c655e5e4b805366129ff3711fb515336333bd72544265b1b1ad749900a9a7bc7a71bb0d0ba20a008b6d968aedc213843b08daae08f20032f1bff96fb694662f3b29fe2c4db48bf09010fdbcb25531ec06c02831110e379d62e18e9d299185fc470420038b34c90d3ab069068120024ae8040bcbf21709491f63eb5c8a6b154f5671b246ce041966d18ad68698c50b2bbe920198f6de321f2084526f963a6aca1d17687da64f4e2151167fce0cfe8717e428cdd91ad4bf2b7cff6f2262d7d79dd5b018cac138e48d9c43f60794f7ac2200618be83a5095b280f0d4a9a56d84cbb3bea3d95b2df8bf86ba116bdd9321b3810c3d24d90a507338bd0ef636e96f2a5a814692c9333321d5005942b0d23fbccd6144f0c7d0f094f12c3e28947868f310594ad68076f45c4f95cdb444401cbefac745c156ecd3b5030855f824597e5ce112eec761c78e65e9965030d6a375680281031f4347bf9dea7edfa85c1997a6c2606c5c4159c09f8060ed4ee377789212eed1a9650dca6fb480a688aa4ee0882722f406979a12081d8fdd0f261eeea5d2b7caef8cc4113dbdec056e6fc6d61feb37de8a7ab1b4997ec656063deb2eebf175b7d57e7b15af3b282b57b231f1fe9a8e6df9d89bb0970204a0ce5a335f61d8f2b34c0d4118b3b922d3f95ee1bc736ed5f8053b9c7c5a516c345b0f5d583be01abb9ab8a6c371d87b920d72ba55ea1f36d8063195254126c5b8ffd32926e53f61572b720e6b2dc6e241451b1e5df6723d432f2c34e30e77d7c1b88590cccbc407e88bd03a5b2407e38aef651c29a7d2f4860e6c3f24378656a4280548ffa869e53e6d9b211edf3841eec90bb920b3d8a579173dccf825811829b5c152591aed0bd5dc9e3b37e19d1b0231d2e319de5694ef97ba3d4a4cb5de0f8cab8b49cc6d3be61eb4da724caf9b53a7e31c07249685fd68d367a1d7da60b3f5053da5a1eb904c78b13dc4a7e649d456655407d8c96b4402ba1833ad37f195b1f89de0eab9ec09490a7863270290866e8bacf9fafa24721a2216d9fae1c4108671cc7fe61877848c107e4f23f9fa30e96f70f72a76450412782657fcf10069737bc0dc6cce2681d1fe0660460b1c182342b68910314dea3433b946039b24a3adc09cb344ed192d7d5cef481678bdd5f0a6f09f3f66ab4b7104828e3cabaa03a0d6286f4c1d2a0b806866196f664507fc29ec6bf8c3447119429934228d2111327dfb2b994347726f891aecb7ab03e66477b1a166c15fb44e95636460550bb1d7a0bf019d6dbe0360ab0bc6025bc9fb940f979c2bbcfd88cc43c785128467fcb8341463dd2cb606dc6ea70e78da5b464b6c790d690ed51a025b365e91f42b966b32c6e17c429c7e1b046db6c1e8f7fed444deaacf56ff6174a09fe285c5a8ef27679cb613518d676153aa407a0a368b0316904a0cafac0bb99e8d714b29b4d616cb0e2c8c9322adb0da374fc3ca455de75c7bd4a45564298945c89433de6027338ca265c8c51c298fdadd3f6d661aced7816b7116680a85ccc1017de47269fe3ff2bf883aacdd6b9b33892d4b4f1c5bd5d3c34e2181217c6bfc90a7bdea8a2f640a4a3b9f9ba1f26cbe266c99957da72fa607d0e951976da24bdea5e65409d48b4c6bf8ac59b3524b428cdc5fbf63afe77c6fd0f3e4d8073ff000c859db057a88d1b6027053eea688aacd75fba729756ea0bd3eb6cc27abb48a1cbcdaed181bf72ed1785eab61ec853a1b31ff2502a7031a86c34c7d6341e13ea3a2c9a8dd19e42f8dd8114cb63bf3d9809cc9b461e3843aba8cb887104a5c9d1052f63ae58cba25224aaa0db76db69ac81b22ec788ff4f023bad6fcfabf8ae18b4520981a9efd0d4b1211c75042ad7a4ad3d5becd8a8075dec2380987c4de5dd68b0f83ed2f91b223cd7e3d6569c1389eed11e51bc9bc048856627ca996fb51d310cc7fdf3708274441fa1eee55c0a309e6b0b64a00b9ff6c477f9d94f965f6fd614e1f5bec66c7e7b78dfa6afb43452d93c7ac6308d9e7ef510b68bbc8f7e6b4d9b3297a440cba8a14d784c58618602284e1aa6d7493f31d8d87280929bc8458061097fad2f4234c5a81ad22c2ddc70f8995a459117e5118e10b648b9f5c42640d46d9121f928afd91a5cfc56c3b23e4a8e564f62b96fcc6ac1271b73c85364af150a495a335417e28d06b1c2c2ca5244b40d962bc7d574edc9bdb26e50f6e73441584cc56a1f0ced700318e55ac3c8a70f68b3ab482b4f7fbdf11d07c845ccbf38aa180bbe3da978979bb80b542d97768bb355524c884d8517f7ff6015f946f02be596fb95171ee9b3aa89307075723a14f63008b2809017da0804ca08ecf39f7261e755f1e88ae363a6f81093e113d30d4f410e3017ffe769a23d0d553b914156554621c483b0c2261f41de7e0153a36456333b4222248d38fbf1e20697c787d3cd43e4e663c514727e0561f863abaf1a0a5278e1e9fcb96a49517854934f89b3c4c6a8a2a52b6bf5f27afb9fbc58a9cf62e9958504932ed086fcb318f71bd714aaacb3c640b3cb505ca6abb95a18b496dcb0c2b2bd24c48b8bc587effd62f2e6ad49a66b90bc784d8503314292e3d792e5d92aa51b26dce21bdf25f16dbde00c23a2d50dbfc236f10c7a4dc5dcd94026b5b37644af46aa6b89895c993707b84a0386cb5ac2d62b72610ad2837263fbf0ba8b102806efa44392d6bbe13efc4e22fe61722a15d02fea2a0cff9b1e487e4868dfee93ff52e7d3bb97697c8db1df6b4e4e6835af21cbca2008436d62319f4b0728c74f80c9b0524366816ccad2d18f273b10106a5aacccdb9dcdec09659b7029b80447d322dcdfe9a39695557adb8dd9c0e81cef8f37fe415ba2fa3d5a4996bd0b578250d9e0a599e6b28ecf40e1600cf652ef2423964a13f482e6f05252194b68a29da897a1479637fce167dab80ffc3a8c451cabb91961c745200057fa8675cc569553c054338c32c114205a0b778d13150eb2c3bf7b2fecfe53b7cf56031b4d5ba66fb89cc06b908af256cc3959d571cee11bade6c99479c40785f85cd941bb8d07e68298e73a321771a7249e1e9b1769e30da80128818e73fbe7a78adb4f255254ae84a96d10509312c57fc64201a8ddb626728fa3f267860efa93dcb8978bed1690c4023d25c2a896837380dc602a6f2b56a4ec727622753bbebaa86c808cda1b1c5bd51a8aaef89956a71dcfa040bed025cce3c769a2432b08a23469a664b9ed6238198c1c31c25cfe71233be6e2c7c013a7a1366fbe6d0f663d2c9c2420c9fb7e7282296fd4616f1d89a9b91e54c4bf89ea376f69a5ec2908c6d5f0f48dcded789a20bc13ba7b21fe6d7284943ca42201beab68aa82f68a1f93f73366948dcac19bcee9d386a01c76eb6402f2ddd7ffda0ad056a5847a74191705dd104b394efe8e176d13a3fc48c3672e1b67965b09a9c57f28bde61092bd71cefc4201097062bb0b861076c918bf5f3005934ddc52bd75e9d74dad325cb0ba6acaba90f62fc381d764522ba538afe8b6e6f1fc20c64fbbb3de6ccf4ca40e9431aad43c6f1e88765708315e36bd9829695eb48861a7394733742ef7be2529357ccc0ff1cc6b6bdbae8b56d93611a243c65c085104b427c2cdbe052315e84b57e87602c28d4572eb87f5438e42f61d8b37302f63eba9e76b920ab9d344d61ed2a194b6c562cac6abf0db824d1bb44d05e5de8088b7ebd418cf124428bc7416d35e08fd94c310269f95787f3696b9d9456f56cc10761607399dbafeb8fa91b2e3f77f501a676810fd098d9061c958eb5eedf88d70401ab465d20e51006278a292adb84c35638a79048bfc50274aab5b2f78ab8d3a20aea0458d20c69546acb5010673e9ed96b39727157837dbb0faa35e24fc2f1103bbfab425d2b36155fcbf9ceda1458ea20701ea04d184de9fb5776c61c4b23e35917d43356bf86526538f1fd58a8d6b85dd9e947a8054084e6f5c5e134ca7b51f55816acbc748d7ada03c61cb478e9497eda085b55804aa4e69368eef007994873d98c6654acc8d663f4b1538583a513b197b8e032b37fc67d996e2e5fc7541dab68e5fb91c8da1033744790e84f04ecc109870eb9640c359979c930658ab93e1e7eb0053f6f217247108e798f29c4250a9692e3eee74e8167936a890859835d2c0a4eb5d98ede45d30372b03cedc2a210cf6fb1e3e3a6060981caa6ebd310cfe3f36061b94ef03ae79dec065e3e3d1beac30a3cc5b3527bb4f8f5f418f27f365884f69a356d25f81d91ee6e643b782c2493cb212791407e4da4bdea6301f6ff352bea768abf8bdf957be8777decc96ae5d28a99a2674c6b5d78501ba309d29d5ac056fad8e8101a9138e2fa2c7b330ca109913aa3c84b0b9bd842995e423e746e031b7e826ae07f3e7ee4a6d3271ee5715c8f125acef0a765e5a66c0f1aebf2303fad2e32cc422ced9b229d912a23dc3d3c3b015c5753899f6d83f6aee6fedeac157d7bc8f5536979f7ad3774c8c5fab652f99a5e1008066ce0b0979c92a79b7cf8bb1bc204e18925c6262b697bafae916af996111a10f10dd5f7bff9016e08b7a43659171cc75df5f6f46a21138fcc9b525a79dfc786670d269d27487465a0d9b661051917c86681ed59bfa7bf61ed41980866d117402dcef03fabbe0cd916f467f22bfaf3515b612798d239a98c396ec72e2bcf3f658fc14b2f8b095f63e29bdbc6032b3ad64cddceced6e979196e51354e92e74ec95bbc4791f10d6fb22df12823b272d1df13180526d5b5b8ade53b73dd773e4f349a3e9ca7bd5bab6a263782e01ac5e0298a1330d24b0d16ee916b12a8929b6a07b476d734434265803b848c19240b537e21684ee6c015ddaa0c97fc3632c537662ff9dc7a44bd95ea929dc2a05887de8159bf57fdd43d5b80cdf3f27d87d637fb1a3a3ef9ec93102ca95f482a054039bfc40b2c46215e55a68960e28f66783af4503aa1519bb31169f211edfcb625e2bf4f4f425908def828fbfb4425e483162fc03d100241d3816e9b50011c43d6bdb53fe9578de937fe09b762fd1ba5735c20b2e0acd28eab1b56748313e2e8ba8683e9fab8f458ff5670bded61a0ffabcb67343da8ac1ec83f874df7f50967ef5ed9d9a46a30fd85c8c0390e176630d9ae94998ce9bfcdbbb649ace2cc0cbb527a26aa72ac4960d638e6e8c4dabcd5da4e6bfb067ddb48df05ee4125c2adc6d2d32e9065017a1b334e9aee14e983c0ab6e84955b153e4591a6f3f621b806bed53f4126da189d7c490c1884304a929ddde59d0ee9a0d79753ed3aad097f9aa217ef5e3d3ac7f4bb67c3fcfa648e18feb0863a34bae662184af4c92a42a01d9f587713cb7d0156cb40883f041d363964ad83f4dc38ba0c78ac6cc14baa4825375d1b5ffa06c04f96b5452ac8e9b8270a96b20105266789d6dd74166eb5c1894346076e238c8e8edbbc31ff1809f0358e64faab8c0b0ff50e875cd96a269c00bac6bd4fac97c83aff29dbb00a5352756ea532d0d2508dc90c7fe09dd2ff0dc7bab454c61584c70e512e0deee75964d340c02d81a69ea9f4689727b51d2852ce39c3997a5bf62237ab2084b2901d52afa40bb8932fad479707245bd49c123e91b2de7e601317ba9777fda2fa22ac165d034caca23999a07047dd9193b716a16a2f187a670ba5810b7896e343b8fe46b36e1b515743d110e8ed60a6f242ada344c87c342738cbc9fe9181a6433b3631f8cd28a97ccc3b999ae4237b9ffa53a133420052d99ab07a8dbed4d87b13ccc488dcc3d1350cfdbc1c10d6564c3ceac1cceead821b30920562948fd0155f5b4db70d77a6ebe14ddaa21e9f9eb9976c7225483393d5a3fdd0e281ec151d3acbe1e071fce3af03bdd20b2aa2dea774a18bf9cb15f20630c4aa90fa2be970e7cae7bcf3d2160416880f55f343bdb80cb58ef523980deaee7c22a5f62dd8fc4861e67441be1d2e8a323b5a9568a563ef810c53d7af6131f6e9aa5e58ef75e99e8bcb8c0ae3a862f4516fc54cb9d0849b3dda767dbe59704201178ad3684fcfa2b805d035f80242a18c7f512a1c6ba7ffbe56cc67c59fda59bf82cf144eb0b46f97676ddee5ea8805e226f5a29b2dfa101f927a99ca3884a8a7b38880827193c0fcd9e5db51d6a49640fe2d87b2d7cd3b1dc13ba582414c3985613a616839684c81573a20757ca418753f3ed807e623977de5f8d2363e44350e4048cec479302e902ccf319fe4dd82645b799d028a7c0b985eccd8548a0803a0ef55b23356fd87c1f08aab61237158e9e808fa4eb41d3b5f96451ef7019b96bb9b313ce6824a04b0a53a471528aa2eff867c2b711acf5bfdbf08decc5a406b9227285e230dd93101b351aefac5aaf24e4c5dabcd863606876922648fe767145975e251866b811d22924c1151bb5b595f40cfbf7d5151a82243a7892e8a77a8dd1d3575de2968173f9a00efa711d09ff6d7aa8cb73c210c1328fcb3a0371620a882dba3366f88c556f61aa7e92fe373bf7b4ed31b75682df6bcb2a1dcd467c1e5f2856d1eead140cd7aaa3d67354110561ae69d19c31349b6efd9d172cf19166821cd76d0c756851429b27021350eae6165786b7199d8ef701ae7b7e67c1a8d5ccb2464e9c8738302e10ca1c178cb64f0fc016f6cef7de8193e29b8358f8e4357033ad67a22784361a23967d9d0bfb644274efddaaaf3737a73811eb1230ba56663a8604e815c098d0b71dfb91f5cf7c9d684446f404895082b50a9fd413cd3f412d5949efe3ffecb305b1bc49a1509bcd33af194a1d5dcfab77e7efc2e2ee1d5e45a270a6cf933a9de6808de7b80b1a5bcaa23580c5cbf0692348aa36c47ea9b2cd9981e4f5d23fd684f054d8fe5c22bff709fc2617f539a1813f7a17229351c5ee7221264136ef32daad5b16c5239120d7001d652d04999e5fbaaa8ff9eea46ce64b09f4cc23d966d405a6a393fbc554e7138a05838a161bcb07b3c8ba19c5b619f0685aa696bf2524194ae0f6e1e2fd31f79dbffc9f4b9ec51bce71ac12655286430e761dfe5ef95f0fbd9487d768f03a243a7c55040c8a42a3b23c737e4d9feb89d3d9327781c815b4d2e2ef01e58d630fb0c34ef1055eea485c9ba3806e9a83cf2783b28b500413e7143bb7018868a901104dabb887e7173b84fecf4a0b4b867bd0ce5ba2992892af76e59cf1790b3c9a4c52ad91ca5dae8d05e08dccc1cf2cab72934b3b3c4f76c3bedd0cddd8e3e1f2a2b072781bcb38e7bb72582a74c91cb2c6c537ec2acfc68e087ef646a33ca923b9f4f8247eeecb86e30032dbf3b34abfb250c0ab20a5ee0f21e1594a183241704ab93e284d963612e49b94f59c5423db0b6e8e07830becfaa13e2aa5330418ea72399ed0e0aa3a4ca606f60949660a903abd8b11b8b5cce1e30c574fe61477ad2d34aa2d9524e6c7d1c0e959fe69694894e82541e9273f7081a787278b7d73e270a33bd213ba4c62542de6ae62e8d68678b6dfa4a8360e627a2891c313cccfa52bb48bc0c2301835b7e777c1349bc38d78c69d82377da2fe16eb1f75b3d64fc837133b5fed155e6a621ca0193667011234425bdc43e691499153da4364f2424f9ea4e6fc40682e394d583d318d979aa14fc857a9dd28a0ffb56afc133180cdfbaad1129a80b56a40adc7d32b4a2a45c53e63af99470cb8f3b296b1d1e449c2468dc2a5eb38bb04418379d04437f5e50328196b15478ea076bda7fa64c3185dcc3793b150e58c4dc9147620ab6be277e1c3095fc2aeb53a03e5f9f1f2dde9728267a66e6a72040e2dce926bd526daae7d5d149ea8d3a4b0831fbc96473bee57129bcdcf91cac1100865abbea1cc6650c5db2a694e8a37532d3ae4ec44c6c879c385d3f45f9b854a51ac1354ab76e8cf0fa71f680e85eada293c1d3271de4802b60c3ce241cedfad07098fba45a23706bb76e863f9108a154a05414cff132d930ca00b5fb478a7c9dfeb5d1170fbcae17af2cf34cb59b34ad5a4568b2daffa20c001ddbc5f2cb41cf92c89975c7eb54a91cbb24ea35d8af003d18a66398267eb44dedaa47bf18767f09d723bb9ff79395e08b076d04f5ae0886c301a1256430ddf0cdb1b982aca5e729c7ac4ef4954174522e16936cfa79db557e7b829f37658a144805478ce457fbb7b496e8d68cd5f8eb2f97bb7c6679ca080700025678fa2f7ab102b1b04831793dff727e215e93222018f5603a207b2d0724eee60e666bda63837fa132c7e810048eaf949b103e275e3b47d3364e542be5a84f8b927982959444d83a112b40c0cace3d04e2a3cbbc2dee942dd876008426c9ea8ffe449358a698a06d7f01e62845ed06da0b64ad14d7c89f55a9a8ab1178ddb1eaba686d5f5a53a1526f2abf948800762bf237d860fe413ab09dc1f8eb245e8901e7f760d19ff37f12d3ebb01e9eeffbf24573deaa4fadf41e913ed67f0f68c5230a4cb5fdc330dbfdf2cfb4ad0ff7a24fa9c74179c0f59a1859290f9dadff78652f6e58521a27bc113cc1074a87df480fb8a9a8be48972044f4a01c7aaad16a5bb40e31b66c7d5e4427272675045729698645595dc19dde69d137a91d58152edba2c739f858ed72eec9875e6e875315f2da7a9c3642a808f2ef1c6b4d21b425a7a58f78000159899054ef45a11141e5068d31b2d541cea05bf0166dff1b0f5990423bb7eb384f9d843e7dfa27706cedbdaa1e068a8b2029112441ae3709fbacca2c85de7954370428981be4d37217c877d1227f65398f4c1d9e962afba880262bd5177bf7b0de74004b1616ccc09c6090d69389722515d01680ca2c3dce1d1ae77d04a17dba5bb1249d475fd205e577aa62475b1f62e70bbb5098ccc940609019c146a9f4f4c52312ad9bdcda9976ebe6ea81f1ac20f4efdead30ba79e04449b8fe688e2b196324d235d24faea5cc54555183a79adcc836e5f97aec85647d8724478d421883f69fa71dd2d6eba2ea40169b074033bfc7c234bcf974d308820a6a96473a85e0191bac68d980ad1556d772b459b2199a4b2310cf6e811fd190fc9811de952ae7fb47f0eaf5fbe9500c697c11fc89e1933d48c470d7eccbb9d8f9062065b97189688d0c4afb67942e8c1e5e9e6a54c09d5cec5f67df1e1b246dfa68e0fe783c5a1f6c10bae88b7f26c3474083540311ee68200a42f1ef81b30bb7bc30c0e89066519a19696f8f2b4b517405555e66cd7603416d25fd4f853bfc5b3e9c2840540b9c4eda617a8a687c1aeaaf30ca95a5e5ef343f05b5108df28f6e4fa3b061f61dacc11c0bffb85c6a65937e53257f09907d1ceb03bc5978814a54f46716de8db0d0ba95dea06129b8cdf3a9d4d950b98e6001ee18a6c3dd944695ec50e21eb49e17bd43342cdb2e6b374c5546dd825b4697d153273313d64208e07bbd9c85476b54d5b0f54c9060777a831e0c4f636c73099654e74264fba445b5cd91be30d7cf7aeecc6991a6d1ea9f757dc79c91eaa684e6e5250bcb8f3d25a40e4d6f14ac66ddb8d1fa3a2b35684033aeabcfcd53d40202166baa0cfccf524aec3cf79ea8f8de3087e910223b17401d45aaed2c3094c05a2b54771317b1b48b5ac3f9a3be05052d6f0b7c71f2686e8b974a23233934761879fea8fe669d824c27d7784d642fe59f1587ea6c7c910495dfea45c8f0fe2f888f6a7db1a341df378cbc32a997c4403610f744b43161183f82cc32b385a13abec73c10fe2a818c8778e4c3d80a268b652716da4027ff2d8cd7fb83059c26ed515915dfb6aeb9606588755fa2dfc55e841bac5769c63ce710fabd6ae95cb1e950e2497ab22665ecbd95853eb627bf9d20383e9b5728deccf9db713d41f7406c0f32abe2f6293ce88a2a24eae93372f6d5c9972b8129cb9ef28690526844a5b5d2f4e785861fd99b5253d343a7dde69d4d8507a970761b4de5f113b84f526807add9f390f4fc6df60ab6bfa5eeec6306d15dba6ff41404da4583b3fbf7ee0a9bcb474d5a510c7ea06ed676335d0925db1b8490f946f5d5a4e897d55e211db071fa3fee692ae351c1676e8264363b1cd2e13fa632527e7d669ffbed7f77bc90ca280846f6b34b98cd26be8b93940af537f78d818386b0d2ad79a3ddd30ae000331da0714e500218845f6eea6fa5ee668c341462f95ffed7d12a6f8a3e4e30bbae4baea7eea937ad41aadcee566844e711b087bd5ca08589b97966c7f2d2a8a943290c90b95a580273e5ad09684b2c8243ae2e4978e188b8fb4be45df0265dffbee666b868f672e24e418f8f9f286fc4e6bf044a3c310e5bd8facb5d9659ee58423d2685f1145bd271ff989efd50c5343606ff4eba0c18f2ac724deb995e2b209f5262a438434e6a31d98e9700927cb9b29ebb2c61b84a94b2d626240b2050fb4cb91efb6820aaefc0dff1ee45e93a742c8ab7f855b819cc5efe74d287c6a20d0c05fe895264b1fe4f0a5e6c4dd357404d3ba3b5b70624f14f164381908cb607f274f50d8372cd6cedc86ce2e9e4d29899798f2361384f520990cb0dedcfa9b0702009b4cda73c40eb7af0b6d0a915d25bd0540c114a002589a5365525247787b1b95a545d03bf904b2a5602223956d18ad06f41df9b420e1ac7ae4a02730c079b832476b362b3a82a82bd82ec1d0738c966082ba36033d4a682f7aff75e5cfe8424bc6d529e40699fedb53e62968cd5f59079ad4cbe2736be79b3b5f6da66d0faa1d96bc7cf33df13b945888d463d0f50560b81bcc75183edfbab5ef1abeb1849f5cce08f5f95492e2a89bdd9d45b36e67a6ed0c5b73dd115d6e3abe938205282504ce4352c0a7a1fdbbec1931f6287f6f826d568f9f1eba298e8026cb4e9a629de8f917f6b0b85f556d7d4007033ee1f54a720165df30cc03b01b8e0b78931219df1a94852acf0cbfe07a59eaec43205295bf37505ba34ba2706914e1b6d078a6b06c3c9f63c709aa5c4231cb31eeb751d4fe6af0cf3db8cdfc5c8d3d9e9a3886ccb611005672b92deb0f437b2ae41bbf785cdde6abb754358270c014b5253b77933a80f46459090308d33644d60a9780ea3581b040c89336023b494021489cffadb452bbc75f69d18ffff1818ee9c01b8d2cd0a075428687e7d741d94eccd2c412bc1cbc8bba80ce5fe932dfdc5e751a36350c2435ac93768cd07261aac427adec5ea8a6071158578eb60a8ebdb2b4819df3a97a00eeb8aee3dcedb93824dce674f7a889afd60bde4e3b1bd5a94c1fb9f4b127153b84c1f103ea6027c8031302fc7facf9b8a802b425c3abe69201122e7a3f6b0c2f6cac6bdceae74720b34c9c4899035408f2dfc5e68e610e378ed60d2b842e2b9d2dff76ca2377d0750a1fcd99b612606695207789a7eae6b9901a74040e5442fbedab24a8f4ee80bc189664221e2d59165ff006a5cff0bb643a2c2131314ef95862e1ea4d7d8883492115170f44a3d51baf28a186c28f51249a3fe2b0796589963fc4b4612ef8165addd5d714ed83e6670dd6fd581d19fe33ea81b2fd8788a59d40e0afc441251d832641e61c48511781a39f173e31461394348dc4223a3b592b83a6f8de4be433aab0795a42697eeed23c5c0d290650bec2d278be59a8ed3cd91835954e1f68e063e35bd193c203c109ec2ca21dd7a11d5e6c45d8466b91ac78c91e14ed549b76b7f1e865d9b29fa7c70782850ba0d2bf248ddb5ff35a7001b365d2d950bf41d592b763cf62c5f1e125e7faea8ebef2dfd658194a44798aa95abf8b620ec076d7abd74ad1af0ba956df0a14ebd1e93659693f5e3833c8dad53a4aa09b2ce34c573d125d691836af637eafe1a6d9865629bb282c983bde1bee81d03dc1c19da6f496cf64822b75904e55003a1e23a9acb60619a3a1a4947d20ae1a374c879a8e4fe2faac90e393a83aa49ff4bab2029a7e21cf80bbb65cf4c14d0a5ad1e252346d5523394d56e8cc18a081b87b37f4ee8f8f72a6414a1d637048a3a47445b8f1a76d2ba6057ce2b3b57b88976bead3f3fbf4cfba3b8c25f3232c7b97686974bbaf4a1abd8943adab6b7ffbe2c083b014cd0ca6d05af73d1aca59cb78af3127bb49f022ae2c4c6eb2dfd36b2e8a5c511be9ba1c8bc2e3f366774004c80bd64f00d11f778a1ab64f7ec137d02aeb4ab0740f6b853ae93ed8ddd33d7abed3f075d732d372b6ba395f7369433ed708878de290c3f4b92fbf5cfc2d5518faa0ea73bd47064c3dec7201dd1a1495ecd7e664cb497c356fdfe3f641f990f68272cf0dddde24faca8d5df0c30c493e4f77c5cb6bd2a3d3a215e0ad9a26eca54af47cfacad71f9a5c3ea6304871252cb49725eeec766515d3ee1e2a77e32462336c77a5f2a7f80363ab36b7b03223d48914358a860809a43784d8987994bba955e5d95e61ab488945c558535a12c47a7f08bc3e83e4526cf644245b24c1b007e6908708bf00aa007e05d03321e10ffbf953b83b8e9a0010c4e0ea815c335fd71cb9d696bd9499772fc3745fe885595c22ad288bc806344cd0fda6d06026b3baababcc7dfc6703769e2ee2b98a838d39e03790f0bda6ac28e17e26c6d5dbcfe1971edb9b3aafdb44ce663f8b72ea89b6453271be6c34974edec5c49bfdeefeab981d4d8e58b5c87e58392c73811f56be707acd2cc5fd2851d1b0c297157237bf3e0c44c1cc3a14cbdc40dcd91c7e9a2095ddeaf8710508b513725cb95e6bdc6d8300e760790ee3483ae9469240e73b211e89520344cebeb0b32240ce162d7b1f83c7975dddb5cebf93ced9862203ad52cd7ce18ca44aa7e5b1bf1a45be2303608e48232fd36ae66cc118c6852988d77d43646921a82d45acb979e07750e8b64d9ad5daa91d7d2c50eb18cf288160b32025232b2cc0fce91c4d98fff4cae15f310bf82f95773b7a05b8ec07ce1485c5ef7d223662329faec61efd0bfb960ec6fefcaed03fb1c441c9aebc3d4c130a42b3ea9b39ee915460a8364f73b70c40ef10ec46c1305cf2a70eb4f7abfbd8abfe9e4e8a2cb521b023ddbeb3899a451810ef73026f3c3c2829dc9b1549ef816ea87989f90676460e622301c5326554d0ee1a6183d22fc64502a8486e041dcbb129ff80672efaed43d80e50fcfb0db7c98cae96af8c6a59587636aa41c6466d83a493e8b9efe4628d89a797261b46d4116e145de1794a9009187c6cf7ded0e3b7aad5f81b9fa262c973a3d74d0f1ce234b7951580f7a68c1300cb79aff9cf501f63e7a66e20b90d5dc11ab81572e9b56dcac1cf0c2420f7422f049e02195d8c5535c818e4b18792da6512ca9d48b56a3f4af6b5359335e57950f01477d9758822687af6ec00a8234508646571657a95d1b335ba0edcf38845fda62de58c161f2b2418384036a5ac13449f00fa579ed2558dd68741abf7e295dcdd1052ddbf95ac5a4ec9d69b04e0697da82a702d22aa9330ca8111581c038b58a2e7f75d841fad4adb141069cc63264582e6144eedd5e194be7e5fe420c62c377b1ed8bc934eb1198fc455dcca4797b1574856bc5f236f0255abd7e94963768f8876beb6f422d71e0ab58df556ba510cca223f607543db94345db1662d0a94cf5de41b1b678886f56aa925310a95e456d30301183c262689126d2f81c3a4f7044e4f0c45f809e6ed53e5e493e0ac31553a31615d5bbc4dbf4d3a52f9a6371b77187edd16f0fe17d8ae98fc504d658d4a9213ddcdaa29d764282b88db4eb435dd3bcda263498cbc74e4499cd101359441aeec713b1462f2126dc8a9f512addfe8c9d036891422f8354a4d18c415472808f3c75f23d40072d1c6fa3161b38dcc2b1cc0f04d30d5e0147bdf92648f75e31af399b362e7b63fd03a8b39835b5c459e78e5281aa93ea781dfed085c5c17960a268d00e3fecced482826aa3f0c84457d75be8062179499892cf59aa7d83f0bbc1d192ded6ef89a6ce446224a68f0ac5cd65e9c3557c25880b2fab8098f5e05ad7c8a221116385591c05f86b2988554e566539b25172e22a4f848050209ca2968132b0b1f01f9fcb494cd1309d9af4cdfa7ec42eb87274aa1663fdd0df3eaf773a95d898d845deb5aeb03b0cba20b969283ed58434393d9daee78f5be845f7089dc44a395c6b1e8e1b13b1b44209589c6c12a85a982ea9c652c366b72524d26efafebce8db46bb923faedfdee340b5f68a5f8a6388e8e03b73235a07c5dafc7d62a641e25890c060160660d14b9a448048c904c7ac2e0700658b4bc9ab3fb9734e2a3d277a1197ec36cc68cbe451a1758d7f309df3556906c069af2582c6778b69d31da3b0e6956acfb0cd0cf97dbcda5d2b20d93a485b7b687a46b4e5b2e93991743923549efd7dc6498617f3be04864aa9f1769e7254de835b611ad26309317219cfe45b61128437f787648a9140bfcb594a3ce422bc3e19c7da61d85e5bc6fd141b0eab4763091adaf690679491f97c74f84d9d5c97409050a7ad8c29c7b771255997356c3e4af49626a3b792565368faf58098774a376a7c583d1078e3407e9280c0ed2bbe7c55ee30a580dc5bad9db5c432ffa3a94720506d8fdc993783029278751dd50de90c0fc62e392188d20c18221eac5fee1d77e2ae4afb2dd67dba0ecc77ef08daa1c4a7fb6039b101c7b786ca9e220996e8897e85107385dc8364405f4ed23f06bec6e714b591f2f0033fe7be408df85f7aebf94c42458e1d830ff66340e7dc9964aabb49eae84b2d9b2842a20a81ba64a0cdd493bcfa37991b1d500157f40d6919985a349d20cdd065511dbb854e32c0b245c992e8a2366d69ac5f0c3dabf3bedc1ddd76f83be4c0598f8aa9bbe57e213c6c950a4e53759a3cfb88a3bfffdb2c81099a6632242afe37577bfad1894cee73a97233ec7e0eff85a4be52a6c094e1b645a43e5eecb3df6a3a8e51f9977acf4ebe91bddc3e6945f16a7142f0075a90493fac9a5b66afd03bce63b371f98c5c71eb63d0ff7c7a0b782afc1100ccbe35190f643be3d0a4cf73ffcd980c93fbe4daa477ffa120e9b06ebad7a4fe16dfca31fc791eee35eb70414f7726b2a35dca73433ba204aa425f2fbf52b1eb973ab1a5556e38b05593bdbe2e6881b9e633d12cc5879471dbc003b9102ac3da1725a0efb34b2d48b200bb03fb0f33c2ed1291fa344cbb8a9e485ef5032ba6a0b291d7702fa4d0a3c555edf7329b61e4ebed752181bd3a77b6444c7acbe128e2b5ebe12b173525d8043c08ab5ff6a299fcca585fee62047fe88f9d7f98824176b342392ad241ec60d09266371cb1b3426c20a4d17dd127fa0dfdd51aa105204302eb25c3b60b7d885f0c3959e0a0848b49478497e9865ccef8b962bcba4ad574f7bed6feb5f1fd207a11a7993f6104a42430f89aa77444d24f1d73a8742e3234593c91c9397111771771e50010fe0024c3dd47fca7204ac9b0bb6231d6722f1da16a7473ac82b88ee8057decbbdbf8c92e39f4bb77c3c6f312aeb07f3576526100133e0d1c652664e17b773056c2a38541580dd909421eee0a58383e1b6b8bc1cf92575e668d3dcc17885c145486aaf8240eb5692629970b89838d2959bda0931b9f3e6c9b4a895b0cc2399d7c4f91e886391aa76f372bc18e9e7c3c2dfe99ba2a07c5e09b9dbe5da347b117853cff5f88a26f78cb68bb494e4ecea17a6a230429017176ead66558a63feca207d471a2eaf68bf9a30886ed0a5b77643e7a123d5157725a60ec320a35da9325a7210597ee4287664cf2500f9e986f6e987417b97d1f713910ad46d1f1d5e3a4babe8f7e7df020594105a505ff81f928a4e6eaf697611a262ad7b0d7c384cd5c4605482cd78674e00ec7cf32c83086b620748a0624e6f4ab6bcf31e22c516bba90279883f9780e68c7bd6a0019936210fdbce95c849d51428f78fb35c6b4191e48866fef8655299948b5b4c16b312b7092de4b63edce0a0142af9aade5648c1c878ebba7fd0cb1fc562c78a665d585475dd1ba26ed21aa9b268f1cb8f2810bfeac2d82d982510bca33667f9a584c159c8b583acafa05f0238b7495ba6b8630450a7adbe7007dcbacea929d3fa8c5f44ba5cf4a4dc68e662874d16cc8943ce6e75d69ff37203400b7206d60abd309cfb9232bfb277bd97fbe030d5c908788793772f60379ccc86b3d89b9f263fda1211dafcfef3da038573df74408f03d1a60b14590ea4c3d1b6f819c59c53a20df87f0b02c3543366c21bca28a94276c3112190f5e023ca040f9c824eae0298ee622e235cac5f2dbffdb2d4703691d3865d7e6f7daee1e9893e3715ac03789e71971deef50e8daed4b439c068c12a16f47b5486437db28aebcca42fdc8d6238978d424ecccc5ea6127706b9cd2862dd5d37403d1082364d014b6d6530489c47f5a28f802222b7a161ab549e41d29802ef9be11f992d6b4c1059d7238b96538b193f7add3e02e7fb116ab97c57a0d97c21f3789fa3dcc79102c5c6f05d5a00b699a685bb547786df843d9785deb8bfbf0757fd8dca995e6751ecd9f2f8a2fc4d83b6e2f0209d514dc4c3209e4937990286984194f7c507abb1552a3dc6e208a1d21c22b2d11aaadcf55d3fa20c89c96d94556109041b9f4fd050948cdfef0af88f7d0ed6ec5b037b20723e71498a8fb334f304ac4426f95c61d7930999190bde9e535287c87fc790cf04bee0af5ba4a2044626f80c42001795f798698144085df8a743859211b1c3d31eec83bd283eff074f305b14ec48f18990137df6f05b767864b1203bd94c97a5cf906300d88ab44ec1a63d44f682342459068f3d1fcb7b14acf9e0067813d3037595be7d126fe585c5c35a01a7ac4ab3bb2ff38b74f24f64bd83e25579a8895a416f4277614556811f284b63478597d6cb75f598f3d6463ea4ce78a370db29ec20c35fdff1c4ac1abb721674c59ba508cda597619db431b1a0213f9770a1adc7b646fc18bbf8028aabc6e08d6be9de33381d04ee4440c9a803c9ab6bc256c0b5fed3fa726d606b2b15298756558f501ad3a459cb9df79eae73979c74b2425a023d50c5d118fbd17cc89897c903f04935fd660bef3b277f7abde12b347a9a4554f80508ea5c4115e58a5f9428f9b38fbf5d132e3f337d52ebb54a4d0b889153eb36ff5f07b1dd6c59637c6fd59ad87c50d1023648cb559d40c30dde325afb2663aba9426701827590c626ab385008a6acad26f46bdd5cc9c712d3f717bdfa2fc4b3ca0a4b5d595f60782bf65268a3127b66d1b7ddf4d04157849962b9542f220df73922cc02a576f971c5a9006c8c21089b211b313f927ba0cab12cf61db75e2d3aab29cfbe2b073af57adb11042a82a62780fd451afafb1e81bc7fa3164c4f066c5eda7448470df082387ba0152a72a0fcf24d1d22ab1ef3d992087456a478632f8ae1514ab97302b31f4dbff4e82dfbedd79ad2282b9713e57127b17755f23ee6dc7268b147d6f7360e5cfd51852a4142827c8432ce1978a97f88592d1ad66efbe84ec953b93ef219867e8dceb53d0bb930f101e397899b20aee7ed45cd64f04d7191f7ef79671e11024eaf5ab7a84eedce9b8b86ffc06bd0d6a72e550abe5d96026852e3f8bce87281d0778c6998c846e37c72460ce131c92280edf2972e73f6b25ff02f499576a3b66dcf740ccd97eaacc6a0f969617aeb77c3cd522e1ee025df477076f2f1ee39b874330d3a9df6c6ef8425b6f7143cb71d50a277f386cb188067a7d08f28fbea5f8695ddb0817e6c7a2d16a72e070c0ad9f8690e84881a33fc2e8dfa31dddde99ad29d4747aba694729fe1c9514842e58abc83c4acaccb302f577f8a466ed6ef5f8b8a316992756b3fc0205ddbe370466f092287ef6268aa51b7e39ba4b61624e75478716a339c0381402a9f1c946d0e8de658cf73ec86c25e3c0ff407975456ec0630db8ed7756d9de7798078bb9ea98c166534aa32579001b799fcc5fe27c6992a266238b4a65f07a6f62352967910d0e432624b82f3369e154a9a313b05a6d7868d13518adacd1430f001e7e8c8f9111769c426a17ef461ddc4d3a7b93406387d97ed4b099365b18e730c126d83d46ff97bb862e306359971b72c86e141adf7bc2d778196e89bd458ee68e1cd431e49a2785e98b78a0e953a69ecff798b36092bd268cd2e0e01aba5a0046aaa5f0d1ce05ecdbe9c55b684fa59500406fe7f62b57e03cbbd6ce2451883e9ecd3726b2f3ab29e295a3e1cb9e54847d199b5de6916c97805cf8169a23013f0d2a2fd88ee7bb7e702c8897cedba938d232c1110ca15ee8cd04bcda37d26e1dda37a8bedaa71b9f4620b735df12fcb50010015216cfe72f36bcd85fa691ba79a2420ab0c0657378c7e921add287b23957019360e9f992197b7a2ea446149a46cb1d59338a56d592158bc31ec9568b87d9e19e871d0668170ab9c8953bedc39f82b1e62fbcd42fda6e402d4a437ca037356a5f522e8b65d7615032c4a2522d809b30a57dfbbeca4bef60a0d48f791b06dc41ec6fd4875cb6e3393b4bc49c177430776cf02727d2761724662cd52945a127b960f13ee0ff110ed46b865b5b3cb4e3a8b9d0ec94b6e1e789d46602d66b2af8e9fd61c19f2a5df894492cc51db4e42d82562e40d96c8fd50c50a7707e5fa4c656aefc40431df30011d05344914f5e111fbf3af7178dc66b3c4dcfe6f2f54c4835adb0a5760a855df6355560fb5e3f39c238840e609661b135fe26c007dddabf79b40bb833e769b9efe964efa46d2115d8d01e18dad5837d81c9d8eeacacce7a3eeb5adedb31f5ef1e260b0d19dcb41325bc88ff342bd754c9fc45ccc2228be5495fe0dd0540157fb84218896f213adac42952d8c6566f090e4986a0346ae78b3e11115411dbf8d84fbd6ae35edca6c51432e777e719b8f97b7fc81d7ea084e1e29905a222fe81a79bf77e9eb28741d91e1c24ba4bcf46cb69a62aeedf4fe5d11dc0beb949ba31c9c997f7cc1167f78ed9c0b4d3753b527c96a3c8e450d0d838f16f3119cf82629b4c8bbb59fbf1b1f7d8ee886eeb4ae2eda8d88378665eaeba1980dd3bdcd6237688dbe6c1a00df19602a342e987850f213a4a8fe75873fd6a8c1366b0135203ef98651ba5ba4068d9e1cf7c5035783c6c9ef031243499b8d33e675ed5d2cdd13581d4597997598ac97bec01d8500f7d36f58dc8e90eb3f8e83e3087ecd00373e90cbda6a22bf8c36e3ec87b8315db33af58db322d6752182e0935fad9c27e9a2d240cff807341df5b7f6cdfe3e4a41d02c5483d2ae0a7c06f5419f1829dc7f4aa270f28a5b0206b64f9809ba0934543fdefe15a7ad591dc268a0d06ebdb26ed495797b88901785bf6c32f5e0f4e43a96abc52bb5d3f04d6624082de25fd6d624df10404152bc3bd33b9ce57a8cc65aa5daafa30b7791e3d011eadd2a5bc6d04019a9ef42847992fb6a700232347d6c3c20b5131d6c434e71f53e25f13c07e6604f14161734bd05695986a450da79853daf51bcfebf2a221b68d27f6610f68653cb681c5f42df087df0c45f304b37397281289fe46e5d63978fbf9d1c145a37ebeafd14919b8b03feb9919a9ecf6c1acd2b005ffbdcd26a81b29bc8c45232b2fac3d414c4a61c97cb6fa8ac7175fbf69300c5a5e8248c03bb036cfcb2d1f717aefa75617ebf5da5d7ed0bbaa08198526ae867bb8d580e8c158bc8cde9d8ba1c9551829e7bb268e4525fd6c9ff2bd6bb89084d2a78aa32815e7873df9ccb81cbb379447bf29d663032acdf97d42419720fd567613e61372f677fa17621aaa7a6b197ce834f09b00d7bff9d46abfaa69621513c06e90b2c0443ca687bfee77ea881df7d75c9e60ad75f83e17f86e2abf9bf9acc73a3f954199699be8fc0c4ef02e35aaa04bebaaf9bb2e98946705169507ed80942c48b9ded1b790a20e12a9fd4fb20de911f3accbc50427127539a9274ec11de1be30a8a71968b954d5a5082e6a869540ebbbd5059cc2b9e0561c83091f4f7f8d26a725741f2b8a2dd74861ed2f3169b97ede5b467e228af5d0e4d261af977d3d079ea42ba89e2ae6b63aa19fb03c6471c56e5e10f5e7e6024bc45b4438826c1fe35fb0e3f0828d0fd50dffe208cd7d38680a7ecb8723051d7a40cae5cbfa3d1ab4ab914edd2ef6faf9df22e31b66085194d7fb32da22a2153fc101ac2ab1fcf14c1da1d978f04060e1fafc60147fa86091cc5e2bbeb69215e87fbb7d58e5024dcb22c56223b763546443530237870f95b38aea8c252e9d50ca55d4b4fbcdac1df43d8a38adb108b7283248bbd4933e3ad9de63290382b15894127c9006a3349f72f12e3ace918436cbf0fa019b577589250536c0b6e1daea6d20032e627b0de9f96320c5a286a79ef5d832f2824b613ea4804ee4f30b88dc37ae992a9883b7b4366cbeee1da2d0748517019b6cb5d3061c566e15efe8f748dce88fa2323a316ec6302957a9c96f851e3fb9337627d3811847a422aef25156fbcf014586491b17c283f7c8fc1a05e8a844a21246c43590d6c64c8ae4d3d8eb62820fa81f882582e71e3f2eed5844ec2fbfff06491f1942b6feedeb981ec29561f82a5933006e8a4e3682b9cbce6d186a8734fc5f0f068799e038702c4ca620eee89ff0efdeff5a3f308b50883c7f99e6b66e684e8c5f4c997d1d6bec5e5858f081e88d4843b4ef9363bdda2bc16fdf611599d286af158644362bea950f10b7fff4da877dc4152c14f4326332db1ee63dbaf7513d92e46c726ff1814f3313c6b2a9646a1f5812d7550407e38c8fe330af7d63821b8c800b5082b57c2513779419726069ed28f601c8eceeab0111a6a2a41e651f783aca156df1646a27afc92c9425e27fafe87e5ba51755b0eb4fdd4daa3d513e670c2dcc76deafd9501176a3f1f564cf8f8968139cb3fb3ab575cfbcc1cb152566181299c088a96996d4319809e0c1e8b31b67b4e2181dd22e23ca71302c25a16ad092f2ad5f6452ede504bcda2567776ead6305181002744e8997cd0eff858ab7f3f0f6f672e6ee2bd0332c2c6c8d5da2f554b4ac3c26de3b8fe9a3103ee7462459b88b97ad43175a81119ca0cea5b70ea7b1bba0ca17a9df8fb283139abfff4cb686a9a8fbb0b9ee161663ab6ce36715b0dbf1f8dff17c175d0ccb7a659954652d333bdb71178b14d11c5ca4a8dbd839c2d64b52d4863560d797412ef1db4ff3ab25a8296b9e42e99d408e34f7c603638a7f17c1ead8bda7f40cced26ad8b70058a15467cb80d2a5fb457934d585b153cacca895d12d3fbd9c3f57cf94fb122c56a63fa2d7d008d0bbd9183106a4a61b5e287e18fde0dec852f31cfb8018ca99e154a6481b20ebb9c5c89604766f4a11d496e15aa518c8b8bddd9485107ff1a3a500d5c40c67a00c27ad5081e844d4995dda3a97c83128dfb861314c5e4dd69bac5bbb4a0fce480a7e9e674f5cb792f6913ba1261ff95e086f00d0041eff78168851a1998982dfe20904f23d680f41e3a0ca6f219faea3ab7a05a845820e621f2f5ba779193497cfe9142ae7bcbe3bfd1908be8aae67108e9df1f0aeda7465b2204c06cdbda67082399a5e18fe85aa5007090185b94e57ddce39f4ec58a02dc418e41143735f8714d99259dc8ac624229acb81a49b54854d57090fbd7ab6522dd26a0ec16783fde48cc60de252b3bc9d70d95357b6e5ddca4552c21377de366220524a927dde5d87b560e842e51fc3f9dbab39c0473c59482c943ef3ee90323a826f9e9fc89071ea47ade682491f18a188d4ea0646379293b049edc3d920ea3ec3519d0e3b93346bcf2d95cb0ca85f5f59d4353d89d49425bd4cd5aed24e812402ee338f484a875dcb6be7faadb2b0e830bbe82e0e132b131f8d7a6c4ad7f78de7ef8538d719b3a4f3ce6b8fdb2f2625aa7e25140cbbf62fe109ee8a104ba78cb9e06582e46a9ef34c089532fdd125ce434afb14c1169a17a5aef5282f4f12cebf81d8315175e152902a62bda258bda3f4c617d4216e8f7290e6b1da43ad4b8f791751d9937d5a3d7aaecd9700456bdf3389e057df9922cfc311d6e4fa0fd76615a8de6709c070d020cd7274017995bd9a7d399aefc477818969626ff51c66647d8841f7731fe5af8e0981344fc9c952118e7728ae2aec3510c5ff7d9b7d04c4e5e5ffcfc151daccfa71272c23b61b8d9e31b12739bb772e75adfc91347158bad3184995585a95820ec081d270da2a68a632da2965b39a81f3d03c722a4c6236082d2c74fdf8638f4052a1383ea23ef6d4f8cb7c478b39fa487a5b243d03a0956a3e51ba3a42c6f7a941c420450bfb8d07ca9dd12d7a9557f21e8d3490b55c8b81278c2d62dadf025ba26f35668cf9fff02e3bb3dddc1d5535641ed41070d7a36278d9c2f76e9f2d01ec8f34ae86ad6e76e9d7f6a64185f2b6ad360b8276aea6a50a2cc180c20e052a6cba756b3ff9cf42203745e1f1a793442a20b6de1d8992324a3da8dbd0f6df5fdd4ac613f0e0d507a1294e139930c18cff7482e28af7dba59cc42e7e335adf70e74bd5a3fd75fdd0421e5a5eae7ca714d23345bf3fb5be3ee8c4538f9badd613ddb743f126b056d55f8f7793bbd19087597632c3548c2e9ffbdfdbf7ab047e252506149f8dc898e8ecd886603c87cbe85a611140ff810ad9fe3b3d20b778f368db393ef01a6f881446a31e1bf64df8a69edee050f2283a2fdaa4138efd58d52e44b8d21bfb05e3e39a06c6e4fc61cffeca3f6ae6ff540f6f6984d4413fd6f49f2628cc96376f18631bd48a92126c077af7af4e1b4dead875959b03c25f89886e2a9bacdf40116785517b71bf150d38a176e89d0aed1bd69e16a9091507bcacac7d0f91e5777359b4f708f65862b902ea2d280e4aa1438e24d8d6f1682f0bf87de22cc81980e41c929d92658748d748a858db4cf7da8383c63f5652c33813452773200ca2b6a0ca4e3520d427269eff7578a68a20dcc5cc581212bc9bc5c69971bd69c79e82ddad65e5fff6c919c4094779434c7cf0bba6dbb040a9a17c2fa3e3e03111c6ba15cf2f546b00b6570ef76ca76fde6c5b1a3fd6003409a97def02ca4f0e583e6aff26d8b1811db9a77fad754cee9267004b72293c01389545e49019b98ce725957a537d3023d9a55b36a347e0efe6219c175e6189e895c71233d642ce26bfcc4ef6857569565955bb01be53cec2e1c5376d99fae91674bcd25004b77a0125039bdc8ee4400093f4b1228d4bddad6b1bcf29f3ff7688267e4a58db5e6a4fdc62456cea862393b6b90759012419857c6ccf2235bd0d5d3c0a49e09afade65dc4cf6f0b27fd1f32cfe89c01fb9fdd3265c429851e332f8f24e67af6ae2c269cc0709670ea1e1d69860f5be96f8a06f50c66c3f0749c72b594f5d38310e98d15e57b2b6c2970a2c384848b36eb63d42b8fca3daae3e5e3c2db0d929521ccc6fcc1e78a4d67a389b3639ab3164599b454439eb7cd0708400ee078c797bf44bec687c9e74eb7260b03f3ab4f8a3a553c4bbedea2a7ef41baf18c7552f3d9e98b882e6393e33482fa4b25ec5b1f20b1e23e79526939e2c8790dfef7d1a3ba24453944d716fff76aabb600006fa0d89c4ef567f72b7abaf98d6142d293ad7b2c8784991c5602e76bce5cba4d0ec3a3282a2bc73f4a1b166d1f741bb0234b9c67865725c1d1b847a3471955fc84e8a21ec4ce060bc963bea6d8db52f42d8190946470754df46aebd35d4796e494f5c45d06953925cf8958e1414ea2b7c72cdf3ccb872dee9b8a10fd56f1c00b384e23960e8aa64c9895c3e6d3d9df66ec69dd59fd9e622cec1bf31c2d120c243ea35754082921c56e6c4941359abb702b66da377386e04c19c9b09ee6746a5ec6b5220dd9bb515b4e6378e772a3fc563ae53e3663858fc368edcc689ec81fce2db61d8c73b5b31aadccbb66b6328ef64bb8965b7652ecc411f4c7b158f263223fb8855732e838bbf74848d25a597f236fd1e5b221db151579e8175ea3280c785d4c6e060f376efa079a7d02d310a41de43f517c97cf85d31f89e65e41025aa69eae185525a15d09c4739b2486f3303e6d423fd667d1a7d455d263613ddf103378a60f68c5d78288cab22c5216023bab8bb30f18bd7f888d32756dd89db3c23c1d6544a37644b64c494fe7f9163b2fa3f6500fc441f595d00386d92d35403ced6d1549d942a6128e79703e446683ab3ceabf01539a8357060a69e45ce8366809bbf32a0c707e7997fece87ab3b7da66be232d4f432c6e932e710d544ec4b1e21c149e4c4096313fbffa45c8bfb7ee076241d73a4fec3dc936037460127dbe28ec5b8c6cb6cbed4bf5f4d6f4257c53cf66fff7f67a07b59a005c40f6f260e8fe01087985b77256b119ea41ad4154d751fae0bffedd06eab3da4abdb5ef5ba142510bc043fe905fdd8e15fd3f75ea477f9194ef0466c5cd20dd36f16030b7a0be08622558e702a0b50b946e4816798efcc619290d0c9a38d88a6a14efb4c37e8e851976ac8bf42ff7075214c09c9691956f7e948b81da3ec03100710df05593d9ca285653f0d46d6f835841dde0e4f2e86cc635f60dd0d80c86284cca4df00bcd6194658df503d705d56809ee52fcfce85a5a37d811cc7828b32f55ca361c508cf1104f1437e8825191408b4c6e8bf4e0872916b45607dc29d0656ada6021cf5c421f5e9c4b018e00fb897263b58cf49f76453566ef1497d7404350ec95afdc7fe95b0b57d887def6940a85f5de9d7aeea7fc790c96a0904f1e160641091bddf84edd30dce9a2004d21540434c1744a5a20739d4124be9f739b246997d6b0bc4e48c837575bec1da885739f6f19a54faf943307fb92537873d6415d30ab01959054a08bd53ffabecf0b14fdc438960b61f19234c3e2ff449c3e336f9374dee469919be9c0ea7b820283cb059e4b068a6c465fd1157054c4df59378bcc3bddc7c42a62d31f10e3421ea7770c5662c1eaae1ed47703afee559b7c4b4c861ef33370ca33cd2ce9d688023d8ad89fdb170d982c6db7dbf232ce790fee711838beafa054fab780a0a98fa13020f0078c5be7d5a4a054b17cfb3b3651c26381b35c7ff7e87df8fab19f329ca5f686ebcf41df7d613f93415b39461477d096100e9208e7b850e521b5fb0c67924b3d6557ace48be1f5bc98446887f3eadaa4cc48d03a0ef3e9bdf5447637d3f048bfc1356a729ad03b04d9fc0f53b1b38935792174694afb306b0adfb9c28e4c6652da0c24fc377154ea6c8953dc38a5fdb9c062e3c883115e57af1f6744714de4c3078709e0e855c54d8e183a88d4f5b20f5391e884c55a8ad001987f9bf7e006a625746e487b74e6fa4a86bf2b2d74d3b700e3bfb95651b102972a1311573e1382c4b8b5cf8a26680904764e53e9ab27994d57de741e6fb843117bc4efadc038911654965cedbf0d8dcde152e5d526949fd69ac2161574987ca0c96528f862c866d3870c130bc462b24a0c6be62456849fc52ec80dd6b4a5165309046b979c72e025362de87461c5714604ff31b6fc969a020fd3502027e7d303b2d106c43fa1c63e4ef6bafdf3b4aaf9773f149988f0dd0825a97e59a1fb0a365cc66288643ee7a072f6c757ba5b76f121fee9d6bbc6a52bbaf8144de389c4668690f5f9e92af3e1583a967e820fc3048282ae719e0f74202001e0f3cc62d5dfd6517fabeaa3c18d141de9db0ba4f68bd464320f00e8a5162510627531be2ebcdc7215320d38aca9f81ea40a3cf7d98894007f9ccb478517312408f7c91311b8d703ac85a7c3ede5bbcfd1da1daf4eb6bdfee99afe49be2a75435399af228d8271f54e4ffe32961407048bb569705257c23b954cb7bfd207e0f1cb2694edf814f2f45e86e8288398a3d85b1cd6957c29dc4c279d5ce08973846e5cb6630d3c90cafb4172b89710d9c9da698b4868a8fdafe3f82a2188348501538b33eeb7a0aacba81598e19c3821fbda84a2c8a64676ab9415e6370d64302e704f81b0d4e2b249c7b49f889d4e755a571bfff3a47340c8659dff1446b65b8f82cd66cc6f482b2d4b855f72070804d64c6ad84220c0dbcfcdc56016eeb00e0e3dca3278cf2c95534e3b381d6c871a8247d478ea0622838bab6900c6dae0343b2073dc029a739a21e3b9598c71cd068b52844e5babbbb3c13770ef5dae2d9191f8fe89a920dbe6410da67ef4b7b034493b1e4e1e483c12ecc25917eec49f52e0f6f49305d3ad5669a92b40d676ab5c8ae6060f3ae7730abd809de383e466345e034ff824cbf0a62c65c79991e55b8c046f8fdaf3d00a9d6a2b8cdb452d83ac1b62c0dee46c5a8beddc72fa35f287c51a0db355ade95f2a7fddc8c0aa430534952bccfc8cd4d1190b8d08dfbdf611c4d7df53f22a9fc5d2b7e04f1df1ca4f4718554dff7253a01b88c7ed55e90da26e1e0f36119ddc262b1df9075bb99260d46f473cc8001cd26a506e5da748ee73d3adf53b0d8081b703a051fd7d62ec100ba14226f4355597f84e801b949a47e2ce9feee79655070a5cc9b52bbb92311df34eee84069f3068710cbe0fbc2ec6af244ff0f274082d788b01716fd8746e9ab12309294f9fa479af295fb3bde66cd62a35599cc38a4510cae8b439ef55c4b1d9629a584043c391061c89c4574d07076317c43daa5a75b5f1d1bf19e18a8354687b55af79fcd1aa7b8a92008e1dabe77f82013afd46c62ef3b55e5ff35cde673d4dbfc2e49c4df8018e1c2b320c53f2fd0d49c7499bed1c696e87ead1e47624d5716e74f2c35f16ee0c6c0dc88046f406b33efae5458f93b64b5c37e62f2a78fc53bb304f8926ccee4a160b4729da473a6bd1c0b601c643877f451ef1985eef3a0be5043e73b6120c940d7a43dc59fa94876d67eeef11587be4363ebef2182b464145ea62a2910e5b03a7beb92ada8ddca25565719cbb3f705dc157549755085afea773c79a788611d5e7145f71ebc9b7dfc66a01ffab420113b6fb8f8df8a5de69e2c6336d7d711ce0ec87e6a95d62f64ab35d04d79a9095dae01394a542e314c13cca05f53b49333adc0b7c2d928b920f40f3174fef7576729c453af478579423c490fcca78d09fea631eb2d3de13ac197aacd255772528d27a6f17e2a70a569afcbd0f9a0c9ce2531742e43f2d179bfbca8d143db3692d7cf1123128da6261dca474c3556ceba1a9b29909626b693b17af0c788b52c3588be136e7875e2fa34800e6e6bf0c9c539b4d97ed551fcf90e2c0a6ebccdfdcb7ebc1aa973b35c83b23484b249f76227ab96ad05bf80355bad7ddbeed0994a210d926d39b11bfbd501677a66f76a371369ee4b053fc675a830b9b48ccdafaaefb27e3e8c7df0db8e480acdd7f574f9b8234acd7c107ebc87d738e3435f2eb377f405ee6dc80920e06ee430b5fef7a26c1f92cce7a3a19194a8078b9ce3dd4a4ccad002e6495cb302b24be0189b6488c9e346d5b944679c0253e9f0c5131996e2f47f9e4b43c3cd7f7b84900b32f8036b03996ec88a582fbc9ce03b40b9715e5e91191c2bacb3e0236fdac0d4f1d8abc97184921559cdeda97d8bced4b65048a566d6e2587b55eb0cfb4737b36938ced0162db607d97fef0b9bb578dca243684511835d8f3b6edf9e67b755bb9e93ed43b732d540c46d54e55f870d9cc7a38096ee9b73be0c15e55951dbcbe97b31dbd4a6a023c94a12ec114f23195365f1c4449b26df5c0c760ef7011d46d60c51273a64bbcb2b2b8fd53e10b62d654a88b7266e475939de4610c662db1ed3140a7ef6724c57fb554f5638ead34c70bfe4bb36e2632f7cabfa733d8963460c12e8fe733af685155633848b2ec5a662e64f19cc4d54b65e1b147afa5fc33aed0c7fda251eb21a5e2ec6b40618cb37fc1133f87827a6518166360e2b7cb469689b05fd01e45187052ea11d62833621aae38d9540627a1a43304d65e55ab22cc98e55b1ac1cbf34a05717f52c077b099715fd2a72bc1eef86ca5a02f6d5dcde56ae2f552b6a93b6c67d41a29d81290012a621f933f7c583bc7d0c05da1cba87b4c47c028cd361b899c0cbac50330e71a03723be4b9bf872700b264ec10a574c44438388afd9f505e7370c914db50022f25306405c2f04c760de87832f924d65c29f6ffed8923577838fd35f485caec92d09595a6b147f3be9a6578b9df87f5b3269de3f4ab6c06701d8f43a35c895bc4de3db744020d507df28dd9476693e60e1c4801107f0f0a4786f98aa2763932eafd5afc1f841a99a3da23ea607f20b8ce45f03d3f88812c08ef6c305b2a0220c267a2c10fc7895d6a5787c0e7e7bf7aec68bb7a4807d955eb09445d5fc3f4ddb085e4880798859132513a4728144727b2e4da15ad6c75192fbd305f7a6f83b411bf9eddb296cf2002415aa754f8cca70f812bfd16fe701dd5570a6908c27bf959702b21a267413dc3f440b4e6f6f0850c10c86badbcd9e09a200e37cec18335c8dce322c87e69625c8af59dfc9a444606d5c040a2569ce48ec33722465d48da1232ddcc6aede908b435e6188bc8bafb0f5ddcc3ea4c6b6d381f47ec6c666794ca02f80b29d16d3454193b62a720d7902c21329e9a80d7470cbe80d35bcab9802fb6673e727e60e3f8def8820dd8e30474078eda58d2704e8cb1d2c3a79b0f7d35757f7c1fc2a1d8e6288ad7126fadcc8007b7f4bcb5be0bcb89b1d6b2d70e5ea8a8c1f8a37f6c044e18d84242ba1fcd46257965531198d04ccf5c5c899ef770d9f807e5d1ce79b755816f9b1701e7d3b45fe46fb5912a2cc9528e3a95153c43933cf58c2b8c3cc50e34aa08e9afc8c31c11f6b9857fb875d0d42f3ef63ffe7847d3fa06c541d20d3939d59eb4c0db7744695cb9edfa1a8e7d665f3c4399c47e0d6d1c8135185cab18ab3ec30ce058be1f9b06c4ba618a2519953132a08cae484befe40879c8998b5459ceb46dea859e51201aea6270877a0888faebaa152468c47ba9824d6122b877fdade294db588698dea936c122c48fd5900b834870d39871c60693afae7956aa30d19f15ac152bbf7bef431da6f28febf6382a776cdcf8e297f56f00df77b9e245dfd92fb9e487818ab5cf60d0185c7b21dfd153dbe7f4d160647a03a52b5fabf138c4fbdb7827f9a4b4453ef89ec26e9cedf763b7a13ee13a6d9177fe23c7d65e1f2339e7942ea929725164c1c98447aefbb28bc87acabf431ae55ff017048b761e7aa465c3c64642d8f67c94e2ae982855c268cdd24eba4392bb65f74443010e2980337057e0fc8e86d91303fe6889758a0a5c8e55639e694361aef1e6ba5e1d74e75025abec3f7afec5407945f440eac521761ed88d887f4f3f6f90b571be1ff0b0633fed19aa9507716156945fdda0d5432f9f4b7f58ba285a83e716b3a0ded402727656d2582bb06a97babd0057a9482ce88ac3e6865f706a927e9f0fc12c801305a9037de0d5e7e063eec5ed3032641f17846749f73a88fd6231fab759774bcd7907c76d84e6511cf3ada0e1d36a7f7e1925bea281383b52f8c12e1664a196990d9dcf168096b491b9f609453d9e664a756a8d571415486e5b50645c36d5b1666588e979560b2407470bad10ab21fe17bac5a7f8c244d61c0926e0d92c6d5e4155da82c496d3373ec413fa01bf7eef7e4abdeb15172ab06d7834887c0050c72b6b1888a5528e3b4fd5e959bf7dea7eaff4a29a00b3db578c3c50c3aca2769860dd70ee51b637644dfa1548ef0554fb9cb9b662b5907ad3dbee7db7bf0b28f9366ad5d2b0c0bc6d3b1436c2d2734609314823f119bd854449dedaebec733d29060efb13bc9540f94fb58cbef17708ed0959ccde8983e78a49c06a0ec70e9b6d07ec1931c6b5a507f6aad2f91d3fb7e901cf494b9c8aa197e1416be5aab2104b24d1593fb1406cf2aa134c647a22ffc5d50210cbab198eb72b98a9f5a6da082d7f0c9b17eee79fe1b089b4e7f7a491e8558398bbcca9b3d411ddec7d9cd53bfcecd03d8bf558642eb863b5089ac29eb4c82899337477ad408fd4f6cf19c34826ab51f8a6c199c1535f415e48d9fd3971dd106f41ca3882746ff3415cb4d135cec3ebb709db52fa06895e55eab203cdb273485877a0659eee438f45b51a9779d1509d51ec93f1ed5ea71f9982b6fc8a2564e67afcd7ff73464cb81a29dc3ffbd5013a854da1b53c5873391ea9b81480d89767fa4d8f10ddb6a75bc5faf31f7613007888b59cb3462f9d4e631c4813fa15b77ff2bf925d8ff062907c584e54cb418857bb0060355e4b6e7805ee1e013350015580573580512d9269d3fcc3d4c8514f5b5463a598bfc782a307e5af150e354a6458bbcb20b7e8d405c4f15c31027504f502ef85525b429d77093d176e061b35b8f58d1bcf7de45797181aaa46e7c52d40def5f24a7075e21acac06a697fccf0ea09f67448d67a0b64c8a5537aeac671fc94e717f5e8ee8808c62a80f98ea813b799ff4d8ee52d84154f72274a3f2de5ea04f1efde5790a3f1f6a74930432bba08b7292fb4cf174ae395904b2ff4b4e1a700b06abfc021130fbcc0affd4953017fc09821f5feba6b4b107ba75404fa016ae77043c09c6584a868c7e6e86af538b9ed21100fe2d204261db03e227ea49093d9dcf891ba6453c0e66a0ace5a62803e67f31b46cbb6a6cc832588551c939323e02feac6d80724e5e85a7d89e6bbf85aba1d14c858adf6b8ad95e9b535cdbc0cf067a88a1e36f27ec8909ea8ac365ac68d9c695e336f3960b46850d290f81923b1935a6a48b62f316acf13713c5159ae7ced3853e4d27167832403aed965eaac33c35321cf1ddcf56307c10512b4f7672b1ad122d1edc867f6230b0e865c1ca80c6009739f774dbbd3547a16b0f444b1d974a09a2ef5135519383bc75c33f57ef44c6a77180ca97174c9e52ecac28551adc901b37383bc225a828fbeff1c7d4ca7cf400e455b58b7a2256877012d1a3b43c6410ec655f4def09aa161c74299209d84f23b8fd7e17b04a4704cc8e54cafbac70e8459cac573ff34ea851a55c0c8ccf7ff33a36468240c5f8ba517f7c2ba658d36e076b21ce64dda43ef2bd16bb840e3f5384f6edcbf9b53c69a27d1ddbe22157b03b97b4d0161ce35082c5090e828429b10df7a5d09503f0a73d4cc36b6695fe3f80dac6cae84ae072231bd34c8fd85870a4c57663423020a029289970ccc01452f1bbeb56e73cab9cc3a51a592fdd1100cc1c656f8b3367ad3ce26a47951bd2ebc887a191bba3e7063429b2448c268c9cfe01e024942dfb18ec19251982a25302e121d6b5234aa3d4753dac79e032701664f83d75f1317be616536c48716fac3fbf602443a4558d4b95e255f135e5e1908c36d24084e4bb7cdc36e2701335fa63a0c6493cb266e751473fdeb06a8295552797281679471ead4902342bb3537c8badedf99c86d92c71f9aac79084dfef92f492ee522aa40b005b258196e6fe32e8407f0d5ce41c77efa47ccf2ff74b524837535d8cfefc91402ef5f39fced5656c0a858bb8650dfb46de340c5afbb16ed8113da12dfd92ed6fb6cea8983d68d47b33f2aebfb483c56440119edcf31b7ae2b9eaeda24ca6dca3986863d18024c15d9f604ed2844ce2da488e66b06afe6dd3cedbdba070ec952b7235a443027979d25a88f208d76c4c9af6b622c7d548db51495237436c4b6eca7cf9fe11151697aadb99c99ed144eb12563dc4462754c8c6e4613c2bfbf0c6a2302eb6c14b80f5ea2a7b429ed44278d3e89b885fc25cddd1287ff92ca6945d0e634bfae07172cbfd4a91bf3471440e832a56d8e422b71d407abc146a23ad06c3cb9fe45f9551e454ccb1357f52a042637474f9c94ae77564e08b4b073ba005c29a8f50f5af6f72196ab6211f76c6573dbd37b6ecad47172b052ed6ef2ddf6845e41cf2ea663ebd3b9b0bdecb8fce67f708d07872257c53608ba9acad6ad824e84fe7509aee2c66a952626ebcdb54b4a1cc89d858e9378db4ac9582e48a25a703ca78a9ee70b1bbc7a822985f5fbbf54ae4577e400792fa7e73cd5170d306ddbbd4cc2fde8ccff346ac82d7e132525491ecd49cf36cd63e7817e006c56381d28af23573663e39fa2ffacfcfbe40428160d83aa4d1dee2883215b2869fd36ce1da88d464ee0adbf35423cbe9689e82c456f29f8724e6ceec89d746f9e5547e02f9c406859f7da02746a8b30376b90fbc5993126a67cd07959cd5239dd6eb029a9c7b5c8e481aa77e5af242106d0d4052a79235ffe0d0f6fe1e94dd1c07eaf3570fea177b522e59f1591077a02bef8e1b49cd858e295121166ade2a86de9147144bdbac930aee24a1b830a68a83ae70f34d5e6f5994d7192642d4c66dab3bab4b7cbfa5d53ed665a85146e66e48981d6b6dd2f3809a0de5b6dc39605c9f4ce605416a2a54eab542d13c667fa2473b67edc1118b4d3624b74c4b9dc910965164aec73acddb75a4963e3479efc2f127d4ed67785a2eb00ecc594312ef867fa293bc81dfcb702987206f9f95861461b87b25d18868dab3f510466c6c1bfb6e35be1cf1e3ee17e8b9544001ea23d85e0ba0c40d53b10652f120fa1810b58774003099ba2917ddd593427485d2bf21aff4398c412cd63beacf6d35f18e8bd8529abfd65b57091e7934e65b4996c4d4e2dd86bcb114766dadc113f5e03082b869f433d615b9fc5d225688f573bacafe81ecddf1b601dd1fa1ff4ec10e46b21e1ed2eaaf3dda2a1379fb19767ec8b4906dd57f52d7f03dd47ecb164b187807d24b535e8bd798d0441b41a3d557b1554776d66e90ea3128ccbf550c78f1bd02cbb4f7a2522b98f5d2d6a7eb11b3321241c84e87cc5097981def9ef84e3fc97824e46b40b3e50aa9a74f30fbe6ae8d4e71bff02d39cd4b5dead985e528247a5369be909653f83afff373524b210d679eaa48dcece292a2c789c6e03cd4186f646eef97d048a39f08d60ad6983ed55e58291fcdccde4f7f7c433c5cdf3ed5d27cdb9f6dcf6e90ed33ac667f73be2ac1036d450934d877cf09b23a3f798767ae29bb678a5313d6ac945063bb3c2e5e6eea79bf33b86d85ee4c9fc892882ef0303f3b5c3c951680116bd5d8479f940e30c35c417e6640b01a91a1c7bd7861933e8b1c909cfba3d9c1cd749776ac3f36450fd047e3a8f58a6149a8e5d14c9a17f30dd0aa3a96e74ecb798f69a7e5d7f965dd4cb06e64d76f832f9b5bbe13d87c2f5bbb5d1ec8ed5d5f69ae1fa8a8912171a3dfb3248561b30cb7fc52fccf49f3a65c09e938b971fc005443d2f77e8aca41965876bca4627afe6f2330ac9573e9790f328da15f7d69b534764f569eabb65dc086b84c6a14dd6233c6b7dcdda94d87d0b1d8d08ed8c3446c3ce6c91959fd460e354491421ac6a75a90b2844fba48c489c7774926c2348eeb4bca33d7af328103330eb2c49551ac82fb654842f7159b81914f8245f8d55715c056978631256173e95bfe74cd09f45e57f9bd31acb77497aea5e13b0f07dbcb6bd14bd9681cd1300ce62191e4221b265dd11cddc68ae0b2609e57041438ba0e006fe8619580765091e87d5b7fe8a8d26112a7f5b536f05f80a00ee4c9fea6588e07f11eb6ddf3507f27ff2557d737a9f6142c25b967729ddff7948dc6127c3300bea30eaa629a96ab710864f8367838d63f4f34a821b9cd65ad4a21229ffd9fb96dacb645a30b35b75349adc8e012e398e718ee113e727cec6ed21bef5d3c570208cd3edf865091f03f41cbbfab4dcc86744ffa7a0e11c447f6dde99ea999886b3804597d945b1f702fd82431467329280c3e031e3fcfa7c15438f9d209e857b95f558657f8524f0410a8ed8f91bb32c4bb4433a21ca45cb316eb9446ab7da0b17297056c32dd7969eff675c56f84f88301f19a0c90b41fe5a3fcc109c7fe9c11e867a4390c2c7922daf664be4243134944dfe1c3b248c1070568aed39196682c11a683707b578e730f95198d0e23438d63e1a2ef74605c10c7ac76d6c90aa0ed4a9cd4597858178787dc2aa195e9a1566cc70df18ee039686d00203287b71ee21b7efd34ea48b3bac1c37794d902d6838f8024323581dc217ac190f55d75759da12bc02a44bd15b98e90771de019eae369094086fcab6af79cd4394c2f2b3a78e601d7bca38e36b04042033b918b3e9b741e57001271dfff7a66511e530310c6455cf57be36b127a6ce03c0d3445ee4512bf58da0c02ff29d6bae72cfecd10d4f8f5d7e5f4501912d217cb561aae0850a19b7cc21b6420b43cc6aff2cc33cf7fb3ae0f7f2ebe29d6a5cb6a6cbfd8da0e49de082b4ad81a28c7cf4c9053d9dc6e502153d671db718f307176aab7285e175ca8286896baa0a01981fb1e9f663f5c7f819226f690e366da6a4b1998df2315fae34360a5b2fbf3a3731122073ea4cab29e2c96692b16ff17086deed30a7ad799453b2bacc8692b9fed851c568bb16a91cda0b998dbb6ec7b0c0e5c050b6d37a5429558eed59cce569535ea61a9f8768c49adcc0fb9050c7102080717ca59c3f94c620a588bcaafdae834a4f19b6452dbba37f8768d245300ec374cac4a6cbf0e8392c61ce7c0ddf27a8d807e9eeb6c02143725bb4a55ca6097998c783fea9a43e8a57365b1c73dd771af3f1f6dcdf3ea5f4129e179424a14c71814b52ab33cbc9223b789ffba61dd78302eaf703ad53025516fdd15a6b41042b5764189583978db45097a7cee35dc456c4070cad52ec01bfb3995f8cfc5cc3ab06ee87e16140df28481943ec5697fc8fa48330e37b5edee4bbae3a0cc3899cb81eff686b3f17199af9d8e9c9b93c7c047ab502b0868cea47aeef63df6ff05d6e0485437b518bf0ae4a66ce3aac79883df0197b2c7d13268440d65487f1f21ef4ddd44a3c99fc50b99b20bb64413f67bdcf4a24d8716c631957e7c7aadf30ba489553e80e3090708e0537140d28196e1a57243867201682021d1dee80fd1135df858bf76cc721a066ba27d200488c1023638bdb481ce7d54040414a01f703e829ee9a1e017f1a51c458944a74d2b15bf7638995c6ca85e46f7d817471b9e29a4fdb7a954f394044855252cb99173bb8bf95be0bd5f00b9ee38bb382da6b4bf18ff68109c792411c50ed66ced7e5ff9b07a2d0b5bde487b01d92a2c3a4a5cae2d4beada4d4692d33687a2f61a2d085628940b14406db520ee9ec0467c33ceb24e950beb741ad4281d3a0dbfc70bbff4e72ab074579eaa47a0de6579d73506984c84fcc8a9dcafc434850e0086f9e4225f6d90e9629f0e0a93159aecb46bdaa336667170a4f2f534447bb7f15ea4229f913b6dd437d34402e24aa066a9b43cf5b0f5b3219668d09c232583cb92606c519826297b3f6fad1a0ae8683dfeba967f540754abca5c2046e89efaa1eb3ff2620cc621c83668954c63aca0f3ae2f0bd205ad183f6f96a0f12d9faa8299de2863f1c4982775b943f5636ccbc8c9738a67c87e95b203c54748e30f6be8b9c69a326687282a685c0837518f84cd39f336b96a8424ea2849826966f880c79a2f3c0d3020169a91394cdc6405e4c510300de6976865d48ea3d1b29fd003ac3ce17aa05e90f6da16632417ec0c17052ea7bda512f8ca4a63be91bb5d73d623405819e5bb3679e4ef32e0106f841d52fcb76753aa4798b911e477b5b22ba01501cd267cd733495dd8c50f5217640c60a3c52b0d7c2a76c9a484bdf2d20152817bfd6e39ae642b709569d29d8cbe791ad87a46e4113a0c8c2e0baeffc8cc72e28539b3bfd1bb76d71546e67bd9a587f87ed18c1c46651a384c35210295d728e062f85093541835b5873a012ca1694c71bea08ba5c3f36dc3f6d4f7ce94f3ec2b5a1d416ea05dd2a682e3fc39b94cab690d48a3d85c02a07fe85a8362ce9209dfc136071f408dc975feadadc8b29606ab557b2c75c8b467792b8f69e3a8cd6004b877065e44fe4a90993d7f4ec5de1dcaa9d052fe33aa2735ae2511226f312cfa373e62827bf5215bcc8996181bb0ede22b388ee79fc049ed0ec8dcb1aa0e9ad2a8bfbbbcc643faa306aac4d07077124e9859d364b9ff584c9f9dc65857efba03b396a4377c73283fa70788bd9105cdcdf0e41523a578bb9ab4a11fd2191ba899e2abebe5c67aa553eddca7b5e4f773f07a73a4e24b007ba4f79820a9d1ce386b9b572ce11ce7e8d13f00127494992ab0a2ad7b1ec7d3d5d39e5f578fc024a5d6fdc65b3162a52b9aeb1c38ba9cbf5735a37eb7b4801314c7ed9681884927d663c44d554601ac208fe57b1f597315abcc7c5b4e06805c5e71db6baec1a9a1b4df244c0ba420d800147ef8df7aa47d3f7daf73bb68d9da52efffad1de350159150a51153710829343f5703fed32b13eb407bf0df61bd188ba8d2857979cd308906243a95ae2d5fce32aab8160a91bb3398c4b460b72ad3854bfbc4da8a289e72db1170a3aac31bf9375a4b8388f5c7223238b0241bf46166dfb2212760c493cef462519bc46eb21ccb3393bebcfe6c528390f1c725d730d172512e886e7ffcc8d4c85b7ac5add3ac60dbbaa7badd0b38c78adefb133f23e3b8aa4b1d6552b58802c1eda63a011a5452d0243f02f7668c46f6601cc93ff92bf5bf4a98622c33e160eb297d49c53b35d2a4a7e46f72ccef830eb91fd2f074a9e571dfd11f128eff2911fbe3f5636eff154eef0337e77d79eb72945d8fbd96f79f4d5cae335781516f67a74ef6701b94ddd3bae6f2ae5a6a207a86716ca55a3e1154e5ae41eb11e00569c1300a4a2e86ebf4c021e2aa786b19219daa0e740c9323d5becebe359983f6cc7f170291f2078c829b2e690f30b54fd49b0babf524be7001818e929d13b346196d7d3254568e6f50efd334b7080d1e963ced6aec580778c9c6e2419f1813fb57571f208e8a8b693f64c776053c00d4e221572ea2210bd99b7111f80ab05c41941e03ff9eee830313c5f6df69902894d6a6295ee465d93fb1847867b8e5f2ef4ba6e74a184fe6ae4c0337272a892a3201589601be4251fc449097f0fdd5bd87802667e5ac9635e60b7ac5b744e7582b19784b46f53702a3849b55a4f8d3ef65e93e9f29429242f9a86c29d0592ce8810c3945eb4e7f2d0ac890d60671e422af738df85f87e6861dd882dcaf15ad29e2c4b9151309864c0a19ed0f9fbf3c65a89cf36e37cce1e089d230dd520e8812751e0c5cca8185a24d3085147a9f485bb5ec9e8d987842952dc552ff6ea9265b6f922e4ed00958c435de5016abfd32f4c7a3394e4db1ce3fb53471d6439b7656dacb89b13228515c043220703bbe4533fda613e099417f1cfb8f082632516d76e84ded0d3f5155526b0ea965b8dbfe36da85380c95334a19fd74174ef94433503adfafd0254abdea4ae2b4e1f41f4d8064af12bf63cd35b023426f9797a68aa7b744140f901f153512927d50ac2aa7d1761981122494e4dff648f1b01b2fee947007c50cfd8465ae3024c86aa368632c3805998f5209026ca37b88d51bb8cc7be32b03488ded2255b7b504b44823a79b4042828c31b3460645cb7c9a2fb08e07f809d9b85887df4f3a7c507af1ee3661f07fe5750ed8c948b41132102958b40d760a43b13d85a35229947a09c6e965f97b98df793fef5cc87a60ade99c8f4ee2a4f04495afa7893b2765709fb3e357f3a57495a3424ea910bbae8597a1599fef414f64212bfff188ff2800bfeacc42c7d22e09116f72fc7ce97fcf2c2a25a5d25ba827dec846aff9386fdcb64512e7931890a27b7f9365c5f89a3c686ad27657ce2f697dc174669d4d0ba01a06e33d6e7d9c8ed909a43ef39523cdf9878fd30e4cd183545033fcc2d7cda41b56a5a66ea6c9a558d49044a6b9812cca775c5da6cb81e9d702eaf23c1f265c657e53452ec1189a8af6b7fcd258d21b036fd8abeef7757c95ed89c6378b31f700b97df0a241f84ef6527dd4d2fcd1497b0b1367ca5a30545c46e3398042dd2c1910f88bbb634a6395cacdb12deda42e6d6735d6b5df8a1f0a33c6ece8a530679d4e426d41ad1c7fed225fc727e831bb614322dbd159a7f1a47b5071bc1e46b0663e0c72d02bed011d80581c95a74fdbf8ba3d1aaf891ba9ecf1ce3aab9a53ea1a7684654341669decb9f1f6defe6c4697ddff669c350c0adfbbfaadaa8e7cfde83d50ad84069b55663b09857da642e76aefc847fdd95870a1cb6f8382e76bda8dc29a9bf8e1677060c7a66eabfeb56330e63d73b5088956660808a89444e321c3681b292c3cc918ee6aa47784090a5c42e958731ad8043718483de43ed024be78113191184c7108b345a3b14016b02abd1f5be00b171611d032b4ae9049ac00a67fb48d0e472ca39366cc962a4157f98ecaec72233bda70396d906ae7e8454ed22d56674de1caf324c3c0fc0fa013cc53b0a73bb0e6369e34c114aedd348df0050104625fa9d7a0fe892f92270ef1ca912d42861cd4399229886d6789310b6b435bdd8ceff9e9af8ffa914917872e088a3077626d64e16ae2402629dc430fc52f7ff5e94c639b719ae206e1fa20f4d6a74d0fa4f3fdf6b87c3af4ee6ebf83429640c55ddd19b5d9990ab2009d130dc7557ace80e2e16f07a7892c947c490167c1713768f7b362a3d04a87b33d3301865cdede19526cab80852eed71c63d9d93c7c098bb348d1f41209d57d59bbe7de5179561dd733fd2e7be83467cfac47fdbc8ddde4a9a2e171cd696c6adfd53a69949e3014587313ab911117d0d3ac0b90ee1d7865bd14a4c454ce6fe993b632352dba73a2a6485e8367807ae6b3a989c7196417eb9c7713f7a848bdab8d944106600b8a5593f80aff549c320b8523c157cd92e304675dc0a085b56782c281bbdbea91c2b2f865bb012eb124354ca19915f44abbd2a9915771112abf237337ffbed36165216a8362dabb52b3437ee34eb510dea5eb88354dffbf3c841956364c16d6002aa80db3263b42d29159516648d7afae0f0ac24eca89f9d4c80da1a7c058738f9712b7f8ebc5aaefadd24ad767d9d54f398d0765d7943d6c5b01e6d473892fc26073c30cd5436d5619aad5fdb92ba68f725a148c7e9c76102d3ef32b54393ecdd3027b7213a22c8ed42bc1a91e203fea68349e87a0f7cb1ad25db2fc43f5d7e7fa1b637077b03e71d4da3718ceab659aff7e2445d7b814aae2c03c96db0d86172c49845961887bee11a21ca61867483a6a6b9f32ecdb46edd9b3c9bfd27b0b009d532b60751c77cf3c5d57268d1281392ecb1f283d8bc4817b85dd9b40a85c78b0cbc2aa83884ac4d29717a91ba05a68fb8d197cd7c23b18803ab9ab45a6c5cc7b2838263c62d27bc372567ee2d77eca3c2c23b24135c5725dd5ac80c67780bbb3e584c8c8dfb071de9c9304ad856ccc4f0e3d30cffa294b98b0c0bfce6c6216b433e418c60f6493602428f86653acadad19b80171071d4a74d9684ea8598cbf73bad94ee2f3b1d9a940dc818603cd6a1e897688a93acbbfc5f7af87841f0702c5cfcca42c9891ae628e245ba69e592987ec006b2dd76a022968d27099c5e829412a17b68819a156a33cf81127c61c26613b06462f17d3d011b00f8f76f1f1a3f4f82d4105f6e925bea2dca03858950bfcf3a755cc5708984bc5eb0a87f2479689b4454208ee65c6798b98b03b276714cb70800c657ebecf4531fa1f4a0dcd4879cddd905bb540d4262eade4b8de5ec465edf1f5db34a7b15056296c5e9234d5d8d03961346e9b1f87ed4e21c7e319aeeca45e99ea4a744210d499462df765a25a6e5e938295b3accb848e22fb7a093efaa0e8ddde53c50ad7c315e6fd6b43aa88da2534a88cc1cbed7b3ea2923c2441f111cf89571ed02169c3d57c030e0a32bddd6977bf6cca0117c01895f1d13acc3dbc70bfba6204e66c7d7df6f7f3f96d0249b7b03b32dde25112207b890d29041d97730f52aecbd94ef2219e45835427cee03b78e39fc451021b71221f0f880c0e698c4180fbd623dfadcc41d153bcaca6a6d26b51a1f5d46d9d10085f7edadf0bbbb77a0baced1c8d43e90cdd74fefdfbdfc6949d8b39c53ae1ca49dbdacb78ed889252eadb02bbfac2248fa5d9d02b5d8ebae29f6ec53ded1c4ce48b1cb12adc9ae7ea820a9ac88e14e11ea51f8af1128d403110ee02a0c7959acf377ac515c8d5cf60ebc4172485d3b2bb6bd92c9c78ee3873e85b9f5f4ff3635b079d429da7e7e4961d54f328ab0eb0b5c92b9abd9f883fdc192007020ef5fa09090e98bee8d00816775c2f94d83d346119d01ea8e73fc75ffb638dc68a49a08b1a1f17d3b20e1b2173306ed48c7c457e60082cf782160728a4f322935354783d5a9feade338523169b8eaa08056f559495dad2200de30abc167dfb4f1a137fb15b31a177da2662aa5cc843304c180540a7e0318b4fb6d25539cec3ffd9baaf8578624410a9b5ba80e21e41b9acb3c82dc2c2876998ed698994108b6d5076f7f29d563b92c46e69f6a866755d98b11322bcd2d2b8075006d4f94a323f448c82e30b51590792e453b23032b8883b5612441d3b1d745def61f05e69dc1e7dd5d492e72bcad8a247939cf18df7a68bc3d2b3d31af80baa44b4c539f321de35818a08d67e544f0221e4965cd1d7e6755b66a000cc998614c352b07f207c129d39219294dbfd97f39bd9216869ab9a44aba35da2f7b0d9759e41fefb46e56496f28443a6700914014ed24a62a3c4b223ce287026147450d88d771e6cb6334e3782b3452011b3e5193f98ee137b79cee83e9401a39f3fe71e556b35e67b526befa148af1991e0bcf575e1932e6fb56ea9ec32ead06fa5d200143e68923584172a02601b423af34bd1627710ccebb15025f6c3e309e31afddc149b27936fe667c649a6b49a5dd81bada8d5596b28d1fdf258198f534aea1148b3806f85a6e8607661adaeadf409c5625fda79998fd6d5a84f66e53040eec5a50093f7e8bb9c1db3d1d2231bdbbc1ece52a63b35fb2632dc7d69dca74cac4cbc6cf87d43474e6f0e091fb062ac058a77fd6037aed61714193a33d28333c9433bb15d6379fc6abe7dab6ff02e07f8a334bb8cea5fbcdd1eb6773f388cf0685110d5261de7103baefa39fac7e591136db26a0b7dba61d5da155f84614c68a369df17f6c97acb96ab4cd8949413e882492aa17deab76f01b38a0d8e3e5d3f0a41d7fb309d53a6fc24dca7713655f43c82c776db6bf7f49f9e11027bf47010cce67f7b4532aa1d4bad87d724b2fbf694b3aedd54c2e85c307c6a9d019345bfe703ab890a92235e6a68768ec2b76180e9930f502fff99e5d86ed30ffd586a73c071844377df4980595de976f740fad200277f9c7f91c4903cfa5ec0fae9744017f3fbfe1840b10e200a0322c1b97c671cdb5edf39ad743bb9ca1777b3a9b05bbbea8c57701cce098d94e3458bb8d25a1902230e6846aa1de9f32fdeb494340e9090338a08ef3a220a205a19855d47c8181ac93ed134778ab912ef4f5b0d72bcdc2ca92ec3e89a78dc2bbb980f82a587ed83719408a057af98b9828170f24ba05e548e271c86e363ffcb3bad6d9c4174dab509d7fe0f9db96c55c5318f45559b25a2e21aa818307c888dfa831f46af34fb52cc3d3fc99488fd3581dabb7783ecce2ef5000a2d17a64c017729e4fb9745c8392dcb626e8ba37f233ebde357344c0aaf4375f98b2e89b21a1fd4474a2d1f94964c4cbf3db308f7a52383c3da9e2ae568880b0f959fcf11dc550350efbacb944b1a427bc72c8d201a0e58df53dbd55f7716bed1f84f858605e3839c11051675d843cff92d91855414d89b80769ef79260f5ebe1a0308af174f0ae295a7096c04081da4576e381377b60546a00d2fbc7f7e0d9e9ba3b3226338aeb74ab1ea5bfddc2f5d6b25c82031f49d20780be6cd41068bf01b3ad4a81524ed10f6f89ceb4a83188f642961cfad3fe692101bed23e4223064ed92aa4689fa8a5b5f5268c24cb6ca2d68670b75e03adba192531b69ff5011cbcb00553d28e6bfde7ed4d09f21b02e1e987471245803efff972735ec55aa7a0b7bd405b905fa5c815d9d5a71e234025d9acacc3b4ce1336eedb41ae5f051d53a0e6b3a09920b8ac021e7f3524fcb0dbd7c85dcfe85dcbb9130660b8ef69bbc242860a319c04c601691362dbd950f4110eda810b7b47b7b388b859b1b46af68399db008ebb2b7779b76b503fb873e8b2c80999110ea45d1ba471bdf136a65856b1cd2981c9670b1c43daa8d5fcfcc52e9487b536da8e04df253b0212e04c1a1dd4e15c067fe7039c453950b4e49995727d278d47811a778b118b732b679c7b4c414af2571feeb2b7fdd140acff76537a083a204e4bc708359eba83aa1fad958e29a2c22bb961e82de944e8226a202f2e359d6012b48dc3f198ae499ac52b866bbaf5f794c1a91d5cef31446870ab85709509d7f5861d0e79ed349a41b4c1ff1cb101751d9a9e055e1f272e0f8c78b4265494d83a4afbe33699f2e2da0f31bdc7f8fe897a86831f5beccade71aa9bbbbb1fb81d1df8e8e30ca5084bac2f565c44e1dc586ff8536436df140b6098367efea193161a6e5b83c28ee7a98863ae742f91f967f68cd4c7e8760cdd3412920cb393ed41a668f30debcb4756c95fee51c7853af2a9641587ecbe12d8540b80f54410896a4bdc49839b9c6d8781e26d8e032a340117f346c0d463a092267e70a15afc5855672ed49f60335d2aae960ef53b3f3cf9951db78fc7416e414f22f49075fef0d000c48681248908000768013518c9496dbd631f759dfd7f460b5750beca5bdaec338626b0abe48e1b8b33d59c1a2f2929aea93aa531ff196eaf80cb383c2d5f5076c9658a8e6f7117d9b1f1646587ecc758436e0bd8047f0bbb6e4ff8f77316cff4fd9d02ace5906f691eabc5e80f2588b54750530080ea66ff6a64ed850c1d4e7d5936477ca0599c7c76c33bb567d60a8a42cb1fe46437eab629a7374624eacf6dc54829bffc68b0bde26cbb5d20cecd5b8891ca966977b1e541c32e69324ed855f0dccfb643ae1f85e7976f7627b379869f2f4320496f31fea43f4f30572c935bf52f88e6ee3c6922515266f0ecfdefa68c8ec90574b32520e708a0c87ffecfbe0ecefb46a3e4138c894c843f09af7be04ba4f7652318dd266dcf67a346fa39a08cda45c4af2323d9bbd76dcc485b390630754459d4a0f3f4242dcfeb5a746207f0ca334e464361745b89a2827099be62300a533241eee3a709d6c040e7b7db3aba6bfb6d720611a19d037afbbd13dc764577fcd43d2f0f7d02c2cca44b748f2fdf5acfce450a77fbfbca3742c9d8f59ab8d689f3b7be0726a62121919169154bdeb8f2fd79609ad5c2729701863d6f5451fbe14889c110b72a12557d73944ebf0d0d69ba537ae4d2044a1480a876d80bc63a7fef73a0c73802135a93f5fa9ad0dbef47f74c7c4626b925fd4c12e258c60f2c01528a897b235b292a222d7f205ff76abbf9272205b517267cf530b130e37ea92f1fb8a5923c62f1fa79e6a83fb56ba9e304215632296e063949ca6b960c7b3eec262875adcfce3ecdd6e454238e35445d176068739f3f5039f5c269c9cce916a710e96c51a1b7b9f648a6bb20ee2dcb0c76f4a6bc8f00cb29c8a499556fdbed0c336ee8e78387130c8a40279d66f5d05186a4453c8fdba692864a9c39a3d1ae731e2920cf5ba45cdd452d7323c60d1d8b28354d5e2d9a207f9e07f3125bc7e579570275010176047cdc0cbc3dc9d974067d118eec778c9cb7c02854ee57621e141c16b303b5db426656e5c6685a83af630de1cc0347032a00e6a70ab831875a5698372ebebe74d2cae2ad18fbb65dce44831d190a6690ecf73287d0a7a3f726eac89f536c4222d9f67fa89443b79a992a683c2190f465e7e83a9bb5ff8b2e33aabdec4ffefc67f81ced285c80280e5a0aec7f013074b20bd228083c52a94442aac0eaa331d94e7e90a9670942b60aa5a09c5cbcbb86ec142a36cc3bf1bcf4af3dc468fed690c552235a9246e66f568f7f54afcae1d3f7806dcca98c00d25d5b625678238373704fd68ff0c9e852993234ab685176986042ef890a6be9d5b14f5604092c75a5682fa2e75218e39c9f41ef11ac4e56d80ed62c2d4e30b2965bb168f5b45d25ded2cdb3bdff1e8632614abef9b4c1d075d2b349662a5bb30961803dc18d881f8c792c1b17d6f97f61620b094e22bf48674badd8c97185fbba0df5954f8ef3ec9cdfa8ab0ed8673dc778a2e1ac20c9d0b9939667ed744ad62bdccd9bac7fdedb728faceca70c487b3c80cd30d75b2e52cb34f47ce2f3ad3525846b98a8bfdff467c3a826e8ce7ca04bb68c32194dd801fbef5889c68405bb29b16af258433e206b9830ddc454fc6275dc101ae5c07441268be9e13c610b0cf59ff728290cba6f5d581a24c519f61acc927409684ffde2d9b35c7df4ad6ddbaa6177348050c58c9734c701b81c8a60b2912406a10af1e9a79c58135d7800f52b18b995b83328559384c1472754ac7317dd21a6ab2a984ca588de6a4347cc7fd4b141f1e6aa338195498a8961cb500c5f322d002987b911befc2caa92ec6fc9992575caf2840da8ced481656d88522c7515a118bba959ff43ad54f898867cbdbaac16aa95ee83304efa1777384085449f4e15ea6ed129d9053e2c373b3f4047815fa926dcea0fd4d567d10037c01c2d885bb73d57b827d9968e5d769840d06b5ab7fdbc899556e25edb74de266763d1c0c05b5e617fa81a87fec2b9fd6389ec24d8efff7ce3f05625449403577eed9a4da83390ec1160d7f1c34a8611dfe99ca7e9feec40ac9edb1e030d1f344f6781e672e6d6f20989a115ab3ff993fcb85319326d436f48bb746e369e9d40ba87b74fa418aa536440ceb280d5955842888fc115f8b30705d13bdcbbd2bfeafd9ac2a8140c32059fc4019bdaf9a9196d796c0a2bdb9138cce65432bbb913da6a5918080ade6952dd793dc00edf21dd6774dd00b68ca7e6c53674c3d412790d59b41389346b19df4401d559bf03fe89763565e728e73a1790cb2e58dabde55fd8164d7e330d643b2b97408d7ede9b3ab31075a3d0cb456a4c5b4b218099b12bfcb9b62d565f43047b66a634dee16a8122b05a6d51f44c1118b4bb11e9e5f23db336d1d6874aaf6bb57b8a16f1e6bcf0e63e86b684ff7db76f0b9a8bf1efd5d88234d3b60e6e3f0c485c9ea146f798cc4c539d8cb5bb77d1385686599b3368189e3906a363ff82efbb524d320758757403440f85e61221d4c03ad0ef7d0618605a2a3ce66425680b9ed5f243299cecaa1d9d828cf4152dce9df8d84faa30af0664dbb8b5ed58aef89aabe2a5e1734ec7dc28f0bb5111474c96ce21d99f405206459f9ab963ffcb6caa86add723dca39849ddd6fc9d3e9cbd2d6bc0eadd21c341b552d4a2da938d0bd3eece54609f60685cea5b9b5735d79a990a5b39c15d6fcdb27d2e3de0a99d949b31f53742070f2c256de9d1c00321c5d92dc51309dbb121811d330e8e6a11273acee59193644f6f834c7eaada3d593f2d8b5b5e90444e559af29b08700a9375360db2813bc012828273eba880c54293879bab58e46061ec1f1673edb8f0aaf48b41bcbbd807ddc8463d19d473f002ee8ea942f68632deb16bb40eea3b59bf9bf88cab6803b4e3f0ed40134537a67d82b34c090b950cc7518af04445d1c3f9246313cfdca6c69728bb8feeb4340ae797ce2701d97ecb96e0c54f296cb6c15934ac3b2691cafc5443d6425e0632fbecbaedccda875205920231978fca849dabdfad61710ba1add044aceac841ade1b5d52b7490182c2ea00e01e2a01bc1b94c2464da98ba77f1e5e296955c3443c230536b8bc834f332367c6fe1e7cb92b1c6d0870d328217ec4a939a178a34e34d20e08d6dee676c18cade64de361906d69889bbe81ef39d44c8f894001f51c064ef3b12d9509086b3860cd0dd585bb5c0797092d7e545105af0e27f636025892fea364e4afe274bb3800925fc2c7d493f44c87ce12f2624cc82d8c878487d42fe4c0098321abdc2f41088cad39e8ec759bfca09427de6cb311578ba4d870571676aa3d1ec213187305925965c1b00824aafc7de2df9fb77bd7784110bbe4b454bb14d89e90fe428a2daa72d1a74b7c67464e6a7abc8f0799bf68169d3432cfe7b28e33a4529e51c4781ed4fce6cffec3d4a832cca32f6ded4663e2d956d1233c9c28343cc1cd555c3c4ac1cb5b3817d5f0b557b02bfaa9d1366345c778766c169a0bea74a0a67eb5f80150e9680541d684be6778081511ab52f4d10fbd648abbbd0e1244bb2feb8a870945afd39e61d51a60aa6944830ebfe8e4b5c032b2b7e1738fe04c798769c4cb274b679a90f47628e3a21c916f06a0365997e5a4c539b763a76775c9f2e889973e3e9c747a573ee696125cb9d879bf4e7135efaa0a7307e38f65c7614670f24336d26d47e35f052eaeb745e33b6c4a2721b54915e8082c099b3f4bc39dbf3195b9782abd8265cadec7d36e7feff5a008252d8572baf6a97b0fe7b6c402783fd672ccad1f56f3ffc0e777bb4524e9bb66017c49d848b8e98aeb94ff16c3b6432e04a427827332d2f317afbea7f9ce54a2337d9bf619ec8f716c20d417c08d1f4aa376b32ca5c91c2308046cdd7f1b705dc615ec5df6da677a33ad1f67e95a4859a76d7ac02cc965061a4fdca46548b4b54881b75b4a6f99ecb2ca3298d14a79efd24c4001da7dde208b9888992c17db8bfcda0686ffd9f39d2df175597a54e85856a9b1b627c8283f6bdbcc21d7dcd854659d8c50565696273612d6d3c67a0bcc4d53d27462e414f68dfd38ded1f2ea365af6b5fdc0cdd81bce46b17555f9de329a1a5dc447882fe159faea5b54aa0241a9a6524f5e2269a712d99f3c6ac292ac15d1206877228e2444177106b384cad2b8c818bdb308faec2fa792d17049bae95303e9e3a6c5fc91fa3ea5d186cf19ed3f41693bd52d2490b302d78a063bd2144335712668862eddfafad767d057dbc683f9377e3be5d0c0c45387f0373ec4c1b90f5904e6cfa05af60fee9b3c1de379b9c87d7d31915fcc1984d86d73fc5f11c9a56ceb632251d1b2f857bce82108ae7c746166fdb8ee2c8777e5f6e06d2facba2a069c7995e811b133849c8e78888b28527bd9038f3909081df6c51b54b8417b249dc8d3a2cfe379ea8b878d22fc73fd9c9133845e5603ad5766a5089b5781d70b52b50c813e419c121ef06fd6f181175fadcfce240d510775aba809637d721a1c8234a65732412cde34f2be1ef7a74caf20c4f5d226618e4714d09bc5a7c5d27a0966e999cfa383f7465463b0b7c537b29f756791fb21ea0e2f2b74390796aa19b252bde0e5458757acc582b45e068eb5ac1a7389c0da9e097f37012ffcafed5817b2300c6a1c061db3b2242b6cfbaab9e8792c7db70ccd8854010d5a2cf3ae103d72cb3ce53b378ad5665cfcca256c314db4c7f51a8e2055e407f3db7c46db2c77e26f3cc34fa21c11c00f3ee5e9128e546135a4ddc8320f7970beb7f9af90e4e233e83dbd408a9569c6352e04140cac719165f88c12ad01508c0ec683560b623ecd2ed82ad23a496b7c8a8ed969c9ec423180aca233bf07e9f2694c2f001499c610de53f4683271957eb1ccc348ac16c1a9cc263d43215be52ee80bedb7b9e0b67bda7f8ca919446b444a62cabe0d879dcd90b9b44f1b2e2e5a491ffbf8bf0847e97702f8a1146c1f299ce4092274dce76aa06d420013b9d090de92b3429cca61b794d8bf501b42cf4bb7508f85af4c3cf2ecc58fafc159d2b60fb3d82b707775b892f8d9d59a773c3a985e8354af476e531361142d5aa51604418fb83c9ff0d8692529fca7ead4f51161737a5123bcf4e9ca058bb5116e0c80d2ce64b5c3cadad1d2d2279ce462bfd0272320028ec67995e43c90eb1ccab0d94378d8dde441e2288382221fdf50f24ff1c615ec64b48ca43dd3d63827ca42cf69b6605afb16926e613869e2afee8f29386ab2a12071f1d8f3bc7fbd608023beef49a57fb5fea615c014867f98190bbcc84b0b7f29719f349e2cdd0a59b1891795bc019ea95d1ec654386ec8d58f90bdedd3810cfee23bec8b10b11b696a6a0d515d011d5c5ca8ec0e56c4d7f18660af4b116e173f296573d8a006936db58230a5dbcff894a160ac843a079bf292a75e63838f6c942ba3bef99e6b6900832752dc7e04443513ea92dc455282bcda0982248ab4a4947a077295b522405ec79a2410f2d3b59cdc919b9ed2dbc5a86bd5bedf05ef5be08861c232a5ff7de439549c39f18608795e83fb31cac7504e2f5817fb37a619e01a893971d506a1b9b89de278ffa43bbf4e03373a747b8ef4c719931c15296a434b9c27490bcc7425fd1bc1884ba0c88a25255afbfb9697be106697345c4b85fa7555fc88857d955d5588373fb1755dc14fd4eb0f26dd613c960f355a6570066d826cb4db5a6994693f72d9244a9a6abfb5165d2f6892fabbf5cf15009376aea26b6208c2ffccd2436d5889d2d56cb1cf6fe56e2ffd6a12c51833094d0136698f46d8c280ee0ee8fe73c5f80baf2a11ca3fdcbd5fc872772a50fe77eb30a9b34b148030cfcfeec4c6d32712b4e8a7ebaf412aea24e866cb32c39ac9d47744bc62024789d8796617897c375dbb7d2c443ae11a2b50babb554dd549b329c3b3937cc37bfa76a338e36cc1d01cb707b3dd6c3c7859fd94562cabe26dd90f176dce2d4042126751bf80aae7a9ff692a32afb80eaad1abbcd52f1fec9b7083f2dd8d80ac42336ad365ed0616f68e58f96e79aa7b541205cd39961fcdea29f0fffa00a10e91d0ddcc916a3cda700432238b17325f9d67f9a50688d866e67e7f2428323b6812de1962be431fc043e5f3657c2c281ce23015c846db999e07e4b6f80008f7aa1ff3aee8819a3147c9c768f37041980e6b389e17d2de1aedaf8546b69714798a88cfe5aeb898c5d07f9a945a4fca92ee7da54c9c601421683a95790a1b667c226d550774dcfb0790636acfa419b9f898bb0dad87f82181164f2d44e66a99c238420876191665593dca4487c5ab74c9348ed6dab7242d783800088da479a216fe3b0b2a8ad2f7033ba986fa2facfecde848b554efd489c4fafc8d303468061c85f0f155679f58f102618f40d3202ab5f4e10087e3e3b872b9648fe112b63181d12860173adcdcd519af58786323ad405718856add35dce8a32addf320324c11132a1b7d2ceb0015c2ca2f45d9229819e7212341e29fb65fe1eed9f1f3f3dfd73ed74c68b7a36816e7d1bcf539b107091f9a9f2a76b810ed187aee6b10117d9c91c051ce60f07e5deef215d4ce440d4d942df9cbafb067aef4046ec96939f55357d45be7f7350b67c4c17923a7f8ba69e6483cf61dc5437962fd6ae45fa460c6b5851509bb79210b073fcd615320960e1e412dd712fd4373cb72381325b11b70c1523c422d6b3ba67b3548157747e2c24d352d162273987be4d20863a0d2b2a7ca91e33e24ba1bc12303a6404453dc2fabf5350389b520a58c5dc6c4092c1f514a3636026fa02f22f6b5d35b5a11ff80d955f9482444a4ea5466199bd83112b156f6f3a3046c6e1fdd09a0fc1304d563a1c0c26bdbe71851dfed54ea329a01231613a378352cd1c69470ea9879a32e6473eb49020ebda1f848ad4ffd7bbccb630ef4282a15aeced61eee1a5f4d2f5f76cbfef3e6c96695cb10053bada5f2101183a6d2d32588c7c7313e2dbfe73038f0e1248222b89280a4f3caa5e0bfed588f55cf62bdca094659e8c5bc788eb32270ce4c1a47a19d8ef29882343151e2c5e9d5829ef138cc8ff6ebc6ab48ce7349a3c4ecaa5c26e5ff39270cd0802b6e223f4898bd234848120e46ca14452b61f085b7e665cba3ad74838d5ccdd2c7cd9afc8ab6ddef26cddac1ea6dea75df6ec4fa6d001e457e35a4675f70039dfd056323415f8bd3a525955248b0888cfc915ed2edc9711bcc95593fc409840a2fe39b2902a58fdfc51ebd09e6a779b99b605c7ea9f17e8a58d6b26f0fa4209fedccafbab3e5bb7861a49cc36bd00c254f4bd111a50ee52dcc2aaf47596953d8ac078a55c1957a2cea4c4f8abd30b400f1717f20258f5361efea47c2702fac494e1d1af87d7b9a503f19cbe4b944de2e041f513cf8861af78544694ad27e61cefadce62c50eb6ce4028edbdef4df66d480f5bb7783421b0a6c38485991b32fdb48b23d2e1efd290ab352036cc9478005752bb5a057e21df654e82d3d20f4c50d3b6de680a16f3cd08b38c116ab97c8c5b7df16640bd2b211f7237b8abf73fc629c14f9199306b91cd491d0aafc88d72878f257705ed78ccd45cff1bce2ba62e9ca694b02821e2df2bb6c9b10e8ff23abe61d8f4e72b433cf8fecfcb09e625f59de53543fa98981e8c2c42f40fcb5a69226a5a960c1b906a52a70dd46679077c94a9a2e0709696bd651defb12e34d5435c3d33c14a560962204f1ebfd5b6d18d9af91a5719e3bf36a1a4c253f5bb613f454a874e93a8efb76f3b16f306ee2f4364e284655716bd289488170d72cdd1fd458820a078cdbec2ffcb672f1c668e6fce78edf8d929749274b26a7616a50870b535401eead087929cc20433b763902bcceb64d5794948953191b7650d8a81179b4c15526a083ecf6253d1dfd749e4dc69ee1bd4b7bd3a8861b72b3c8b92d77e3f693b9b0a8874c4f1fa703628090c610afcd8668cc4cb4cf8e736886d576acc94490bad81f0a212d0573682fad4839ee5903188c67f287d3ee8adbeeb66f102689adf8768f326156e757895b124a0d7a0beac4a87bbb6dc5214435754525d8a751952d97f7499ae4b5d7e60bf0421b92df03bf783c8118bef9c3974e88ad9a0443ca277e97134b16160c1c13047f34f461206b581d849599a21d8e8d975d28f4d5a5fa8634170736b6730fa92bbd438e35799fae95653495a29ac02c7a255281e1f2334a60d04af036903b3ca792f9f559192f7aef3a9ac4f71f4a482d2115d09775ee631ba8b4fccb5fd3420e2948b6ad39df2e54d47380000dc15ae7eb505b26ecdde72fdbdb5b794e93dfe80b2e6fa6aaec12cd5a79b3a3a15dbc261470873c7883f37e3a75cbef70c0453f7f871275570ef9c0005bd9cb2a0c39c9d58a7b2604034d3411dc8b7a2b0ef9eb8c581a0b6aeca857b3f9422dead9515b8adc8316dee3b463f3c4ec48ffd15a6297760e04b84843c50943b35e88f5013c60f81a9373292bc43fe5c5f4c9dc1fb2d4d657a0640f8712b698a8fc3a02213c86788f7da18465358aa9d37c10306b8ac5bab610086b3708918afdc8252f3974e6380d6ffdf1549e9ec76cb708101ba2eb2d6b5861d81c58a54575cf484af4b4e59de0ed15a31cda2a6cb0bcb2e0ac680a8c00d5f9581285ec5811b9f414d4c10c46312111dacfcfb63b750cb1d2ab426107948320d15744a9e12056c708dc48a3f6a16bae694cdcc32e4012796ee046cae1262a500df08dec3d3361b0a0c5b3f8e79c2b29b98858987135d6260ebf54e32926c1c02132e2f647ec1a1740cde2511d5fea0a0f493fb4c73e234ea4f52b15a2b803286dba4305fb0d3e14d344585799e6fece5087bf16eab6208b1c80ced21c63d8c532eb083401532539c70962c048fd821a79c6d7b684dfedc25c9dcf1bb03854d0203b60b70ebe6c3daa8a1c3958247226425b448e7a8ca9706312eaec753be0e93d40ee463446711bcc6682ba89469af9ee7043868e987daea6be49df4b451a812288a73f3b419976d4f694e2d981280634b7341932d1e48f11cdfdd0ec6d7b92450f5cd8bae7e4b450e02bc1b2307cab9310ef0d57af78360349677147af6eda4565b2dfe3e62068f5f974190dabd269736291759b27d2b158c54b9ff51b0120a0e1f53fddf93104ae89d8785f4b2e9b8ffef8d65743adc78b4666f81a3e8921989ddb2e36a25affd562ac6e7f63947b36fdca72adc4fae4acaebb9ad6ad9db86d3cf373b54645a3a00f8b4508c7aeb8ed018a69ef761629f2a904cad8b4e002d7e82864b4bc1799348fc338407123a31f05df25bb7add52cf0caa5269179b8260d24f8345f6e48570848f32971ef13d883d19e3f2b466413ec9ffcdf95a223b532d947225619c74689be823eb670779ea845f3e22ebb553a97a0f357b92d53ff8aa2afc38777831f03a58d307014550a908d5f441fd228c10142a0246087a83ca4633374eef627a0b8ea7152a6a2f3a161effa75d71202dc20e9764b35d897113b7068154591633f8e565f95af61411abe9699cce2e221c21e54b377e3e780903c93e7036dfc19a084bf3c0153433afd95901442d51be2573bf2399e6876e93e6fcb2a4bae5430b338e4d884cf86a3558f1fce942b5aaa4c7709fc7cd7280443082691fe2bd0ceecdfceb30d77d9346b3c76d8c5706e4c61fe98e39da2828280e40f538e947cb2669c1cb85cc17d2f2b096109d5680106ab66f21cafc8f7b29486e301fe0aef2c6f7780851d1db9e588854ae486537d6cd72bbb0a9452885058422b8cbcdd835b0eeae36b8992b9ae8f3d9e652aa179404b43153f39fd32b1af0e2c1bfca4ede5ffe3242998ef1bf978e79b16fea331751da2c54efcb80f2472c53b890641eb19435f2da55feac77a889dcc1f3b5312091229fad1468f1ff542b2bb800dcce49ceb4c6d6eaf515fe679908a98822a5dec47cc5d6567922daf18dde2878d0e38da898cef85517aa23780a3d2e232c41a8d5aed21ed3e78e6507a4cbf42a92d91d034177248e1066c1bd4ec4ab2043c04f80be8404144470320fed1951ef4d3ba749099211b56f9b1621bd6df8396b7400ccb0957724505ee886e6d91a7bbdfc8acd328efa5641b1bfe2dd94f25750d9502e347035012e094a4fd2759b00526c2ecf10738398adbc23f2f6c9bc4019cc92e9557dddd3771f4ea18e8aa3793059b2ec03fa18210ee5093d0c4a98a3d288b7f05530651b215184de1ac8bec7804418769794d6210cda51ff34043f7ae3f9a2e4d2ee5d2f4022b743dd56fd2ef6bb43e4d1e2dd4c1c7f729bfc4d460146af9addfe5eb9cffc7401de0d038fc1ff0c3adae2024b0e363804d87045663683cb0be6f76b8206a20c608a190b35b9ea5f5982c2fc48ce779ee639c17100ac8b56783ee6d68bbc85cdc9af0741352566ef6da22af047c770a1594ceb04ce7b25e618a069b0b443d0c1cb5455b2636af0d2b635349b7e07a78fd96016a92163d6db463771f1be176e076210e391b7e52bca89401d85364497da0c120043df0d1a0dd9256500b9453b6ef3089b0aa7593656f36446e4fb4cbb1a56f6044040dc65b98a6a1975fc02e14e0f9979584db19a392e7210a0661409952df9f17f804d5084e64f45bf37688866a3e605cfcb771a95e92a61b924bed07e614cf788d9c01f5929fc023cc096a72d2acf08c36fee23382ac6b7fb40d313640d753cc74f3e2854b40e2d92e6967faa00d76aa3509bd236b840fdd6d751eac37e257794fb03d04b02e9a7fc09dd81e48ffdca4ac20efd3149af79cae3ad69a2bcc7688c41c7b9ac37f55e4a1a6e7870eac4bd5567abb773253c49b582408bfdab41e94fad86334e92c7bcb3c744848a501d3715292b04ca736dd4d78fa2d51c56feabbd9c1ff96ba719e18e1deaec7fd4e928e0e95f55f201bc628e17b39c811ba2af83b25a7764b48cc7623b4c0bbc6e172b775eda9b74a3ab400d01efcc64cb9267d2757619415ae0d3544014254bf1a8ceb059d85807d4dd917d7fb34de86c8617d5da595c98e5449295791b4903d6e7365471f3078577af53199b4c40106856eeef732637108983ba520510edc1d34ed5dc58f3e0c9b5c1454870b8ad6323326db7d334991cbed5d71fcd8f6352871bab7f7a701c8051c577268595d19e5be382077d5b641cef20a587b0447da117e892f83f2a43f0e5b4a52bdf79d335a62c76ab2456c507c8a77a8966ebfecb38c5a09a07d710010f9a499d184572c09b46f1eec6a7b7ed4643e0f980ea6355f0e5e3404b9aa009dc996b592fbf94a0648c5cd56a8144dff823d83d46272193d0fbebed17f07f809f46a86b554b99a415fef6500b3bf4c5cdc5f584abb4d25499c08fc28768d9f827a0d48e548b70feb7633b4e291c0ceaf4081717b0b73cdfc8a87a1a90f3f444cd2f57d2dd5b58e044c0d979a03c77e8f85348b3953d8984f7aca94fcdbc8956747cc86e069a7f1376565604d98e6cdb868b654ca5c80d51782794cae23dbf7618e86fc673e8a05605935c6fff3b8ca29f132d04d05e36384481c035e37d264be00523dafa095f81bd16e404dc9bca669736756ad3b49387fa5af6760d78ea5cf9152ada15c5a50ca9634360126c34e435a70e1f7a10886cd425e2578ee7b0f4323d8d6117968bf4fc4d8eab9bcf5a7334bbc02709b443f0b58772b6467de1b09da24a428cfc5704d7c2f582c05498cacf60ed3953c210591dd061d1614ca20974460a96d6409d3e1ce7259a820ca28cae4cfb1020a6266cb99d1b843da003eee11494cad861801e0e2a7195027ab4d863230a8bb30f2a2943181c122448d748eedfc2bb417ca63abeeaac89e08a0a12503090ca66ffa9b0a603c231941da6c51371fb3ba3e936ea83971af4bbc082711d1930708ae966f2846e7f673849abe4af460d6a250fc97e64f272defceeaa23353e2bff2fe23aaad37bd1cfa2c9db2e68545ed74e3fda1522e7870e60d52fb039a1d6834bd5bb0d142a7547d391d0ef8ab6ecbeea9fdd49ad5c0ae6dd497683c54bccdc878dae386424798ecff4dd4793b4e971dc3b5ad7a8ec4f716394fc3192afee0ea4f13a7547bc91e832e92a1dd82d2a18d1cd5a53b68789563c01bfd78d2d8da124f5c9d9a7a7bf20ae818639d5c840445e214814cdb56783b30fdf427fa619e8dfbc580d51b77206e97ba662c54e235842f2804ec7560e9fd6bdd382148b8951ada1e3ad88b38da1e73ba995324079a4a6287c8be5b4a196f90a06cd0dd859bea9b217a2600929922400364702f9df1423d7ea56386391150c314fd26fe78ece15a3462ef1d2caa0cec5f4d9822c7f39fc2346a80a7dcdaa9a57bad62f6f980f31106ecfa0e9f46c003be66cb383fd4705e5d912d17afecc4ed23dd81f3efb797a9905bfb63dec1a9ba909507cc8425248c323eb0dab2f1f1ff46ad18e48e0b397bd65223efbef2b45cbfa9c9b1cd25fa232ef316b45a8b5c440c949a2ac348e347ebe0d7931f3ff8b93124f7dcc1b97c684cfb8dbd1f725d9828f50d6d52f1014b8b9777dfe94eb6b747bec508b23ced70cdbbe4d0556c7c5562b2b4552567c7eaea5de520a670be85d734a964522a7d8934c3ed4d29b67b0e9488e8b9e8812d30ea2ebc7e6db625e27c17e9cbf247f946b36a2d775e97c8c1958c91f6300d09be6cbdbd5029388284c09f4c4f617321a3bedc7c45be60f019edde662d4aa739a89cd75c1e32c4d6699975650c11e0afdb48bdf4a40de08e3c4a5c644bef25e3d948f5d26738d4fed3a70f601613acdae4e2e4cace7e580a90a49496de05ed4c4b084126910cee30020083f508b0615520c7115b8198b7b3a43f65cb2b1bf46ceda548de80ed14bdf3255a6682078ae724561ed77b168161f5dba1c9f9a6ea805f63179feaa672dc247aa2f33c7d57858a98debe3cccfa9300541a1a23a487bce25b3279aae0ba562f3af80622d0d623ee891528abb3f09dc38271d480a0e3fc48a8f2781f01ef0c091fa7da4fad74b9287015a1bf78b28f0a2e62a7e59c850668b9921f696fe6e2ea4a70d46dcaf5428e4384d864d3e42f2d72f664c223549ce95e695b4a6c8055ca16663faf772fa9201dcce4a978762b1768e67eb9c1ef8fed5d5464a20210f1540f49b609e2ce74c1aec2c752887f2e272cb35ee346a6f3267a09af2a1fe798632a03ad488cc5405f76a184ab4b8231b3481821085ea6218dcbfb19cf7bb190e7ee4f5a046e233b6495eea8feddb43b36eac0045e9eac6e732361f65245c542536c37026060404f1087d9bb2c6643600c0c35bbc877d3867ebd77ef9a085c452d29bc1985af7093febdee39e47375003186645387e5a2aedad65e8304c4bc9d7499d77f3aed35ffb3bee6091998e2218abc32885d3bcd2c152871a8aeeeab3fa57976cf56e08dd5ec117751a9d2e1d02c49a57dadc48258e840bbdcf15e1164dbd1df3a46d65699c6a1c57e37ed84b2da7cc317ab98b4e3b15b2c60f691e9256c4d908c79a91c69ede42bfe398d16f44f3f70550b41c5503bfcd1dbc95158800343e430a46aba0a42f37c29e3ce949e1fdb222044d633eb23d6aeb9fc9df852d850c8b3f655ce72fbddd398d510ebeb51f07c5553dc50fd3ddf9b1534138533f0499de47c6c3275a7bd88580a366f4aedd0575a1728f0eb441bae01149f6bec6f5c8bfde1c91e65d3411301743008c032f29a67621b6c22ce3143a373773c85d10cd9fe8efb2c9e31a98928b6da45ca7cdf968f27734d416009423ae80fd723d23e6c12b2d7a0e4c8f5aef1549dc5eddebe7344734b3e1db3c9033218cc27b94c305d764f222b3dc45af7fdd0f57358d6a867a40fc998bfefc0d766a4e777751f6181106100dbd711255308ef2b52f188f82fbc562ca3da4b6ef14a9173cc4eba219f5194b8748047b938f30a9ff9a4d400d34470e9088bde0ae63ddd602909974fafa084a8eb4cfed158f435c1fdddef6d3c277c609cdaeae8c91e3fa6067376d7d057aa65b38f151c1ea98306b580656048bfd2637284059a0e6b75ba3154b88a958cc0d179a4de65431fc445c3d04060a3451f4f095c92572fd6629fb2a14744ca071ae38efdce994ef8d1a1d1f599da86b41a197dea4e7ad2e431789204fe4275a680fbb1c749f237eed1bd40d9e90217b9f94c205822847f319aba7928679b3fb9f46ec95994b87fcbc1899a4ee4ec2ed5116c890b9185f1899739f5210c411dfec09f85548a6c610d594790f642a002fa93b169dfc5f64d6c3be0b9385d8c3d93ae5ebdf7a8e25ca655c60ef68e23a912213c28aab02d177623d5836f15d38cd0080fad2f125f26d96bba0f368e17449f2be0a71ee26ce153d966d2a0649a8fc88533b46ac92059fc71c9deb755665593ca0e21fb044a8e5c7b905af1aa36896192b53eb3ee18a8bc1fc2d7feb5ab01aea50fd1f00fbb8020642ae4a188c353199d5ffa5e3fc5f1ef7b2f9b783a444ee61e471456ca04eb163ab83d9f4a4f7f28c620aef6e8de04cfae83c67054eaff731f6192ec22564d3b9f8d00503b5496435bbcd6c752745d6db349abf822e7d9a65ca2768ae8f535502bcbe9e2a8eb0f95dcb0475bf65f570b03191221286d13c554b48eb2a07dcab491cc05aa1ec6fee0991cee68eb199fd9c5327b4bf9d1720f5290e87f8c4dd0a49b1c9527876a279098f77b580b5b62dbe3d3c41e47c9f6159045dde62315ae89d25b09676e9be6f17cfc17879391cc1c0d862264a5889af02b51b1e1e20f4d5b34337f0e310cc79e9869a94217a509c3c7701cece20cf58fc1d1162074836b1d40395e45387bd2c32d45eed2827ad84d53f8f8e606efbad72ef9c578ff96eabf06bc1e8eb6c2f98d7c36c07b0781fb1fb9f78758ef4ed21c6d6d9111f033cafa0930cdd65f09be9976c49660dba565e03f65aecdb876d41d661907cd84ec5dfb2290a96c46e07a11dfe329e5361f83a1579fe59d1dfd048df228236b541bf75bf8e2b864157f584a641e59c01394a1a549ad26ed6f6998a7f798ce4128fbdd20b77240f88c163c387f7d9b91920cc9dfd1ca5e9e44d5a262210377e648841009e32512a1af39c13f02817e6e974426ca71b02bc13e65833ebdd88d0b27f571f3eae5cb2e1b7fe9d74bbc77e279f2cfcde3b1dde9e290b86b075429c4c44708f57daeee34ddfad249a5b269fd5330f09f82cf7662ebba17accff6d3b89cdd72f62fb7b85a37a61522999b8161a31bf70282e12075e06f744056df71e890ca1d74187f6fc6c25899dfff57bb9b6e0a3f6769aca4aa59aac3f5cc6aeb67349727091b4936ca6af4d6b1931725cdf1a076b88f103c731ff955dcd9985e719e20fe4dec7462e686bb8b5ed8def02e31199f51c64c5337b0a4d05499cbe3539b3bddbc4c8d5e80e847d340fe96d6db11a5e15737c42537e58c6eecb25f6cfc98988267cb1da91fb95692cf15303ca217f951f2bbd42c3ad0c0aecf6d17d5e7cdd66147e43bb7289f2abe395c96afe91d57dccf8eebf74240dc21d5a23a4c296e21ea64d74e30477677a669659f1752611ee1d87b45fa3fd66eea14f8f064d4ac5aa7e043e5110b75035fa1256592548ff700aebf260765795115e8420b82c582b6d7a9124b0bd0bfe1b0f14346cddd68f4553516ed6c9697a17e3c6ad1cb6861f94f438108e43248a4df1a698a5bbe7aae75994eea5ebd6dc5564eab827dd0684a2d6d490ae90afd1dcf169e876bd19cc2c4ca1d126f5d7e29492031d6dafe591eb7426f4f42a73d64e2f2a4d5af5a7a7b168eb8349955a5b772b9b49b72ff2d157dc99ddf8ad4465966a29086cefc94bdcdc9ce4445a7b925d15f7ed439a5f897321fdff61c0037b12461a95ce3d53876cbdd53d0ffb2a8ce8be4468d03589671adc983a23753fc0ce1677794549667ded2b3eaaf0a83b08e60a472f12304818dbf049365de23b4bd4cb116154b49813c8a125022d3de796267d7163d3d89403b0a1d10c803de64cc1a0bba50963ad2d2e0180cea2ab2bc692ba6e78f34edd972ec5e0a8c951feaa1cf1e62edf8050a02785878b75b990886a324869ef4547e4ccfb259b4b8960dcca7fc42b7d2671a5f60114529a1805a37ecbeb889714c53fa9c399b230a6ee070c9bee405a350d5f2e563a206ca5e83c36b24885298d0f87bd4aba568924b6b4e0497c5e1c81bcfe0f5011add55b61b2d20e1dc499f0115038181ed60c8fc20462dff8c4bffe1f565822ba46267e27d744f28d236914bc62153649146caef049f7669497e7fa49582e33e2c8b6159fa2c0c4039394fc0a40a9c6bed81109dd95e74dd08017a9e1d49577f2499577a930bc966e8524ad004bc4acf17a33df72bd4bf4d4ed6a1901203ea9365f2ea0b95571b2cb6b4f09faac31dd807b8897d1d65a201559e238e907da32038cd5c20f71d17456f4491b674889f6ed595a7a45e157077d05b43f4cb16d9635b5063bcfc5440a2558c68b6616d321454b8c6fcbd65b0efc4e1798b90ba7b89e8ddd118c263fda11bdb33760915b3d6f2955d2c885a4dfb49b74b102f1d04a9fa48b3b20d83ae7cdc8868c8eb177e1f9d8f98ccb6c007f9d56bfa7b9107cb7c6bd6118cc7eb0b930ce90f4438789d9ee4a355760ec0d19a69cbf2c2ddca5b3d5429255af1706f2485b9083f04f33a46288c8412f3abce966b905856bb19cfe4dd75ac0b42bf3c30c2cc7cf391f2734563eb8114085174e9c69ef57ef08de5456c345e94562236d8f9156f2b870a2f49667de6301d56f2f4efec10c4c05eb4e123295dabb9fd7202bc44143317edb45d447ea62f712dba7d76f454f94527f4b1bbac9e7061c1f405fa324a0d589d914126156668442509a6765495be8ff397e7cb2109ca46f40dd866459f32d3f4f6c81cd932cf6ae33bcba8d0ca5acf486c266c47ed04f1c8f8d44827721fcf207b350f2fe18f1c62622d52f9b9f672f15b3c45a1669077fa4c3fc0eaff64e0ab02da7538707c75323a5933de91d7d88b1983747b52b8c4eadaafbd33135a2062a8631992f786b08f05934a0cf157ea55f2e7bfde8f2e2a1eac75cb5565c58721f097fa45adda18f9f54c9f8d09caa6139f7b49cbdc0a7b28ae476716382541a80ab4c096301ad263150f4fb5271d6bb3b2b546b771a6b845ebc75e6d5ad9a1c93d9008c0f408c7e435cb8850b966855df4105c708031997822c29fa443733497cb6f4d933a75ac8b090814d04a7f7b6106e0ac552879cceb535b4afa454900b65a2f174a7fad278194171b649355a613764884477dc90c512d4125a44108c38da400dc4c2887158023a23fd9b93941f12319793911e90d888b439fadb3f7069e5d34ec14a868601656d4182d3a9dab79a0e3d81ae71e11186ab07187eff2a6ec1da18c10c8ad371753766cf52605f447201da0c2998b4dcfa7eea494a16777bdf63cc3288a9d76c26e9ed453c3301e97e9b4dea94fc0dc20843e251af385e187a82d20a2b0306f932fe8af4e5e6c720a6bba391c3af2c296689d5746a958c5078d62cfbc2e06d9f64517b2421781a0cc3fde43e255889af116bde46058f3465d06513d7258b2b7c118790f9c9d97eb0ad9432c76ff75a1fd900fbb67bbe516e352fad259c6b2ed8c88315c4b5614b1000fcbde54a864e12d078c2cb44187f34a2b80a52c1d31d005d17cc54564a880f4831fd97bb9724798df4489f50de84be9f975f8ad6c5f77f35c052dae673756790e27f76fd491bf4d1d9817806c71bd131dda086f0108234475eba2c1e18f255650aa1e8c3ec46f31fbc681804c301df4bb3e2d7aff72f13dc464eafd0f211e28501bf8e96b5bbf6a0f025dda34fd1c5874b7877ac536ee737b08a9f6f9d000b83009456888c99253b34aebd88a9319abc03b122041190499584b4788813f2d46a25108ac53c242e54056ba395ae6b9ca89e289f8e78001971a0131fdd54eda0840820e402292e863bd2a555d8f851fa535ed2e632d0c8bc9b554054e72d7d46a49b89eb1926b1db5455120e471c20ca7cfb58703232f71386c5b68c03f0d45dfccf2d1e062835277f0d4a63f52db91b763b3d5b2a433930a36aeed5b0ac3ab296b4294ef31b4e941fd27c035ccf60813d1b160235a6e697baa583d5f8fc63a0f4525f5b4427713bebd70d82d136b7cfdf13bb48f235d1ed6be64b8236d4473c06bad3829d7b8464eafaca019d65fa55bf6f3e1aef653fc5854d101ee9b9f868f0317f2d1760d917b582ffdbc9559bdf81f0321f698d02fa4bc675692b8fe9e7badb4ab90ed188621ad659572b27a64c81fe46b1ccc18850468b6fb3a2aa42d4bef73a007298324e1dcd9c1bbe89c360a6ff45b96e69564e57e9b58c37e8938e8a5b53cbdba0679dc21d6a295f69aafb6caeb9820becf8de9e4dc1377b01dccc700fb32b443968831d318d698b8eb24f2b682cd58f65bca5de5794654af851993c0a0d518c6730934a56d5f69f110ebcea8b9b633b6c94bef7190eff11de719f574b7b785dd167b3905e705f379760b27fbbc49aa233bd3bc0d542d32bc431dc17244acf9d623e71c93af68a4578e404b017e1784680848a68a26b185899d4dd4ef96398d12c20ae2ac82e0850bb59cd2c23cfd1a63076c3a86d8afcad7fefde507a62b9ae5e1edd6eecdda005246609664df799a9b9f018ad7bb3b819a13e912919b9f73eda0ea9a6aa238dde46011861d2a8ba36d7f2bed5dbb87c003b0d570f1fba260083b9d13c72b2f4463ac95ce251f16687a0b477857bb1967c323feee379cfdfece0893bacd331d5b79e5595b227c2886a4f9b5595e666613098e488d7e5a78a95b94b79a0c004e0442fe551d3cfa002774d4b3ee97ef43be10a6828fa41c7d3866645033a3693ff26e7f827ecdb55fe1ba4bbaa8e3cca25516b9a595a1cb2a0d7e5e6c53daeb2ec05de311433b8a888d446361a3a380ee5badda4fca15d4f2a910f8a45e5b316fd8d05fc32fc907eb2b9b6ea4e9695a407e345edca0c416e2a4cf03e5c02910c6e6dcd353f5d263b36be44190dcd5b35b8be4b04f9c12d96e991e471c429913a4cc57c8b222905bc74af564205ee429427957fdf25e8e20cef520dcd6be9856abded8c01cf7a96a4ca0e104393fbb81a19c1919bad58cbc6e23d1a181aadf43bbf4966254834b111a71fdcb79699a526aec704619f3af30144efcd9176234118916698fdfe0ad980db1b44eb080910d9bb9af68c01b51bf6e35c9bf372ad8b07d3cb01fd730bd4add7b4c0c3cd3786f2970aeba0f2de1ec7d7c0c0ac93d2b01426b66ecad8f0d64b9f4be0db2cd7a4014aa672fafabcd0d9aff72fe37726241082c23dc2a4205cca731c89a8ff5140b17fa0b1ed71d360bb0887aa88e3d2eaa20e640ecd543e92693d5552ae7d34d68bc1ee90211ba4def5d197d2e8f6481ead8fd892709485d448db8d9603db4fa6de25e183772be9b0d86fd6bf93d16afb0027e20b0b4a4634e422e4b0bbe20d8752d70051132c951ddb272a468f2f0ce72bd9cf7eba4feced376a1e8b40f3a523e7160f516d74c9ffeb57977cbb94fe8ea94739fdcbdec46c6201d7e753a4f4fd1a25bb6a6827ee55d341f47d7ae919e91a862b6794309f7d7f9cd6bf5cb4b8eaf252cf80ac752f540ce2e47e794e63d61a9629c68c98e5e1255fe25f6138d1ae866e5cac305c046bb5e8b6531a9f5150944bce7a3cdeb1f5a4a167b32000c6da36cbe9fb57366fbd655cce245a9001a5b4b8492aaf639df75301b1864f4124b8bb18e2b5d85cc5bc19579c0c263e6f5ba597606d2bc83635da274a6944571105289a86382a9cf6677003550706b9cda69ee66e8d872c35f6018750cf0481e5305843885dca22476862732b4c480942f151baee32b3ed2c8d590b961f6ebb0923e14769fa9bb24ce3aaf21e8c5f5db5c81337a2d17bb8c50447367decad8c30fb0f8431e052be2278403f9790ff8bdabee7bb876e74a0b5c9a293083e33d8cf14745ef5ccc898a019945acb46a2bffc47942c79911e18d2501f0c2894a421589e8000456c4528db5eaea9452ccf0a4a51b4f1d7d2849b47a7e9a7a2f07d412b9d7c6d59ccbda02daf53b9c98bdc8a775aa6ef6d39a251e8e8f1da4efc331c7ca59ff8fdcf782fab4d2f7db54df9658a73a65892e419df8487c37eb8722e9f15f02c43b4360fbce1d9c29941f076eb2a85477482de70cb0848cc8b0526178af3d29a4dc1683cff9252d62b5eb8d8d715639a99a63f8ed9c483aa31def80554e6cd37e29c94d84f0894ccfcb77a6b0dcec605345a4ad17adf314ff30bc7552b71866d6f32aa661149a1ec8eacf8b074c8eaea48089e29625c01442310d70db07dddef04a7b6f918c493b73844c63a96598e0c0c1a4afc698602864fc9ee2b120c20b783a250f5a6c22e1293f59e1d47891ce9f921ee03c8820f792866561ca7c0768038d715c5181d802195af78cfba9833908ced9977a8536c5e261d45eecbce0ecc8962e9df721b700d313c264111914da1e345cd7e3924bd003a685777a58562fbb34a5928c3212d48a24187ba884339d8df5f0203f13d6ed8e46a669dc4901419101960bf04cfd301e69fd316b75bff70830fa45af6de8491fa33e5747547120029b5efbb91304667fefc88a027dae2efd063577e9b6842633bab58a7a161d962e9ee0856cd411ebd449fdf3a49210a988465b7ae2eca7582303d318bf18664d485c0716</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">嘻嘻，有密码才能看喔</span>      </label>    </div>  </div></div><script data-pjax src="/Wuhlan3/lib/hbe.js"></script><link href="/Wuhlan3/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
    <tags>
      
      <tag>不务正业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划快速</title>
    <link href="/Wuhlan3/2021/12/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0/"/>
    <url>/Wuhlan3/2021/12/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="最大子数组和系列"><a href="#最大子数组和系列" class="headerlink" title="最大子数组和系列"></a>最大子数组和系列</h2><h4 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子数组和</a></h4><blockquote><p>我觉得这道题目的思想是： 走完这一生 如果我和你在一起会变得更好，那我们就在一起，否则我就丢下你。 我回顾我最光辉的时刻就是和不同人在一起，变得更好的最长连续时刻</p><p>——coolBoy</p></blockquote><p>一切的一切都是从这个演化而来的：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{    <span class="hljs-keyword">int</span> Max = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;n : nums){        pre = max(pre+n, n);        Max = max(Max, pre);    }    <span class="hljs-keyword">return</span> Max;}</code></pre><h4 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h4><p>区别在于，多出一个变量来记录最小的乘积，因为最小的很可能突然变为最大的。</p><h4 id="918-环形子数组的最大和"><a href="#918-环形子数组的最大和" class="headerlink" title="918. 环形子数组的最大和"></a><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和</a></h4><p>非常巧妙，用同样的方法分别记录<strong>最小数组和</strong>和<strong>最大数组和</strong>。假设数组没有回环，那么最大数组就是<code>max_sum</code>；假设数组回环了，就进行<code>total-min_sum</code></p><p>最后，还需要判断一下整个子数组都是负数的情况。</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/1639228731-hwXkOI-image.png" alt="image.png"></p><h4 id="面试题-17-24-最大子矩阵"><a href="#面试题-17-24-最大子矩阵" class="headerlink" title="面试题 17.24. 最大子矩阵"></a><a href="https://leetcode-cn.com/problems/max-submatrix-lcci/">面试题 17.24. 最大子矩阵</a></h4><p>使用<code>top</code>和<code>bottom</code>来遍历不同行数的矩阵。对于每一个固定行数的矩阵，可以采用<strong>前缀和</strong>的方式计算每列的和。之后转化为一维的<strong>最大子数组和</strong>问题。</p><h4 id="363-矩形区域不超过-K-的最大数值和"><a href="#363-矩形区域不超过-K-的最大数值和" class="headerlink" title="363. 矩形区域不超过 K 的最大数值和"></a><a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">363. 矩形区域不超过 K 的最大数值和</a></h4><p>有点困难，之后再细看</p><h2 id="打家劫舍问题"><a href="#打家劫舍问题" class="headerlink" title="打家劫舍问题"></a>打家劫舍问题</h2><h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h4><p>不算特别难，dp[i]设定为到达第i间房子之前能会获得的最大收益。</p><h4 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a></h4><p>在上个问题的基础上，划分为抢第一间房子；不抢第一间房子。</p><h4 id="740-删除并获得点数"><a href="#740-删除并获得点数" class="headerlink" title="740. 删除并获得点数"></a><a href="https://leetcode-cn.com/problems/delete-and-earn/">740. 删除并获得点数</a></h4><p>可以转换为打家劫舍问题</p><h4 id="1388-3n-块披萨"><a href="#1388-3n-块披萨" class="headerlink" title="1388. 3n 块披萨"></a><a href="https://leetcode-cn.com/problems/pizza-with-3n-slices/">1388. 3n 块披萨</a></h4><p>比较麻烦。题意可概括为，求一个3n大小的循环数组中长度为n的不连续子数组的最大和。需要用到打家劫舍II的思想，来处理循环数组问题。</p><p>将<code>dp[i][j]</code>定义为到第i个元素为止，选择j个元素的最大和。</p><h2 id="其他单串dp-i-问题"><a href="#其他单串dp-i-问题" class="headerlink" title="其他单串dp[i]问题"></a>其他单串dp[i]问题</h2><h4 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a></h4><h4 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413. 等差数列划分"></a><a href="https://leetcode-cn.com/problems/arithmetic-slices/">413. 等差数列划分</a></h4><h4 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a></h4><h4 id="132-分割回文串-II"><a href="#132-分割回文串-II" class="headerlink" title="132. 分割回文串 II"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">132. 分割回文串 II</a></h4>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>羊蹄甲</title>
    <link href="/Wuhlan3/2021/12/07/%E7%BE%8A%E8%B9%84%E7%94%B2/"/>
    <url>/Wuhlan3/2021/12/07/%E7%BE%8A%E8%B9%84%E7%94%B2/</url>
    
    <content type="html"><![CDATA[<p></p><center><h3>羊蹄甲</h3></center><center>羊蹄甲，羊蹄甲，</center><center>叶子随风摇曳，</center><center>是一只只活泼的小脚丫。</center><center>花开满树满枝桠，</center><center>不畏严冬，灿若云霞。</center><br><center>紫荆花，紫荆花，</center><center>我的手指在空中比划，</center><center>脑海浮现熟悉的名字，</center><center>我们异口同声地说出“羊蹄甲”。</center><br><center>我们，我们，</center><center>不过是臆想的我们。</center><center>我眼中独家的回忆，</center><center>她眼中《沉默的尬尬》。</center><br><center>羊蹄甲花期全年。</center><center>在管理学院外，</center><center>在饭堂边上，</center><center>在格致园前，</center><center>在贝岗街旁，</center><center>红花、白花、宫粉，</center><center>都骄傲放肆地迎风歌唱。</center><center>我有意去寻找，</center><center>又因他人不能发现而失望。</center><br><center>倒也不必为此悲伤，</center><center>它们为自己而绽放。</center><br><br><p></p>]]></content>
    
    
    
    <tags>
      
      <tag>不务正业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go学习之路</title>
    <link href="/Wuhlan3/2021/10/08/Go%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    <url>/Wuhlan3/2021/10/08/Go%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="零、写在前面"><a href="#零、写在前面" class="headerlink" title="零、写在前面"></a>零、写在前面</h1><p>Go 语言最主要的特性：</p><ul><li>自动垃圾回收</li><li>更丰富的内置类型</li><li>函数多返回值</li><li>错误处理</li><li>匿名函数和闭包</li><li>类型和接口</li><li>并发编程</li><li>反射</li><li>语言交互性</li></ul><p>由于Go和C/C++在最基本的语言方面还是由很多类似的地方的，所以我在学习的时候，对前面的部分仅仅是简单略过。主要抓住该语言最重要的特点，如切片、方法、接口、goroutine、通道等进行深入学习</p><h1 id="一、基础语法篇"><a href="#一、基础语法篇" class="headerlink" title="一、基础语法篇"></a>一、基础语法篇</h1><p>注意，与C不同的是：</p><div class="note note-primary">            <p>花括号{不能单独用于一行</p>          </div><h2 id="行分隔符"><a href="#行分隔符" class="headerlink" title="行分隔符"></a>行分隔符</h2><p>在Go语言中，不需要像<code>;</code>进行语句划分的。</p><pre><code class="hljs go">fmt.Println(<span class="hljs-string">"Hello, World!"</span>)fmt.Println(<span class="hljs-string">"Hello, Wuhlan"</span>)</code></pre><p>当然，如果硬是要写在同一行，可以使用<code>;</code>进行划分，但不推荐</p><pre><code class="hljs go">fmt.Println(<span class="hljs-string">"Hello, World!"</span>);fmt.Println(<span class="hljs-string">"Hello, Wuhlan"</span>)</code></pre><h2 id="变量声明方式"><a href="#变量声明方式" class="headerlink" title="变量声明方式"></a>变量声明方式</h2><h4 id="方法一：指定类型"><a href="#方法一：指定类型" class="headerlink" title="方法一：指定类型"></a>方法一：指定类型</h4><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> identifier <span class="hljs-keyword">type</span></code></pre><p>如：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> num <span class="hljs-keyword">int</span><span class="hljs-keyword">var</span> str <span class="hljs-keyword">string</span></code></pre><p>如果没有初始化，则设为零值</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> num <span class="hljs-keyword">int</span>            <span class="hljs-comment">// 0</span><span class="hljs-keyword">var</span> str <span class="hljs-keyword">string</span>        <span class="hljs-comment">// ""</span><span class="hljs-keyword">var</span> b   <span class="hljs-keyword">bool</span>        <span class="hljs-comment">// false</span></code></pre><p>以下的值，都设为<code>nil</code>，类似于C/C++中的<code>NULL</code></p><pre><code class="hljs go"><span class="hljs-keyword">var</span> a *<span class="hljs-keyword">int</span><span class="hljs-keyword">var</span> a []<span class="hljs-keyword">int</span><span class="hljs-keyword">var</span> a <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>] <span class="hljs-keyword">int</span><span class="hljs-keyword">var</span> a <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span><span class="hljs-keyword">var</span> a <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span><span class="hljs-keyword">var</span> a error <span class="hljs-comment">// error 是接口</span></code></pre><h4 id="方法二：自动判断类型"><a href="#方法二：自动判断类型" class="headerlink" title="方法二：自动判断类型"></a>方法二：自动判断类型</h4><pre><code class="hljs dart"><span class="hljs-keyword">var</span> <span class="hljs-built_in">num</span> = <span class="hljs-number">1</span></code></pre><h4 id="方法三：省略var"><a href="#方法三：省略var" class="headerlink" title="方法三：省略var"></a>方法三：省略var</h4><p>使用<code>:=</code>，这是一个声明语句（左侧如果没有声明新的变量，就产生编译错误）</p><pre><code class="hljs dart"><span class="hljs-keyword">var</span> <span class="hljs-built_in">num</span> <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span><span class="hljs-comment">//相等于</span><span class="hljs-built_in">num</span> := <span class="hljs-number">1</span></code></pre><h2 id="格式化输出字符串"><a href="#格式化输出字符串" class="headerlink" title="格式化输出字符串"></a>格式化输出字符串</h2><ul><li><p>使用<code>Printf</code></p><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">"%d,%s"</span>,<span class="hljs-number">666</span>,<span class="hljs-string">"Wuhlan"</span>)</code></pre></li><li><p>使用<code>Sprintf</code>和<code>Println</code></p><pre><code class="hljs go">    <span class="hljs-keyword">var</span> str = <span class="hljs-string">"%d,%s"</span>      <span class="hljs-keyword">var</span> num <span class="hljs-keyword">int</span> = <span class="hljs-number">666</span>      <span class="hljs-keyword">var</span> name <span class="hljs-keyword">string</span> = <span class="hljs-string">"Wuhlan"</span>      str = fmt.Sprintf(str,num,name)      fmt.Println(str)<span class="hljs-comment">/******************************************/</span><span class="hljs-comment">//也可以这样写</span>    <span class="hljs-keyword">var</span> num <span class="hljs-keyword">int</span> = <span class="hljs-number">666</span>    <span class="hljs-keyword">var</span> name <span class="hljs-keyword">string</span> = <span class="hljs-string">"Wuhlan"</span>    str := fmt.Sprintf(<span class="hljs-string">"%d,%s"</span>, num, name)    fmt.Println(str)</code></pre></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">类型和描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>布尔型</strong> 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>数字类型</strong> 整型 int 和浮点型 float32、float64等，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>字符串类型:</strong> 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>派生类型:</strong> 包括：(a) 指针类型(b) 数组类型(c) 结构化类型(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型(h) Map 类型</td></tr></tbody></table></div><p>Go是一个强类型语言，混合n使用类型是不允许的。比如：</p><pre><code class="hljs c++">package main<span class="hljs-function">func <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{          var defaultName = <span class="hljs-string">"Sam"</span> <span class="hljs-comment">// 允许</span>        type myString <span class="hljs-built_in">string</span>    <span class="hljs-comment">//自定义一个myString类型</span>        var customName myString = <span class="hljs-string">"Sam"</span> <span class="hljs-comment">// 允许</span>        customName = defaultName <span class="hljs-comment">// 不允许</span>}</code></pre><h2 id="并行赋值"><a href="#并行赋值" class="headerlink" title="并行赋值"></a>并行赋值</h2><p>这是一个很有意思的GO语言的特点。</p><p>如果想交换两个变量的值，我相信大部分人第一时间想到的是使用一个临时变量<code>temp</code>作为中介绍。但是go语言并不需要，你可以猜猜下面这段代码会发生什么？</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span><span class="hljs-keyword">var</span> b <span class="hljs-keyword">int</span> = <span class="hljs-number">2</span>a,b = b,afmt.Println(a,b)</code></pre><p>没错，a和b竟然可以直接交换！！！它是通过<strong>并行</strong>的方式交换的，这种方式还常用于函数的返回值中。</p><p>另外，根据GO语言的特点，我们必须使用到所有声明的函数，所以，如果你不想使用某个变量，可以用<code>_</code>来替代</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> _,b = <span class="hljs-number">2</span>,<span class="hljs-number">3</span>fmt.Println(b)</code></pre><h2 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h2><p><code>if-else</code>注意的点如下：</p><ul><li>分支判断条件可以不使用<code>()</code>，当然，也可以使用</li><li>花括号必须与<code>if</code>或<code>else</code>在同一行</li><li>无论有几条条件语句，左右 <code>{}</code>花括号不能省略</li></ul><div class="note note-primary">            <p>GO语言没有三目运算符<code>? :</code></p>          </div><p><code>switch-case</code>注意的点如下：</p><ul><li><p>支持多条件匹配</p><pre><code class="hljs go"><span class="hljs-keyword">switch</span>{   <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>:   <span class="hljs-keyword">default</span>:}</code></pre></li><li><p>不同的 case 之间不使用 break 分隔，默认只会执行一个 case。</p></li><li><p>如果想要执行多个 case，需要使用 fallthrough 关键字，也可用 break 终止。</p><pre><code class="hljs go"><span class="hljs-keyword">switch</span>{    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:    ...    <span class="hljs-keyword">if</span>(...){        <span class="hljs-keyword">break</span>    }    <span class="hljs-keyword">fallthrough</span> <span class="hljs-comment">// 此时switch(1)会执行case1和case2，但是如果满足if条件，则只执行case 1</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:    ...    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:}</code></pre></li><li><p>没有<code>switch</code>的switch，默认<code>switch(true)</code>，这种形式能将一长串<code>if-then-else</code>写得更加清晰。</p></li></ul><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>一般情况注意的点如下：</p><ul><li>初始化语句和后置语句是可选的。比如：<code>for ;i&lt;100;{}</code></li><li>Go中没有while，将for中的<code>;</code>去掉，便相当于while</li><li>无限循环还可以直接省略掉条件，写成<code>for{}</code></li></ul><p><code>for-each range</code>可以对数组和切片进行迭代：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {        strings := []<span class="hljs-keyword">string</span>{<span class="hljs-string">"Wuhlan"</span>, <span class="hljs-string">"miaomiaomiao"</span>}        <span class="hljs-keyword">for</span> i, s := <span class="hljs-keyword">range</span> strings {                fmt.Println(i, s)        }        numbers := [<span class="hljs-number">6</span>]<span class="hljs-keyword">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>}        <span class="hljs-keyword">for</span> i,x:= <span class="hljs-keyword">range</span> numbers {                fmt.Printf(<span class="hljs-string">"第 %d 位 x 的值 = %d\n"</span>, i,x)        }  }</code></pre><p>输出如下：</p><pre><code class="hljs angelscript"><span class="hljs-number">0</span> Wuhlan<span class="hljs-number">1</span> miaomiaomiao第 <span class="hljs-number">0</span> 位 x 的值 = <span class="hljs-number">1</span>第 <span class="hljs-number">1</span> 位 x 的值 = <span class="hljs-number">2</span>第 <span class="hljs-number">2</span> 位 x 的值 = <span class="hljs-number">3</span>第 <span class="hljs-number">3</span> 位 x 的值 = <span class="hljs-number">5</span>第 <span class="hljs-number">4</span> 位 x 的值 = <span class="hljs-number">0</span>第 <span class="hljs-number">5</span> 位 x 的值 = <span class="hljs-number">0</span></code></pre><h2 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h2><p>defer 语句会将函数推迟到外层函数返回之后执行。</p><p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</p><p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {    fmt.Println(<span class="hljs-string">"counting"</span>)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ {        <span class="hljs-keyword">defer</span> fmt.Println(i)    }    fmt.Println(<span class="hljs-string">"done"</span>)}</code></pre><p>输出：</p><pre><code class="hljs go">countingdone<span class="hljs-number">9</span><span class="hljs-number">8</span><span class="hljs-number">7</span><span class="hljs-number">6</span><span class="hljs-number">5</span><span class="hljs-number">4</span><span class="hljs-number">3</span><span class="hljs-number">2</span><span class="hljs-number">1</span><span class="hljs-number">0</span></code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数定义方式：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> 函数名<span class="hljs-params">([参数列表])</span> [返回值列表]</span> {   函数体}</code></pre><h3 id="基本的函数"><a href="#基本的函数" class="headerlink" title="基本的函数"></a>基本的函数</h3><p>一个简单的加法函数：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a,b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {    <span class="hljs-keyword">return</span> a + b}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {    <span class="hljs-keyword">var</span> a = <span class="hljs-number">6</span>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">7</span>        fmt.Println(add(a,b))}</code></pre><h3 id="多返回值函数"><a href="#多返回值函数" class="headerlink" title="多返回值函数"></a>多返回值函数</h3><p>返回多个值的函数（随便写的，写的很爽嘿嘿<span class="github-emoji"><span>😋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a,b <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span></span> {    a,b = b+b,a+a    <span class="hljs-keyword">return</span> a , b}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {    <span class="hljs-keyword">var</span> a = <span class="hljs-number">6</span>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">7</span>        fmt.Println(add(a,b))}</code></pre><p>输出：</p><pre><code class="hljs basic"><span class="hljs-symbol">14 </span><span class="hljs-number">12</span></code></pre><p>有的时候我们可能并不需要多个返回值中的某几个值，可以使用<strong>空白符</strong></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> {    a, b = b+b, a+a    <span class="hljs-keyword">return</span> a, b}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {    <span class="hljs-keyword">var</span> a = <span class="hljs-number">6</span>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">7</span>    c, _ := add(a, b)        <span class="hljs-comment">//使用空白符来接收不想要的值</span>    fmt.Println(c)}</code></pre><h3 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h3><p>从函数中可以返回一个命名值。一旦命名了返回值，可以认为这些值在函数第一行就被声明为变量了。</p><p>我们稍微对上面的例子进行修改：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(ret1, ret2 <span class="hljs-keyword">int</span>)</span></span> {    ret1, ret2 = b+b, a+a    <span class="hljs-keyword">return</span>}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {    <span class="hljs-keyword">var</span> a = <span class="hljs-number">6</span>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">7</span>    fmt.Println(add(a, b))}</code></pre><h1 id="二、进阶语法篇"><a href="#二、进阶语法篇" class="headerlink" title="二、进阶语法篇"></a>二、进阶语法篇</h1><p>其实是基础的太多了，用这个来划分一下。下面的还是很基础喔！</p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="基本编译与运行"><a href="#基本编译与运行" class="headerlink" title="基本编译与运行"></a>基本编译与运行</h3><pre><code class="hljs go"><span class="hljs-comment">// geometry.go</span><span class="hljs-keyword">package</span> main     <span class="hljs-comment">//指定该文件属于main包</span><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span>    <span class="hljs-comment">//导入一个已存在的包</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {      fmt.Println(<span class="hljs-string">"Geometrical shape properties"</span>)}</code></pre><p>在执行<code>go install geometry</code>之后，会在<code>bin</code>文件夹里生成一个<code>geometry.exe</code></p><p>结构如下：</p><pre><code class="hljs css"><span class="hljs-selector-tag">src</span>    <span class="hljs-selector-tag">geometry</span>文件夹        <span class="hljs-selector-tag">gemometry</span><span class="hljs-selector-class">.go</span><span class="hljs-selector-tag">bin</span>    <span class="hljs-selector-tag">geometry</span><span class="hljs-selector-class">.exe</span></code></pre><h3 id="调用自定义包"><a href="#调用自定义包" class="headerlink" title="调用自定义包"></a>调用自定义包</h3><p>文件夹结构如下：</p><pre><code class="hljs maxima">src    geometry        geometry.<span class="hljs-built_in">go</span>        <span class="hljs-built_in">rectangle</span>            rectprops.<span class="hljs-built_in">go</span></code></pre><p>rectprops.go如下：</p><pre><code class="hljs go"><span class="hljs-comment">// rectprops.go</span><span class="hljs-keyword">package</span> rectangle<span class="hljs-keyword">import</span> <span class="hljs-string">"math"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Area</span><span class="hljs-params">(<span class="hljs-built_in">len</span>, wid <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">float64</span></span> {    area := <span class="hljs-built_in">len</span> * wid    <span class="hljs-keyword">return</span> area}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Diagonal</span><span class="hljs-params">(<span class="hljs-built_in">len</span>, wid <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">float64</span></span> {    diagonal := math.Sqrt((<span class="hljs-built_in">len</span> * <span class="hljs-built_in">len</span>) + (wid * wid))    <span class="hljs-keyword">return</span> diagonal}</code></pre><p>可以看到，rectangle包里的函数都是首字母大写的。在Go中，任何以<strong>大写字母</strong>开头的变量或者函数都是<strong>被导出的变量名/函数名</strong>。只有这些名字才可以在main包中进行访问。</p><h3 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h3><p>每一个包里都可以包含一个init函数。是在一个包初始化的时候自动运行的。</p><pre><code class="hljs c++"><span class="hljs-comment">// geometry.go</span>package main<span class="hljs-keyword">import</span> (    <span class="hljs-string">"fmt"</span>    <span class="hljs-string">"geometry/rectangle"</span> <span class="hljs-comment">// 导入自定义包</span>    <span class="hljs-string">"log"</span>)<span class="hljs-comment">/*</span><span class="hljs-comment"> * 1. 包级别变量</span><span class="hljs-comment"> */</span>var rectLen, rectWidth float64 = <span class="hljs-number">6</span>, <span class="hljs-number">7</span><span class="hljs-comment">/*</span><span class="hljs-comment">*2. init 函数会检查长和宽是否大于0</span><span class="hljs-comment"> */</span>func init() {    println(<span class="hljs-string">"main package initialized"</span>)    <span class="hljs-keyword">if</span> rectLen &lt; <span class="hljs-number">0</span> {        <span class="hljs-built_in">log</span>.Fatal(<span class="hljs-string">"length is less than zero"</span>)    }    <span class="hljs-keyword">if</span> rectWidth &lt; <span class="hljs-number">0</span> {        <span class="hljs-built_in">log</span>.Fatal(<span class="hljs-string">"width is less than zero"</span>)    }}func main() {    fmt.Println(<span class="hljs-string">"Geometrical shape properties"</span>)    fmt.Printf(<span class="hljs-string">"area of rectangle %.2f\n"</span>, rectangle.Area(rectLen, rectWidth))    fmt.Printf(<span class="hljs-string">"diagonal of the rectangle %.2f "</span>, rectangle.Diagonal(rectLen, rectWidth))}</code></pre><p>如果将<code>rectLen</code>将改为-6。则会有日志报错：</p><pre><code class="hljs cmd">PS E:\go\src&gt; go run geometry    main package initialized<span class="hljs-number">2021</span>/<span class="hljs-number">10</span>/<span class="hljs-number">09</span> <span class="hljs-number">14</span>:<span class="hljs-number">28</span>:<span class="hljs-number">40</span> length is less than zero<span class="hljs-keyword">exit</span> status <span class="hljs-number">1</span></code></pre><h3 id="导入包而不使用"><a href="#导入包而不使用" class="headerlink" title="导入包而不使用"></a>导入包而不使用</h3><p>一般情况下，导入某个包而不使用它，将会报错。有两种方法可以先导入而暂不使用：</p><p><strong>1.使用错误屏蔽器</strong></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">"geometry/rectangle"</span> )<span class="hljs-keyword">var</span> _ = rectangle.Area <span class="hljs-comment">// 错误屏蔽器</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {}</code></pre><p><strong>2.使用空白标识符</strong></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> (    _ <span class="hljs-string">"geometry/rectangle"</span> )<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {}</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>初始化</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">5</span>]<span class="hljs-keyword">float32</span>{<span class="hljs-number">1000.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">50.0</span>}</code></pre><p>快速初始化数组：</p><pre><code class="hljs go">arr := [<span class="hljs-number">5</span>]<span class="hljs-keyword">float32</span>{<span class="hljs-number">1000.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">50.0</span>}</code></pre><p>长度不确定时：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr = [...]<span class="hljs-keyword">float32</span>{<span class="hljs-number">1000.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">50.0</span>}或arr := [...]<span class="hljs-keyword">float32</span>{<span class="hljs-number">1000.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">50.0</span>}</code></pre><p>使用下标来初始化元素：</p><pre><code class="hljs go">balance := [<span class="hljs-number">5</span>]<span class="hljs-keyword">float32</span>{<span class="hljs-number">1</span>:<span class="hljs-number">2.0</span>,<span class="hljs-number">3</span>:<span class="hljs-number">7.0</span>}</code></pre><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>与C类似，需要注意的有两点：</p><ul><li><code>* int</code>，这是反过来的！！！</li><li>空指针，<code>nil</code></li><li>Go并不支持指针运算。比如说如果p是一个指针，<code>p++</code>是不被允许的。</li></ul><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>Go 语言切片是对数组的抽象。切片本身不拥有任何数据。它们只是对现有数组的引用。</p><p>Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(“动态数组”)，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</p><h3 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h3><ul><li><p>使用未指定大小的数组来定义：<code>var 标识符 []类型</code></p></li><li><p>使用<code>make()</code>函数来创建切片：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> slice1 []<span class="hljs-keyword">int</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>)或slice1 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>)</code></pre></li><li><p>也可以指定容量<code>make([]int, len, capacity)</code></p></li></ul><h3 id="切片初始化"><a href="#切片初始化" class="headerlink" title="切片初始化"></a>切片初始化</h3><pre><code class="hljs go">s := <span class="hljs-keyword">int</span> {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>}                <span class="hljs-comment">//直接初始化切片，[]是切片类型</span>s := arr[:]                        <span class="hljs-comment">//对arr的引用</span>s := arr[startIndex:endIndex]    <span class="hljs-comment">//将 arr 中从下标 startIndex 到 endIndex-1 创建一个新的切片。</span>s := arr[startIndex:] s := arr[:endIndex] s1 := s[startIndex:endIndex]     <span class="hljs-comment">//切片初始化为s1</span>s :=<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>,<span class="hljs-built_in">len</span>,<span class="hljs-built_in">cap</span>)</code></pre><h3 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h3><p><code>len()</code>和<code>cap()</code>可以获取切片的长度和容量</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {    <span class="hljs-keyword">var</span> arr =  []<span class="hljs-keyword">int</span>{<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>}    slice1 := arr[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]    fmt.Println(slice1)    fmt.Println(<span class="hljs-built_in">len</span>(slice1))    fmt.Println(<span class="hljs-built_in">cap</span>(slice1))    <span class="hljs-keyword">var</span> slice2 = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>)    slice2 = arr[<span class="hljs-number">2</span>:<span class="hljs-number">6</span>]    fmt.Println(slice2)    fmt.Println(<span class="hljs-built_in">len</span>(slice2))    fmt.Println(<span class="hljs-built_in">cap</span>(slice2))}</code></pre><p>输出：</p><pre><code class="hljs angelscript">[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]<span class="hljs-number">3</span><span class="hljs-number">7</span>[<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<span class="hljs-number">4</span><span class="hljs-number">6</span></code></pre><p>可以观察一下，cap到底是怎么计算的</p><div class="note note-success">            <p>切片的长度是切片中的元素数。<strong>切片的容量是从创建切片索引开始的底层数组中元素数。</strong></p>          </div><h3 id="切片的扩充和拷贝"><a href="#切片的扩充和拷贝" class="headerlink" title="切片的扩充和拷贝"></a>切片的扩充和拷贝</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {   <span class="hljs-keyword">var</span> numbers []<span class="hljs-keyword">int</span>   printSlice(numbers)   <span class="hljs-comment">// 向切片添加一个元素 </span>   numbers = <span class="hljs-built_in">append</span>(numbers, <span class="hljs-number">0</span>)   printSlice(numbers)   <span class="hljs-comment">// 同时添加多个元素</span>   numbers = <span class="hljs-built_in">append</span>(numbers, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)   printSlice(numbers)   <span class="hljs-comment">//创建切片 numbers1 是之前切片的两倍容量</span>   numbers1 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(numbers), (<span class="hljs-built_in">cap</span>(numbers))*<span class="hljs-number">2</span>)   <span class="hljs-comment">// 拷贝 numbers 的内容到 numbers1</span>   <span class="hljs-built_in">copy</span>(numbers1,numbers)   printSlice(numbers1)  }<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printSlice</span><span class="hljs-params">(x []<span class="hljs-keyword">int</span>)</span></span>{   fmt.Printf(<span class="hljs-string">"len=%d cap=%d slice=%v\n"</span>,<span class="hljs-built_in">len</span>(x),<span class="hljs-built_in">cap</span>(x),x)}</code></pre><p>输出：</p><pre><code class="hljs angelscript">len=<span class="hljs-number">0</span> cap=<span class="hljs-number">0</span> slice=[]len=<span class="hljs-number">1</span> cap=<span class="hljs-number">1</span> slice=[<span class="hljs-number">0</span>]len=<span class="hljs-number">5</span> cap=<span class="hljs-number">6</span> slice=[<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]len=<span class="hljs-number">5</span> cap=<span class="hljs-number">12</span> slice=[<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]</code></pre><h3 id="切片与数组的区别"><a href="#切片与数组的区别" class="headerlink" title="切片与数组的区别"></a>切片与数组的区别</h3><p>切片文法类似于没有长度的数组文法。</p><p>这是一个数组文法：</p><pre><code class="hljs go">[<span class="hljs-number">3</span>]<span class="hljs-keyword">bool</span>{<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>}</code></pre><p>下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：</p><pre><code class="hljs go">[]<span class="hljs-keyword">bool</span>{<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>}</code></pre><ul><li>切片并不存储任何数据，它只是描述了底层数组中的一段。</li><li>更改切片的元素会修改其底层数组中对应的元素。</li><li>与它共享底层数组的切片都会观测到这些修改。</li></ul><p>观察下面的程序，猜猜会发生什么？</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">"fmt"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change</span><span class="hljs-params">(s ...<span class="hljs-keyword">string</span>)</span></span> {    s[<span class="hljs-number">0</span>] = <span class="hljs-string">"Go"</span>    s = <span class="hljs-built_in">append</span>(s, <span class="hljs-string">"playground"</span>)    fmt.Println(s)}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {    welcome := []<span class="hljs-keyword">string</span>{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}    change(welcome...)    fmt.Println(welcome)}</code></pre><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>切片持有对底层数组的引用。只要切片在内存中，数组就不能被垃圾回收。在内存管理方面，这是需要注意的。让我们假设我们有一个非常大的数组，我们只想处理它的一小部分。然后，我们由这个数组创建一个切片，并开始处理切片。这里需要重点注意的是，<strong>在切片引用时数组仍然存在内存中</strong>。</p><p>一种解决方法是使用 copy 函数 <code>func copy(dst，src[]T)int</code> 来生成一个切片的副本。这样我们可以使用新的切片，原始数组可以被<strong>垃圾回收</strong>。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="Map的创建与初始化"><a href="#Map的创建与初始化" class="headerlink" title="Map的创建与初始化"></a>Map的创建与初始化</h3><pre><code class="hljs go"><span class="hljs-comment">/* 声明变量，默认 map 是 nil */</span><span class="hljs-keyword">var</span> map_variable <span class="hljs-keyword">map</span>[key_data_type]value_data_type<span class="hljs-comment">/* 使用 make 函数 */</span>map_variable := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[key_data_type]value_data_type)</code></pre><p>如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对。</p><p>所以必须进行初始化</p><h3 id="使用range迭代"><a href="#使用range迭代" class="headerlink" title="使用range迭代"></a>使用range迭代</h3><p>使用键进行遍历即可</p><h3 id="查看是否Key存在"><a href="#查看是否Key存在" class="headerlink" title="查看是否Key存在"></a>查看是否Key存在</h3><p>可以使用<code>key,ok := mymap[value]</code></p><p>若key存在，则<code>ok == true</code>；否则<code>ok == false</code></p><h3 id="范围Range"><a href="#范围Range" class="headerlink" title="范围Range"></a>范围Range</h3><p>range 可用于迭代数组、切片、通道、集合</p><h3 id="delete-函数"><a href="#delete-函数" class="headerlink" title="delete()函数"></a>delete()函数</h3><pre><code class="hljs go"><span class="hljs-built_in">delete</span>(mymap, Key)</code></pre><h3 id="参考例程"><a href="#参考例程" class="headerlink" title="参考例程"></a>参考例程</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {    <span class="hljs-comment">//创建并初始化</span>    countryCapitalMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>)            countryCapitalMap [ <span class="hljs-string">"France"</span> ] = <span class="hljs-string">"巴黎"</span>    countryCapitalMap [ <span class="hljs-string">"Italy"</span> ] = <span class="hljs-string">"罗马"</span>    countryCapitalMap [ <span class="hljs-string">"Japan"</span> ] = <span class="hljs-string">"东京"</span>    countryCapitalMap [ <span class="hljs-string">"India "</span> ] = <span class="hljs-string">"新德里"</span>    <span class="hljs-comment">//使用range进行遍历</span>    <span class="hljs-keyword">for</span> country := <span class="hljs-keyword">range</span> countryCapitalMap {        fmt.Println(country, <span class="hljs-string">"首都是"</span>, countryCapitalMap [country])    }    <span class="hljs-comment">//可以判断key是否存在</span>    capital, ok := countryCapitalMap [ <span class="hljs-string">"American"</span> ]    <span class="hljs-keyword">if</span> (ok) {        fmt.Println(<span class="hljs-string">"American 的首都是"</span>, capital)    } <span class="hljs-keyword">else</span> {        fmt.Println(<span class="hljs-string">"American 的首都不存在"</span>)    }    <span class="hljs-comment">//删除某个map</span>    <span class="hljs-built_in">delete</span>(countryCapitalMap, <span class="hljs-string">"France"</span>)    fmt.Println()    <span class="hljs-keyword">for</span> country := <span class="hljs-keyword">range</span> countryCapitalMap {        fmt.Println(country, <span class="hljs-string">"首都是"</span>, countryCapitalMap [country])    }}</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><pre><code class="hljs c++">package main<span class="hljs-keyword">import</span> (    <span class="hljs-string">"fmt"</span>)<span class="hljs-function">func <span class="hljs-title">printBytes</span><span class="hljs-params">(s <span class="hljs-built_in">string</span>)</span> </span>{    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>; i &lt; len(s); i++ {        fmt.Printf(<span class="hljs-string">"%x "</span>, s[i])    }}<span class="hljs-function">func <span class="hljs-title">printChars</span><span class="hljs-params">(s <span class="hljs-built_in">string</span>)</span> </span>{    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>; i &lt; len(s); i++ {        fmt.Printf(<span class="hljs-string">"%c "</span>,s[i])    }}<span class="hljs-function">func <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    name = <span class="hljs-string">"Señor"</span>    printBytes(name)    fmt.Printf(<span class="hljs-string">"\n"</span>)    printChars(name)}</code></pre><p>运行结果如下：</p><pre><code class="hljs go"><span class="hljs-number">53</span> <span class="hljs-number">65</span> c3 b1 <span class="hljs-number">6</span>f <span class="hljs-number">72</span>S e Ã ± o r</code></pre><p>可以看到，出现了一个小bug。这是因为<code>ñ</code>在UTF-8中是占用了两个字节的。那么我们该如何获取每一个字符呢？</p><h3 id="rune"><a href="#rune" class="headerlink" title="rune"></a>rune</h3><p>rune 是 Go 语言的内建类型，它也是 int32 的别称。在 Go 语言中，<strong>rune 表示一个代码点</strong>。代码点无论占用多少个字节，都可以用一个 rune 来表示。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">"fmt"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printBytes</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span></span> {    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ {        fmt.Printf(<span class="hljs-string">"%x "</span>, s[i])    }}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printChars</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span></span> {    runes := []<span class="hljs-keyword">rune</span>(s)    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(runes); i++ {        fmt.Printf(<span class="hljs-string">"%c "</span>,runes[i])    }}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {    name := <span class="hljs-string">"Señor"</span>    printBytes(name)    fmt.Printf(<span class="hljs-string">"\n"</span>)    printChars(name)}</code></pre><p>更简单的遍历字符串方法是使用<code>for range</code>：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printCharsAndBytes</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span></span> {    <span class="hljs-keyword">for</span> index, <span class="hljs-keyword">rune</span> := <span class="hljs-keyword">range</span> s {        fmt.Printf(<span class="hljs-string">"%c starts at byte %d\n"</span>, <span class="hljs-keyword">rune</span>, index)    }}</code></pre><h3 id="字符串是不可修改的"><a href="#字符串是不可修改的" class="headerlink" title="字符串是不可修改的"></a>字符串是不可修改的</h3><p>要想修改，需要先将字符串转换为一个rune切片。然后这个切片可以进行任何想要的改变，然后再转化为一个字符串。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">"fmt"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mutate</span><span class="hljs-params">(s []<span class="hljs-keyword">rune</span>)</span> <span class="hljs-title">string</span></span> {      s[<span class="hljs-number">0</span>] = <span class="hljs-string">'a'</span>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(s)}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {      h := <span class="hljs-string">"hello"</span>    fmt.Println(mutate([]<span class="hljs-keyword">rune</span>(h)))}</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go 没有类。不过你可以为结构体类型定义方法。(当然也可以为非结构体类型定义方法)</p><p>方法就是一类带特殊的 <strong>接收者</strong> 参数的函数。</p><p>方法接收者在它自己的参数列表内，位于 <code>func</code> 关键字和方法名之间。</p><p>在此例中，<code>Abs</code> 方法拥有一个名为 <code>v</code>，类型为 <code>Vertex</code> 的接收者。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">"fmt"</span>    <span class="hljs-string">"math"</span>)<span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> {    X, Y <span class="hljs-keyword">float64</span>}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vertex)</span> <span class="hljs-title">Abs</span><span class="hljs-params">()</span> <span class="hljs-title">float64</span></span> {    <span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {    v := Vertex{<span class="hljs-number">3</span>, <span class="hljs-number">4</span>}    fmt.Println(v.Abs())}</code></pre><h3 id="值接收器和指针接收器"><a href="#值接收器和指针接收器" class="headerlink" title="值接收器和指针接收器"></a>值接收器和指针接收器</h3><p>经过测试，我总结了他们的特性：</p><ul><li>无论是值接收器还是指针接收器，既可以使用指向结构体的指针来调用，也可以直接使用结构体来调用。（Go语言或许是想减少我们的错误，两种方法都可以）</li><li>而最终的效果——方法内部的改变对于调用者是否可见，取决于方法是<strong>值接收器</strong>和<strong>指针接收器</strong>，而和调用者没有关系。</li></ul><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">"fmt"</span>)<span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> {    name <span class="hljs-keyword">string</span>    age  <span class="hljs-keyword">int</span>}<span class="hljs-comment">/*</span><span class="hljs-comment">使用值接收器的方法。</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Employee)</span> <span class="hljs-title">changeName</span><span class="hljs-params">(newName <span class="hljs-keyword">string</span>)</span></span> {    e.name = newName}<span class="hljs-comment">/*</span><span class="hljs-comment">使用指针接收器的方法。</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Employee)</span> <span class="hljs-title">changeAge</span><span class="hljs-params">(newAge <span class="hljs-keyword">int</span>)</span></span> {    e.age = newAge}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {    e := Employee{        name: <span class="hljs-string">"Mark Andrew"</span>,        age:  <span class="hljs-number">50</span>,    }    fmt.Printf(<span class="hljs-string">"Employee name before change: %s"</span>, e.name)    e.changeName(<span class="hljs-string">"Michael Andrew"</span>)    fmt.Printf(<span class="hljs-string">"\nEmployee name after change: %s"</span>, e.name)    fmt.Printf(<span class="hljs-string">"\n\nEmployee age before change: %d"</span>, e.age)    e.changeAge(<span class="hljs-number">51</span>)    fmt.Printf(<span class="hljs-string">"\nEmployee age after change: %d"</span>, e.age)}</code></pre><p>输出：</p><pre><code class="hljs coq">Employee name <span class="hljs-built_in">before</span> <span class="hljs-built_in">change</span>: Mark AndrewEmployee name <span class="hljs-built_in">after</span> <span class="hljs-built_in">change</span>: Mark AndrewEmployee age <span class="hljs-built_in">before</span> <span class="hljs-built_in">change</span>: <span class="hljs-number">50</span>Employee age <span class="hljs-built_in">after</span> <span class="hljs-built_in">change</span>: <span class="hljs-number">51</span></code></pre><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口主要是用于对不同的结构体，赋予<strong>同一个名称的函数</strong>（该函数针对不同结构体可以有不同的操作）</p><p>通过下面这个程序，我们可以看看到调用Test接口的类型为<code>main.MyFloat</code>。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">"fmt"</span>)<span class="hljs-keyword">type</span> Test <span class="hljs-keyword">interface</span> {      Tester()}<span class="hljs-keyword">type</span> MyFloat <span class="hljs-keyword">float64</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m MyFloat)</span> <span class="hljs-title">Tester</span><span class="hljs-params">()</span></span> {      fmt.Println(m)}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">describe</span><span class="hljs-params">(t Test)</span></span> {      fmt.Printf(<span class="hljs-string">"Interface type %T value %v\n"</span>, t, t)}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {      <span class="hljs-keyword">var</span> t Test    f := MyFloat(<span class="hljs-number">89.7</span>)    t = f    describe(t)    t.Tester()}</code></pre><p>输出：</p><pre><code class="hljs routeros">Interface<span class="hljs-built_in"> type </span>main.MyFloat value 89.7  89.7</code></pre><h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>没有包含方法的接口称为空接口。空接口表示为 <code>interface{}</code>。由于空接口没有方法，因此所有类型都实现了空接口。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">"fmt"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">describe</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>{})</span></span> {      fmt.Printf(<span class="hljs-string">"Type = %T, value = %v\n"</span>, i, i)}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {      s := <span class="hljs-string">"Hello World"</span>    describe(s)    i := <span class="hljs-number">55</span>    describe(i)    strt := <span class="hljs-keyword">struct</span> {        name <span class="hljs-keyword">string</span>    }{        name: <span class="hljs-string">"Naveen R"</span>,    }    describe(strt)}</code></pre><p>输出：</p><pre><code class="hljs routeros">Type = string, value = Hello World  Type = int, value = 55  Type = struct { name string }, value = {Naveen R}</code></pre><h1 id="三、并行相关"><a href="#三、并行相关" class="headerlink" title="三、并行相关"></a>三、并行相关</h1><h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p>goroutine是由Go运行时管理的轻量级线程。</p><ul><li>Go 协程会复用（Multiplex）数量更少的 OS 线程。即使程序有数以千计的 Go 协程，也可能只有一个线程。如果该线程中的某一 Go 协程发生了阻塞（比如说等待用户输入），那么系统会再创建一个 OS 线程，并把其余 Go 协程都移动到这个新的 OS 线程。</li><li>使用信道（channel）来进行通信</li></ul><p>当我们直接运行以下代码的时候，会发现和我们想象的不一样，程序只输出了”main”，这是为什么捏？这是因为<code>go hello()</code>启动了一个新的协程，然后<code>main()</code>运行在一个特殊的协程上，称为 Go 主协程<code>Main Goroutine</code>。</p><div class="note note-success">            <p>如果 Go 主协程终止，则程序终止，于是其他 Go 协程也不会继续运行。</p>          </div><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">"fmt"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>{    fmt.Println(<span class="hljs-string">"Hello"</span>)}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {    <span class="hljs-keyword">go</span> hello()    fmt.Println(<span class="hljs-string">"main"</span>)}</code></pre><p>解决方法，可以是使主协程延迟一段时间，等其他协程运行结束后，再终止主协程。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">"fmt"</span>    <span class="hljs-string">"time"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>{    fmt.Println(<span class="hljs-string">"Hello"</span>)}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {    <span class="hljs-keyword">go</span> hello()    fmt.Println(<span class="hljs-string">"main"</span>)    time.Sleep(<span class="hljs-number">1</span> * time.Second)}</code></pre><p>使用多个goroutine同样可以使用延迟的方式来控制运行的顺序</p><h2 id="信道channel"><a href="#信道channel" class="headerlink" title="信道channel"></a>信道channel</h2><h3 id="什么是信道"><a href="#什么是信道" class="headerlink" title="什么是信道"></a>什么是信道</h3><p>信道可以想象成 Go 协程之间通信的管道。如同管道中的水会从一端流到另一端，通过使用信道，数据也可以从一端发送，在另一端接收。</p><h3 id="信道的定义"><a href="#信道的定义" class="headerlink" title="信道的定义"></a>信道的定义</h3><pre><code class="hljs go"> <span class="hljs-keyword">var</span> a <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>            <span class="hljs-comment">//定义一个int类型的信道</span> a = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)        <span class="hljs-comment">//分配内存</span><span class="hljs-comment">//或</span>a := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</code></pre><h3 id="信道的发送与接收"><a href="#信道的发送与接收" class="headerlink" title="信道的发送与接收"></a>信道的发送与接收</h3><pre><code class="hljs go">data := &lt;- a <span class="hljs-comment">// 读取信道 a  </span>a &lt;- data <span class="hljs-comment">// 写入信道 a</span></code></pre><div class="note note-success">            <p>信道的发送与接收默认是<strong>阻塞</strong>的</p>          </div><p>即：写入信道时，若没有读取，就会阻塞； 读取信道时，若没有写入，就会阻塞</p><p>我们可以将这个特性应用到前面的代码中，不再需要时间延迟</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(done <span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)</span></span>{    fmt.Println(<span class="hljs-string">"Hello"</span>)    done &lt;- <span class="hljs-literal">true</span>                <span class="hljs-comment">//写入信道，说明该go协程已经运行完毕</span>}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {    done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)    <span class="hljs-comment">//定义一个bool类型的信道</span>    <span class="hljs-keyword">go</span> hello(done)    &lt;- done                       <span class="hljs-comment">//当信道尚未被写入时，该读取信道的语句将会被阻塞</span>    fmt.Println(<span class="hljs-string">"main"</span>)}</code></pre><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>需要特别注意的是，如果只写入信道或者只读取信道，就会造成死锁，程序会触发panic并报错。</p><p>如：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {      ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)    ch &lt;- <span class="hljs-number">5</span>}</code></pre><p>输出：</p><pre><code class="hljs cmd">fatal error: all goroutines are asleep - deadlock!goroutine <span class="hljs-number">1</span> [chan send]:main.main()<span class="hljs-function">        E:/<span class="hljs-title">go</span>/<span class="hljs-title">src</span>/<span class="hljs-title">main.go</span>:5 +0<span class="hljs-title">x57</span></span><span class="hljs-function"><span class="hljs-title">exit</span> <span class="hljs-title">status</span> 2</span></code></pre><h3 id="单向信道"><a href="#单向信道" class="headerlink" title="单向信道"></a>单向信道</h3><ul><li>只收信道（Receive Only）        <code>chan&lt;- int</code></li><li>只送信道（Send Only）            <code>&lt;-chan int</code></li></ul><p>那么为什么需要单向信道呢？如果一个通道只收不送或者只送不收，哪还有什么意义！事实上，双向通道可以转换为单向信道，所以可以正常使用（个人认为，大概是用于协程传参的时候，单向信道可以限制某个协程对通道的操作，减少出错。）</p><p>上面的程序可以简单修改为：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(done <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">bool</span>)</span></span>{    <span class="hljs-comment">//这是单向的 只送信道</span>    fmt.Println(<span class="hljs-string">"Hello"</span>)    done &lt;- <span class="hljs-literal">true</span>                <span class="hljs-comment">//写入信道，说明该go协程已经运行完毕</span>}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {    done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)    <span class="hljs-comment">//定义一个bool类型的信道</span>    <span class="hljs-keyword">go</span> hello(done)    &lt;- done                       <span class="hljs-comment">//当信道尚未被写入时，该读取信道的语句将会被阻塞</span>    fmt.Println(<span class="hljs-string">"main"</span>)}</code></pre><div class="note note-success">            <p>双向信道可以转换为单向信道，但是反过来不可以</p>          </div><h3 id="关闭信道"><a href="#关闭信道" class="headerlink" title="关闭信道"></a>关闭信道</h3><p>使用多一个变量来判断信道是否已经关闭</p><pre><code class="hljs autohotkey"><span class="hljs-built_in">v,</span> ok := &lt;- ch</code></pre><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">producer</span><span class="hljs-params">(chnl <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> {      <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ {        chnl &lt;- i    }    <span class="hljs-built_in">close</span>(chnl)}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {      ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)    <span class="hljs-keyword">go</span> producer(ch)    <span class="hljs-keyword">for</span> {        v, ok := &lt;-ch        <span class="hljs-keyword">if</span> ok == <span class="hljs-literal">false</span> {            <span class="hljs-keyword">break</span>        }        fmt.Println(<span class="hljs-string">"Received "</span>, v, ok)    }}</code></pre><h3 id="使用for-range遍历"><a href="#使用for-range遍历" class="headerlink" title="使用for range遍历"></a>使用for range遍历</h3><p>使用for range，会自动判断信道是否已经关闭，若已经关闭，则会自动结束循环</p><p>上述代码可以修改为：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">producer</span><span class="hljs-params">(chnl <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> {      <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ {        chnl &lt;- i    }    <span class="hljs-built_in">close</span>(chnl)}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {      ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)    <span class="hljs-keyword">go</span> producer(ch)    <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch {        fmt.Println(<span class="hljs-string">"Received "</span>,v)    }}</code></pre><h2 id="缓冲信道和工作池"><a href="#缓冲信道和工作池" class="headerlink" title="缓冲信道和工作池"></a>缓冲信道和工作池</h2><h3 id="缓冲信道特点"><a href="#缓冲信道特点" class="headerlink" title="缓冲信道特点"></a>缓冲信道特点</h3><ul><li>只有在缓冲已满的情况，才会阻塞向缓冲信道发送数据。</li><li>只有在缓冲为空的时候，才会阻塞从缓冲信道接收数据。</li></ul><h3 id="创建缓冲信道"><a href="#创建缓冲信道" class="headerlink" title="创建缓冲信道"></a>创建缓冲信道</h3><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">type</span>, capacity)</code></pre><p>如：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">"fmt"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {      ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">2</span>)    ch &lt;- <span class="hljs-string">"naveen"</span>    ch &lt;- <span class="hljs-string">"paul"</span>    fmt.Println(&lt;- ch)    fmt.Println(&lt;- ch)}</code></pre><h3 id="waitGroup来实现工作池"><a href="#waitGroup来实现工作池" class="headerlink" title="waitGroup来实现工作池"></a>waitGroup来实现工作池</h3><p><code>WaitGroup</code> 用于等待一批 Go 协程执行结束。程序控制会一直阻塞，直到这些协程全部执行完毕。</p><p><code>waitGroup</code>使用的基本流程</p><ul><li>首先需要调用<code>sync</code>包</li><li>声明一个waitGroup：<code>var wg sync.WaitGroup</code></li><li>每运行一个子协程，传递int给<code>waitGroup</code>，使其计数器增加：<code>wg.Add(1)</code></li><li>取<code>waitGroup</code>的地址来传递函数：<code>go process(i, &amp;wg)</code></li><li>每一个子协程运行结束后，计数器自减：<code>wg.Done()</code></li><li>当所有子协程运行结束后，才能继续运行：<code>wg.Wait()</code></li></ul><p><strong>工作池的作用是什么呢？</strong></p><p>在golang编写服务程序过程中，如果每次都启动一个goroutine去处理任务，处理一个任务后就退出，这样势必会造成资源浪费。构建一个工作goroutine池来处理任务相对资源利用会少些，具体的情况需对比测试。</p><p><strong>示例</strong>，使用工作池来计算，每个随机数每一位加起来的和：</p><p>这里工作池的作用是：</p><ul><li>创建一个 Go 协程池，监听一个等待作业分配的输入型缓冲信道。</li><li>将作业添加到该输入型缓冲信道中。</li><li>作业完成后，再将结果写入一个输出型缓冲信道。</li><li>从输出型缓冲信道读取并打印结果。</li></ul><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">"fmt"</span>    <span class="hljs-string">"math/rand"</span>    <span class="hljs-string">"sync"</span>    <span class="hljs-string">"time"</span>)<span class="hljs-keyword">type</span> Job <span class="hljs-keyword">struct</span> {      id       <span class="hljs-keyword">int</span>    randomno <span class="hljs-keyword">int</span>}<span class="hljs-keyword">type</span> Result <span class="hljs-keyword">struct</span> {      job         Job    sumofdigits <span class="hljs-keyword">int</span>}<span class="hljs-keyword">var</span> jobs = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Job, <span class="hljs-number">10</span>)  <span class="hljs-keyword">var</span> results = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Result, <span class="hljs-number">10</span>)<span class="hljs-comment">//对一个数字的每位数求和</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">digits</span><span class="hljs-params">(number <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {      sum := <span class="hljs-number">0</span>    no := number    <span class="hljs-keyword">for</span> no != <span class="hljs-number">0</span> {        digit := no % <span class="hljs-number">10</span>        sum += digit        no /= <span class="hljs-number">10</span>    }    time.Sleep(<span class="hljs-number">2</span> * time.Second)    <span class="hljs-keyword">return</span> sum}<span class="hljs-comment">//调用digits函数，将结构体输入到results信道中，并且waitGroup的计数器减一</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(wg *sync.WaitGroup)</span></span> {      <span class="hljs-keyword">for</span> job := <span class="hljs-keyword">range</span> jobs {        output := Result{job, digits(job.randomno)}        results &lt;- output    }    wg.Done()}<span class="hljs-comment">//创建工作池，调用worker函数（进行计算并输出），当所有go程都运行结束后才停止</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createWorkerPool</span><span class="hljs-params">(noOfWorkers <span class="hljs-keyword">int</span>)</span></span> {      <span class="hljs-keyword">var</span> wg sync.WaitGroup    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; noOfWorkers; i++ {        wg.Add(<span class="hljs-number">1</span>)        <span class="hljs-keyword">go</span> worker(&amp;wg)    }    wg.Wait()    <span class="hljs-built_in">close</span>(results)}<span class="hljs-comment">//初始化，生成随机数并且输入到jobs信道中</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">allocate</span><span class="hljs-params">(noOfJobs <span class="hljs-keyword">int</span>)</span></span> {      <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; noOfJobs; i++ {        randomno := rand.Intn(<span class="hljs-number">999</span>)        job := Job{i, randomno}        jobs &lt;- job    }    <span class="hljs-built_in">close</span>(jobs)<span class="hljs-comment">//关闭信道，告诉接收方不再有数据发来</span>}<span class="hljs-comment">//输出结果，当全部输出完成后，done信道才会接收true信息，主go程&lt;-done才能运行。这是用来避免过早地结束主程序。</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">result</span><span class="hljs-params">(done <span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)</span></span> {      <span class="hljs-keyword">for</span> result := <span class="hljs-keyword">range</span> results {        fmt.Printf(<span class="hljs-string">"Job id %d, input random no %d , sum of digits %d\n"</span>, result.job.id, result.job.randomno, result.sumofdigits)    }    done &lt;- <span class="hljs-literal">true</span>}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {      startTime := time.Now()    noOfJobs := <span class="hljs-number">20</span>    <span class="hljs-keyword">go</span> allocate(noOfJobs)    done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)    <span class="hljs-keyword">go</span> result(done)    noOfWorkers := <span class="hljs-number">10</span>    createWorkerPool(noOfWorkers)    <span class="hljs-comment">//go result(done)也可以放在这里，没有影响</span>    &lt;-done    endTime := time.Now()    diff := endTime.Sub(startTime)    fmt.Println(<span class="hljs-string">"total time taken "</span>, diff.Seconds(), <span class="hljs-string">"seconds"</span>)}</code></pre><p>输出如下：</p><pre><code class="hljs yaml"><span class="hljs-string">Job</span> <span class="hljs-string">id</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-string">input</span> <span class="hljs-string">random</span> <span class="hljs-literal">no</span> <span class="hljs-number">983</span> <span class="hljs-string">,</span> <span class="hljs-string">sum</span> <span class="hljs-string">of</span> <span class="hljs-string">digits</span> <span class="hljs-number">20</span><span class="hljs-string">Job</span> <span class="hljs-string">id</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-string">input</span> <span class="hljs-string">random</span> <span class="hljs-literal">no</span> <span class="hljs-number">636</span> <span class="hljs-string">,</span> <span class="hljs-string">sum</span> <span class="hljs-string">of</span> <span class="hljs-string">digits</span> <span class="hljs-number">15</span><span class="hljs-string">Job</span> <span class="hljs-string">id</span> <span class="hljs-number">7</span><span class="hljs-string">,</span> <span class="hljs-string">input</span> <span class="hljs-string">random</span> <span class="hljs-literal">no</span> <span class="hljs-number">998</span> <span class="hljs-string">,</span> <span class="hljs-string">sum</span> <span class="hljs-string">of</span> <span class="hljs-string">digits</span> <span class="hljs-number">26</span><span class="hljs-string">Job</span> <span class="hljs-string">id</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-string">input</span> <span class="hljs-string">random</span> <span class="hljs-literal">no</span> <span class="hljs-number">878</span> <span class="hljs-string">,</span> <span class="hljs-string">sum</span> <span class="hljs-string">of</span> <span class="hljs-string">digits</span> <span class="hljs-number">23</span><span class="hljs-string">Job</span> <span class="hljs-string">id</span> <span class="hljs-number">5</span><span class="hljs-string">,</span> <span class="hljs-string">input</span> <span class="hljs-string">random</span> <span class="hljs-literal">no</span> <span class="hljs-number">735</span> <span class="hljs-string">,</span> <span class="hljs-string">sum</span> <span class="hljs-string">of</span> <span class="hljs-string">digits</span> <span class="hljs-number">15</span><span class="hljs-string">Job</span> <span class="hljs-string">id</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-string">input</span> <span class="hljs-string">random</span> <span class="hljs-literal">no</span> <span class="hljs-number">407</span> <span class="hljs-string">,</span> <span class="hljs-string">sum</span> <span class="hljs-string">of</span> <span class="hljs-string">digits</span> <span class="hljs-number">11</span><span class="hljs-string">Job</span> <span class="hljs-string">id</span> <span class="hljs-number">9</span><span class="hljs-string">,</span> <span class="hljs-string">input</span> <span class="hljs-string">random</span> <span class="hljs-literal">no</span> <span class="hljs-number">150</span> <span class="hljs-string">,</span> <span class="hljs-string">sum</span> <span class="hljs-string">of</span> <span class="hljs-string">digits</span> <span class="hljs-number">6</span><span class="hljs-string">Job</span> <span class="hljs-string">id</span> <span class="hljs-number">8</span><span class="hljs-string">,</span> <span class="hljs-string">input</span> <span class="hljs-string">random</span> <span class="hljs-literal">no</span> <span class="hljs-number">904</span> <span class="hljs-string">,</span> <span class="hljs-string">sum</span> <span class="hljs-string">of</span> <span class="hljs-string">digits</span> <span class="hljs-number">13</span><span class="hljs-string">Job</span> <span class="hljs-string">id</span> <span class="hljs-number">6</span><span class="hljs-string">,</span> <span class="hljs-string">input</span> <span class="hljs-string">random</span> <span class="hljs-literal">no</span> <span class="hljs-number">520</span> <span class="hljs-string">,</span> <span class="hljs-string">sum</span> <span class="hljs-string">of</span> <span class="hljs-string">digits</span> <span class="hljs-number">7</span><span class="hljs-string">Job</span> <span class="hljs-string">id</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-string">input</span> <span class="hljs-string">random</span> <span class="hljs-literal">no</span> <span class="hljs-number">895</span> <span class="hljs-string">,</span> <span class="hljs-string">sum</span> <span class="hljs-string">of</span> <span class="hljs-string">digits</span> <span class="hljs-number">22</span><span class="hljs-string">Job</span> <span class="hljs-string">id</span> <span class="hljs-number">19</span><span class="hljs-string">,</span> <span class="hljs-string">input</span> <span class="hljs-string">random</span> <span class="hljs-literal">no</span> <span class="hljs-number">914</span> <span class="hljs-string">,</span> <span class="hljs-string">sum</span> <span class="hljs-string">of</span> <span class="hljs-string">digits</span> <span class="hljs-number">14</span><span class="hljs-string">Job</span> <span class="hljs-string">id</span> <span class="hljs-number">10</span><span class="hljs-string">,</span> <span class="hljs-string">input</span> <span class="hljs-string">random</span> <span class="hljs-literal">no</span> <span class="hljs-number">212</span> <span class="hljs-string">,</span> <span class="hljs-string">sum</span> <span class="hljs-string">of</span> <span class="hljs-string">digits</span> <span class="hljs-number">5</span><span class="hljs-string">Job</span> <span class="hljs-string">id</span> <span class="hljs-number">17</span><span class="hljs-string">,</span> <span class="hljs-string">input</span> <span class="hljs-string">random</span> <span class="hljs-literal">no</span> <span class="hljs-number">506</span> <span class="hljs-string">,</span> <span class="hljs-string">sum</span> <span class="hljs-string">of</span> <span class="hljs-string">digits</span> <span class="hljs-number">11</span><span class="hljs-string">Job</span> <span class="hljs-string">id</span> <span class="hljs-number">11</span><span class="hljs-string">,</span> <span class="hljs-string">input</span> <span class="hljs-string">random</span> <span class="hljs-literal">no</span> <span class="hljs-number">538</span> <span class="hljs-string">,</span> <span class="hljs-string">sum</span> <span class="hljs-string">of</span> <span class="hljs-string">digits</span> <span class="hljs-number">16</span><span class="hljs-string">Job</span> <span class="hljs-string">id</span> <span class="hljs-number">12</span><span class="hljs-string">,</span> <span class="hljs-string">input</span> <span class="hljs-string">random</span> <span class="hljs-literal">no</span> <span class="hljs-number">750</span> <span class="hljs-string">,</span> <span class="hljs-string">sum</span> <span class="hljs-string">of</span> <span class="hljs-string">digits</span> <span class="hljs-number">12</span><span class="hljs-string">Job</span> <span class="hljs-string">id</span> <span class="hljs-number">16</span><span class="hljs-string">,</span> <span class="hljs-string">input</span> <span class="hljs-string">random</span> <span class="hljs-literal">no</span> <span class="hljs-number">630</span> <span class="hljs-string">,</span> <span class="hljs-string">sum</span> <span class="hljs-string">of</span> <span class="hljs-string">digits</span> <span class="hljs-number">9</span><span class="hljs-string">Job</span> <span class="hljs-string">id</span> <span class="hljs-number">15</span><span class="hljs-string">,</span> <span class="hljs-string">input</span> <span class="hljs-string">random</span> <span class="hljs-literal">no</span> <span class="hljs-number">215</span> <span class="hljs-string">,</span> <span class="hljs-string">sum</span> <span class="hljs-string">of</span> <span class="hljs-string">digits</span> <span class="hljs-number">8</span><span class="hljs-string">Job</span> <span class="hljs-string">id</span> <span class="hljs-number">18</span><span class="hljs-string">,</span> <span class="hljs-string">input</span> <span class="hljs-string">random</span> <span class="hljs-literal">no</span> <span class="hljs-number">20</span> <span class="hljs-string">,</span> <span class="hljs-string">sum</span> <span class="hljs-string">of</span> <span class="hljs-string">digits</span> <span class="hljs-number">2</span><span class="hljs-string">Job</span> <span class="hljs-string">id</span> <span class="hljs-number">13</span><span class="hljs-string">,</span> <span class="hljs-string">input</span> <span class="hljs-string">random</span> <span class="hljs-literal">no</span> <span class="hljs-number">362</span> <span class="hljs-string">,</span> <span class="hljs-string">sum</span> <span class="hljs-string">of</span> <span class="hljs-string">digits</span> <span class="hljs-number">11</span><span class="hljs-string">Job</span> <span class="hljs-string">id</span> <span class="hljs-number">14</span><span class="hljs-string">,</span> <span class="hljs-string">input</span> <span class="hljs-string">random</span> <span class="hljs-literal">no</span> <span class="hljs-number">436</span> <span class="hljs-string">,</span> <span class="hljs-string">sum</span> <span class="hljs-string">of</span> <span class="hljs-string">digits</span> <span class="hljs-number">13</span><span class="hljs-string">total</span> <span class="hljs-string">time</span> <span class="hljs-string">taken</span>  <span class="hljs-number">4.0083858</span> <span class="hljs-string">seconds</span></code></pre><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>直接来看一下参考程序</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">"fmt"</span>    <span class="hljs-string">"time"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server1</span><span class="hljs-params">( str1 <span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)</span></span>{    time.Sleep(<span class="hljs-number">3</span>*time.Second)    str1 &lt;- <span class="hljs-string">"message from server1"</span>}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server2</span><span class="hljs-params">( str2 <span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)</span></span>{    time.Sleep(<span class="hljs-number">1</span>*time.Second)    str2 &lt;- <span class="hljs-string">"message from server2"</span>}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    output1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)    output2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)    <span class="hljs-keyword">go</span> server1(output1)    <span class="hljs-keyword">go</span> server2(output2)    <span class="hljs-keyword">select</span> {    <span class="hljs-keyword">case</span> s1 := &lt;- output1:        fmt.Println(s1)    <span class="hljs-keyword">case</span> s2 := &lt;- output2:        fmt.Println(s2)    }}</code></pre><p>输出：</p><pre><code class="hljs sas"><span class="hljs-meta">message</span> <span class="hljs-meta">from</span> server2</code></pre><p>主程序当运行到<code>select</code>就会一直阻塞，直到出现符合要求的<code>case</code>出现。由于<code>server1</code>延迟3秒，<code>server2</code>延迟1秒，所以<code>select</code>会先接收到信道<code>output2</code>，进行输出后，程序结束。（不会管<code>server1</code>啦）</p><p>这有什么用呢？假设我们现在向两台服务器发送申请，并等待它们的回复。为了节省时间，当我们接收到最快的回复时，就继续接下来的步骤。这可以使反应达到最快的速度。</p><div class="note note-success">            <p>类似于switch，使用default关键字来表示默认的情况。可用来避免死锁的出现。</p><p>！！！当信道仅含有nil时，也会触发<code>dafault</code>！！！</p>          </div><h3 id="随机选取"><a href="#随机选取" class="headerlink" title="随机选取"></a>随机选取</h3><p>当多个case被同时选取时，会随机选择一个去执行。</p><p>下面这个程序使用了延迟一秒来同步两个go协程。</p><p>输出结果是<code>from server1</code>和<code>from server2</code>两种都有可能。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">"fmt"</span>    <span class="hljs-string">"time"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server1</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)</span></span> {      ch &lt;- <span class="hljs-string">"from server1"</span>}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server2</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)</span></span> {      ch &lt;- <span class="hljs-string">"from server2"</span>}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {      output1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)    output2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)    <span class="hljs-keyword">go</span> server1(output1)    <span class="hljs-keyword">go</span> server2(output2)    time.Sleep(<span class="hljs-number">1</span> * time.Second)    <span class="hljs-keyword">select</span> {    <span class="hljs-keyword">case</span> s1 := &lt;-output1:        fmt.Println(s1)    <span class="hljs-keyword">case</span> s2 := &lt;-output2:        fmt.Println(s2)    }}</code></pre><h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">"fmt"</span>    <span class="hljs-string">"sync"</span>)<span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(wg *sync.WaitGroup)</span></span>{    x++    wg.Done()}<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    <span class="hljs-keyword">var</span> wg sync.WaitGroup    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ {        wg.Add(<span class="hljs-number">1</span>)        <span class="hljs-keyword">go</span> increment(&amp;wg)    }    wg.Wait()    fmt.Println(x)}</code></pre><p>输出：</p><pre><code class="hljs angelscript"><span class="hljs-number">982</span>/<span class="hljs-number">984</span>/<span class="hljs-number">992</span></code></pre><h3 id="使用mutex解决临界区问题"><a href="#使用mutex解决临界区问题" class="headerlink" title="使用mutex解决临界区问题"></a><strong>使用mutex解决临界区问题</strong></h3><p>外部定义互斥锁<code>var m sync.Mutex</code></p><pre><code class="hljs go">m.Lock()x++m.Unlock()</code></pre><p>输出：</p><pre><code class="hljs angelscript"><span class="hljs-number">1000</span></code></pre><h3 id="使用信道解决临界区问题"><a href="#使用信道解决临界区问题" class="headerlink" title="使用信道解决临界区问题"></a>使用信道解决临界区问题</h3><pre><code class="hljs go">ch &lt;- <span class="hljs-literal">true</span>x++&lt;- ch</code></pre><p>输出：</p><pre><code class="hljs angelscript"><span class="hljs-number">1000</span></code></pre><div class="note note-success">            <p>关于互斥锁和信道的选择问题。</p><p>当 Go 协程需要与其他协程通信时，可以使用信道。而当只允许一个协程访问临界区时，可以使用 Mutex。</p>          </div><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.runoob.com/go">https://www.runoob.com/go</a></p><p><a href="https://tour.go-zh.org/">https://tour.go-zh.org/</a></p><p><a href="https://studygolang.com/subject/2">https://studygolang.com/subject/2</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HPClab2</title>
    <link href="/Wuhlan3/2021/09/30/HPClab2/"/>
    <url>/Wuhlan3/2021/09/30/HPClab2/</url>
    
    <content type="html"><![CDATA[<h1 id="高性能计算-lab2"><a href="#高性能计算-lab2" class="headerlink" title="高性能计算 lab2"></a>高性能计算 lab2</h1><p>！！！</p><p>源代码可以参考这个仓库喔<a href="https://gitee.com/Wuhlan3/hpc">https://gitee.com/Wuhlan3/hpc</a></p><p>！！！</p><h2 id="一、基于MPI点对点通信的矩阵乘法"><a href="#一、基于MPI点对点通信的矩阵乘法" class="headerlink" title="一、基于MPI点对点通信的矩阵乘法"></a>一、基于MPI点对点通信的矩阵乘法</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>我们可以将矩阵B分配给所有的进程，并将矩阵A进行划分，将每一部分分配给对应的进程。在每个进程完成自己那一部分的计算之后，汇总到主进程，组合成最终目标矩阵C。</p><p>其中涉及到的主要的MPI函数包括：</p><ul><li>初始化、获取进程数目与当前进程号</li></ul><pre><code class="hljs c++">MPI_Init(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);MPI_Comm_size(MPI_COMM_WORLD, &amp;comm_sz);MPI_Comm_rank(MPI_COMM_WORLD, &amp;my_rank);</code></pre><ul><li>路障函数，用于同步</li></ul><pre><code class="hljs c++">MPI_Barrier(MPI_COMM_WORLD);</code></pre><ul><li>点对点通信函数</li></ul><pre><code class="hljs c++">MPI_Send(&amp;A[i*row_range][<span class="hljs-number">0</span>], A_size, MPI_DOUBLE, i, i, MPI_COMM_WORLD); MPI_Recv(&amp;buf_A[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], A_size, MPI_DOUBLE, <span class="hljs-number">0</span>, my_rank,   MPI_COMM_WORLD, MPI_STATUS_IGNORE);</code></pre><ul><li>MPI获取时间的函数</li></ul><pre><code class="hljs c++"><span class="hljs-keyword">double</span> start, end;MPI_Barrier(MPI_COMM_WORLD); start = MPI_Wtime();end = MPI_Wtime();</code></pre><ul><li>MPI的释放</li></ul><pre><code class="hljs c++">MPI_Finalize();</code></pre><p><strong>详情可以参考文件中的源码<code>mpi_matrix_mul1.cpp</code></strong></p><h3 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h3><pre><code class="hljs shell">mpicxx -g -Wall -o m1 mpi_matrix_mul1.cppmpiexec -oversubscribe  -n 4 ./m1</code></pre><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><div class="table-container"><table><thead><tr><th>核数\矩阵大小</th><th>512</th><th>1024</th><th>1536</th><th>2048</th></tr></thead><tbody><tr><td>1</td><td>0.810431</td><td>11.400184</td><td>54.643829</td><td>166.500494</td></tr><tr><td>2</td><td>0.503364</td><td>5.933909</td><td>27.939495</td><td>83.671942</td></tr><tr><td>4</td><td>0.608522</td><td>6.119340</td><td>28.566730</td><td>85.674031</td></tr><tr><td>8</td><td>0.675070</td><td>6.000397</td><td>27.530209</td><td>87.848682</td></tr></tbody></table></div><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109281529906.png" alt="image-20210928152819031"></p><h2 id="二、基于MPI集合通信的矩阵乘法"><a href="#二、基于MPI集合通信的矩阵乘法" class="headerlink" title="二、基于MPI集合通信的矩阵乘法"></a>二、基于MPI集合通信的矩阵乘法</h2><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><p>基本流程同一类似。只不过改用集合通信函数，可以更加方便地进行进程间的通信，而不需要使用for循环、关注进程的编号等等。集合通信函数可以自行划分内存块。感觉用到类型派生的函数的话反而变得更加麻烦，所以在另一个文件中使用了一下，权当练习练习，可以查看文件<code>mpi_matrix_mul3.cpp</code>。</p><p>其中涉及到的主要的MPI函数包括：</p><ul><li>广播函数，用于将B矩阵发给所有进程</li></ul><pre><code class="hljs c++">MPI_Bcast(&amp;B[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], n*k, MPI_DOUBLE, <span class="hljs-number">0</span>, MPI_COMM_WORLD);</code></pre><ul><li>散射函数，将A矩阵划分，发给对应的进程</li></ul><pre><code class="hljs c++">MPI_Scatter(&amp;A[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], A_size, MPI_DOUBLE, &amp;buf_A[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], A_size, MPI_DOUBLE, <span class="hljs-number">0</span>, MPI_COMM_WORLD);</code></pre><ul><li>聚集函数，收集所有计算好的C矩阵，组合成完整的C矩阵</li></ul><pre><code class="hljs c++">MPI_Gather(&amp;buf_C[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], C_size, MPI_DOUBLE, &amp;C[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], C_size, MPI_DOUBLE, <span class="hljs-number">0</span>, MPI_COMM_WORLD);</code></pre><p><strong>详情可以参考文件中的源码<code>mpi_matrix_mul2.cpp</code></strong></p><h3 id="编译与运行-1"><a href="#编译与运行-1" class="headerlink" title="编译与运行"></a>编译与运行</h3><pre><code class="hljs shell">mpicxx -g -Wall -o m1 mpi_matrix_mul2.cppmpiexec -oversubscribe  -n 4 ./m2</code></pre><h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><div class="table-container"><table><thead><tr><th>核数\矩阵大小</th><th>512</th><th>1024</th><th>1536</th><th>2048</th></tr></thead><tbody><tr><td>1</td><td>0.914887</td><td>15.457199</td><td>89.563702</td><td>232.458000</td></tr><tr><td>2</td><td>0.555392</td><td>9.096576</td><td>51.484947</td><td>134.997501</td></tr><tr><td>4</td><td>0.502040</td><td>9.375724</td><td>51.218516</td><td>149.110322</td></tr><tr><td>8</td><td>0.617615</td><td>11.616788</td><td>51.633731</td><td>140.564852</td></tr></tbody></table></div><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109281529243.png" alt="image-20210928152915051"></p><h3 id="两种通信方式的比较"><a href="#两种通信方式的比较" class="headerlink" title="两种通信方式的比较"></a>两种通信方式的比较</h3><p>可以很明显地看到，集合通信方式比点对点通信方式慢上许多，集合通信的运行时长多了接近一倍。这貌似与预先设想的不太一样。具体原因可能在于，在进行点对点通信的时候，我也对矩阵进行了手动的平均划分，而集合通信的过程很可能需要函数内部进行自己判断如何平均划分。所以虽然集合通信写起来更加方便，但性能比不上点对点的通信方式。</p><h2 id="三、定义自己的MPI类型"><a href="#三、定义自己的MPI类型" class="headerlink" title="三、定义自己的MPI类型"></a>三、定义自己的MPI类型</h2><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><ol><li><p>定义一个结构体</p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">{</span>    <span class="hljs-keyword">double</span> A[SIZE][SIZE];    <span class="hljs-keyword">double</span> B[SIZE][SIZE];} AandB;</code></pre></li><li><p>使用MPI_Type_create_struct函数</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> count = <span class="hljs-number">2</span>;<span class="hljs-comment">//块数</span>    <span class="hljs-keyword">int</span> blocklengths[count] = {m * n, n * k};<span class="hljs-comment">//每个块的长度</span>    MPI_Aint offsets[count];<span class="hljs-comment">//块偏移量</span>    MPI_Get_address(aandb.A, &amp;offsets[<span class="hljs-number">0</span>]);    MPI_Get_address(aandb.B, &amp;offsets[<span class="hljs-number">1</span>]);    offsets[<span class="hljs-number">1</span>] = offsets[<span class="hljs-number">1</span>] - offsets[<span class="hljs-number">0</span>];    offsets[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    MPI_Datatype types[count] = {MPI_DOUBLE, MPI_DOUBLE};<span class="hljs-comment">//块类型</span>    MPI_Datatype aandbtype;<span class="hljs-comment">//自定义MPI类型</span>    MPI_Type_create_struct(count, blocklengths, offsets, types, &amp;aandbtype);<span class="hljs-comment">//创造属于自己的类型</span>    MPI_Type_commit(&amp;aandbtype);<span class="hljs-comment">//提交，使得该类型可以被使用</span></code></pre></li><li><p>在集合通信中的使用。发送给所有进程</p><pre><code class="hljs c++">MPI_Bcast(&amp;aandb, <span class="hljs-number">1</span>, aandbtype, <span class="hljs-number">0</span>, MPI_COMM_WORLD);</code></pre></li></ol><p><strong>详情可以参考文件中的源码<code>mpi_matrix_mul3.cpp</code></strong></p><h3 id="编译与运行-2"><a href="#编译与运行-2" class="headerlink" title="编译与运行"></a>编译与运行</h3><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109301551742.png" alt="image-20210930143230675" style="zoom:80%;box-shadow:none"></p><p>结果正确。</p><h2 id="四、改造Lab1成矩阵乘法库函数"><a href="#四、改造Lab1成矩阵乘法库函数" class="headerlink" title="四、改造Lab1成矩阵乘法库函数"></a>四、改造Lab1成矩阵乘法库函数</h2><h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>动态链接库提供了<strong>Lab1</strong>中三种矩阵的乘法函数：</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> MATRIXMUL_H__</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MATRIXMUL_H__</span><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Strassen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">double</span>** MatrixA, <span class="hljs-keyword">double</span>** MatrixB, <span class="hljs-keyword">double</span>** MatrixC)</span></span>;<span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">based_on_software_mul</span><span class="hljs-params">(<span class="hljs-keyword">double</span>** A, <span class="hljs-keyword">double</span> ** B, <span class="hljs-keyword">double</span> ** C, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span></span>;<span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">general_mul</span><span class="hljs-params">(<span class="hljs-keyword">double</span>** A, <span class="hljs-keyword">double</span> ** B, <span class="hljs-keyword">double</span> ** C, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span></span>;<span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cout_matrix</span><span class="hljs-params">(<span class="hljs-keyword">double</span> ** C, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span></span>;<span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cin_matrix</span><span class="hljs-params">(<span class="hljs-keyword">double</span> ** A, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span></span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><h3 id="逐步编译与链接"><a href="#逐步编译与链接" class="headerlink" title="逐步编译与链接"></a>逐步编译与链接</h3><pre><code class="hljs shell">g++ -c -fPIC matrixmul.cppg++ -shared -o libmatrixmul.so matrixmul.og++ -L/home/wuhlan3/Desktop/mpi -o main main.cpp -lmatrixmulexport LD_LIBRARY_PATH=/home/wuhlan3/Desktop/mpi/libmatrixmul:$LD_LIBRARY_PATH./main</code></pre><h3 id="makefile文件"><a href="#makefile文件" class="headerlink" title="makefile文件"></a>makefile文件</h3><pre><code class="hljs makefile"><span class="hljs-comment">#######################</span><span class="hljs-comment"># Makefile</span><span class="hljs-comment">#######################</span><span class="hljs-comment"># compile and lib parameter</span>CC      := g++LIBS    := LDFLAGS := DEFINES :=INCLUDE := -I/home/wuhlan3/Desktop/mpi/matrixmul.hCFLAGS  := CXXFLAGS:= <span class="hljs-comment"># link parameter</span>LIB := libmatrixmul.so<span class="hljs-comment">#link</span><span class="hljs-variable">$(LIB)</span>:matrixmul.o    <span class="hljs-variable">$(CC)</span> -shared -o -fPIC -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><span class="hljs-comment">#compile</span><span class="hljs-section">matrixmul.o:matrixmul.cpp</span>    <span class="hljs-variable">$(CC)</span> -c -fPIC <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span> <span class="hljs-comment"># clean</span><span class="hljs-section">clean:</span>    rm -fr *.o</code></pre><p>使用后生成<code>.so</code>文件：</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109301552957.png" alt="image-20210928142657323" style="zoom:80%;box-shadow:none"></p><p>编译main文件可以正常运行：</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109301551113.png" alt="image-20210928142817059" style="zoom:80%;box-shadow:none"></p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="1-内存不足"><a href="#1-内存不足" class="headerlink" title="1.内存不足"></a>1.内存不足</h3><p>对于点对点通信，一开始我使用的是一维数组存储矩阵的方式，我想着一维数组寻址会更加方便，使用<code>MPI_Send()</code>和<code>MPI_Recv()</code>函数时也会更加方便。小于512的矩阵还是能够正常计算的，但是当大小足够大时就会出现报错了。这是因为<code>double A[1024*1024]</code>这样的数组很可能已经超过了数组的上限（其中double是8字节的）。 只好改成二维数组的方式来存储。但是静态分配内存还是会出现segment fault的错误。最终只能使用动态分配内存。</p><p>此外，我还发现在mpi中使用malloc很容易出现错误，实在搞不明白具体原因。在经过大半天的调试后仍然失败。最后使用c++中的new和delete组合，就成功了。</p><h3 id="2-编译遇到的问题"><a href="#2-编译遇到的问题" class="headerlink" title="2.编译遇到的问题"></a>2.编译遇到的问题</h3><p>在linux上编译可能需要添加oversubscribe</p><h3 id="3-二维矩阵在集合通信函数中的使用"><a href="#3-二维矩阵在集合通信函数中的使用" class="headerlink" title="3.二维矩阵在集合通信函数中的使用"></a>3.二维矩阵在集合通信函数中的使用</h3><pre><code class="hljs c++">MPI_Scatter(&amp;A[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], A_size, MPI_DOUBLE, &amp;buf_A[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], A_size, MPI_DOUBLE, <span class="hljs-number">0</span>, MPI_COMM_WORLD);</code></pre><p>比如说，假设A矩阵有8行，有4个进程。那么这种写法，是能够将其中的每两行分配个对应的进程的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>超算</tag>
      
      <tag>linux</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>惊散楼头飞雪</title>
    <link href="/Wuhlan3/2021/09/27/%E6%83%8A%E6%95%A3%E6%A5%BC%E5%A4%B4%E9%A3%9E%E9%9B%AA/"/>
    <url>/Wuhlan3/2021/09/27/%E6%83%8A%E6%95%A3%E6%A5%BC%E5%A4%B4%E9%A3%9E%E9%9B%AA/</url>
    
    <content type="html"><![CDATA[<h1>惊散楼头飞雪</h1><p>事情是这样的。</p><p>看到一个学弟发的tape，主题差不多是“想不出一句诗作为标题”。</p><p>也就跟风发了一句：</p><blockquote><p>我病君来高歌饮，惊散楼头飞雪。笑富贵千钧如发。硬语盘空谁来听？</p><p>这是我最喜欢的一句，只是找不到一个人可以使我说出这句话。</p></blockquote><p>他回了一句：</p><blockquote><p>龙共虎，应声裂。</p></blockquote><p>没看懂，我好奇的搜了一搜。原来是陈亮写给辛弃疾的词，而我所写的是辛弃疾回写给陈亮的。突然间像点燃了什么，我的整个世界明媚起来。可能是最近太自闭了吧，我似乎有很多很多东西想找人倾诉，没有人愿意听，他们也未必听得懂。这种情况下，突然听到了一声令人满意的回应，该是多么值得激动的事情！</p><p>分享一下这两首词：</p><center><h4>贺新郎·同父见和再用韵答之</h4></center><center><h5>辛弃疾</h5></center><center>老去凭谁说。</center><center>似而今、元龙臭味，孟公瓜葛。</center><center>我病君来高歌饮，惊散楼头飞雪。</center><center>笑富贵千钧如发。硬语盘空谁来听？</center><center>记当时、只有西窗月。</center><center>重进酒，换鸣瑟。</center><br><center>事无两样人心别。</center><center>问渠侬：神州毕竟，几番离合？</center><center>汗血盐车无人顾，千里空收骏骨。</center><center>正目断关河路绝。</center><center>我最怜君中宵舞，道“男儿到死心如铁”。</center><center>看试手，补天裂。</center><center><h4>贺新郎·寄辛幼安和见怀韵</h4></center><center><h5>陈亮</h5></center><center>老大那堪说。</center><center>看几番、神奇臭腐，夏裘冬葛。</center><center>父老长安今余几，后死无仇可雪。</center><center>犹未燥、当时生发。</center><center>二十五弦多少恨，算世间、那有平分月。</center><center>胡妇弄，汉宫瑟。</center><br><center>树犹如此堪重别。</center><center>只使君、从来与我，话头多合。</center><center>行矣置之无足问，谁换妍皮痴骨。</center><center>但莫使、伯牙弦绝。</center><center>九转丹砂牢拾取，管精金、只是寻常铁。</center><center>龙共虎，应声裂。</center>]]></content>
    
    
    
    <tags>
      
      <tag>不务正业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(四)Semantics_and_Embeddings</title>
    <link href="/Wuhlan3/2021/09/26/Semantics-and-Embeddings/"/>
    <url>/Wuhlan3/2021/09/26/Semantics-and-Embeddings/</url>
    
    <content type="html"><![CDATA[<h1 id="Semantics-amp-Embeddings"><a href="#Semantics-amp-Embeddings" class="headerlink" title="Semantics&amp;Embeddings"></a>Semantics&amp;Embeddings</h1><h2 id="Relations"><a href="#Relations" class="headerlink" title="Relations"></a>Relations</h2><p>Lemmas can be polysemous (多义性，have multiple senses)，比如说mouse：</p><ul><li>指一种小型啮齿动物</li><li>鼠标…</li></ul><p>单词之间的关系：</p><ul><li>Synonymy(同义词)：couch / sofa、big / large、automobile / car</li><li>Antonymy(反义词)：dark / light、up / down</li><li>Similarity(相似性)：car / bicycle、cow / horse</li><li>Relatedness(关联性)：coffee / tea</li><li>Connotation(内涵)：感情上的（happy/sad）、隐含的意义(褒贬)（copy/fake）、评价(great/terrible)</li></ul><div class="note note-success">            <p>The meaning of a word is its use in the language</p>          </div><h2 id="Connotation"><a href="#Connotation" class="headerlink" title="Connotation"></a>Connotation</h2><p>单词可以从三个维度来看待：</p><ol><li>Valence（警觉度）：the pleasantness of the stimulus</li><li>Arousal（唤醒度）：the intensity of emotion provoked by the stimulus</li><li>Dominance（支配度）：the degree of control exerted by the stimulus</li></ol><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109262248476.png" alt="image-20210926224807705" style="zoom:100%;box-shadow: none"></p><h2 id="Vector-Semantics"><a href="#Vector-Semantics" class="headerlink" title="Vector Semantics"></a>Vector Semantics</h2><p>我们是否可以建立一种方法来表达词义呢？接下来就介绍一种常用的模型vector semantics。</p><blockquote><p>“The meaning of a word is its use in the language”</p></blockquote><ol><li><p>通过语言的分布决定语义</p></li><li><p>从多个维度来看待语义（空间中的某个点）</p></li></ol><p>我们使用一个向量来表示每一个词语。相似的词语在<strong>语义空间</strong>(<strong>semantic space</strong>)上是<strong>邻近</strong>的。</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109262305164.png" alt="image-20210926230518609" style="zoom:100%;box-shadow:none"></p><p>对于情绪分析，如果<strong>基于单词本身</strong>：</p><ul><li>单词特征就是用单词来标识的</li><li>比如说在之前遇到一个单词为“terrible”</li><li>那么我们在训练集和测试集中<strong>只能使用完全相同的单词</strong></li></ul><p>如果<strong>基于词向量(Embedding)</strong>：</p><ul><li>单词特征就是一个向量来表示的</li><li>前一个单词是向量vector[35,22,17…]；现在测试集中我们可能看到相似的向量vector[34,21,14]</li><li>此时我们就可以将其概括为<strong>similar but unseen words</strong>（不再局限于单一的单词，可以是相似的单词）</li></ul><p>我们将会讨论<strong>两种词向量算法</strong>：</p><ol><li><strong>Tf-idf</strong>（特征：用于<strong>信息检索</strong>；一种基线模型；<strong>稀疏向量</strong>；单词用附近的单词计数表示）</li><li><strong>Word2vec</strong>（特征：<strong>密集向量</strong>；通过训练分类器来<strong>预测</strong>单词是否可能出现在附近；上下文嵌入contextual embeddings）</li></ol><blockquote><p>荃者所以在鱼，得鱼而忘荃；</p><p>言者所以在意，得意而忘言。</p><p>——庄子</p></blockquote><h2 id="Words-and-Vectors"><a href="#Words-and-Vectors" class="headerlink" title="Words and Vectors"></a>Words and Vectors</h2><h3 id="文本间的关系"><a href="#文本间的关系" class="headerlink" title="文本间的关系"></a>文本间的关系</h3><p>每个文本都可以表示成一个单词的向量。比如说下面莎士比亚的文章就分别记录了相关单词的出现次数：</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109262347161.png" alt="image-20210926234152207" style="zoom:80%;box-shadow:none"></p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109262347863.png" alt="image-20210926234200465" style="zoom:80%;box-shadow:none"></p><p>可以看到，《亨利五世》和《裘力斯·凯撒》的相关性更强，《皆大欢喜》和《第十二夜》更加相似。</p><h3 id="单词间的关系"><a href="#单词间的关系" class="headerlink" title="单词间的关系"></a>单词间的关系</h3><p>两个单词如果它们的上下文相似，这两个单词也是相似的。</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109262347232.png" alt="image-20210926234555455" style="zoom:80%;box-shadow:none"></p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109262347994.png" alt="image-20210926234638018" style="zoom:80%;box-shadow:none"></p><h2 id="cos计算单词相似性"><a href="#cos计算单词相似性" class="headerlink" title="cos计算单词相似性"></a>cos计算单词相似性</h2><p>对两个向量进行点乘：</p><script type="math/tex; mode=display">dot\ product(v,w) = v·w=\sum^{N}_{i=1}v_iw_i = v_1w_1+v_2w_2...</script><p>但是这可能会引起一些问题：如果维数过大，乘积可能会非常大</p><p>向量长度是：</p><script type="math/tex; mode=display">|v| = \sqrt{\sum ^ N _{i=1}v_i ^ 2}</script><p>我们可以计算出：</p><script type="math/tex; mode=display">cosine(\hat v , \hat w) = \frac{\hat v · \hat w}{|\hat v||\hat w|}= \frac{\sum ^ N_{i=1}v_i w_i}{\sqrt{\sum ^ N_{i=1}v_i ^ 2}\sqrt{\sum ^ N_{i=1}w_i ^ 2}}</script><p>样例：</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109270000427.png" alt="image-20210927000014433" style="zoom:80%;box-shadow:none"></p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109270001875.png" alt="image-20210927000051712" style="zoom:80%;box-shadow:none"></p><h2 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h2><p>TF-IDF（term frequency–inverse document frequency）是一种用于信息检索与数据挖掘的常用<strong>加权</strong>技术。TF是<strong>词频</strong>(Term Frequency)，IDF是<strong>逆文本频率指数</strong>(Inverse Document Frequency)。</p><p>对于单词t在文本d中的<strong>ti-idf值</strong>，如下：</p><script type="math/tex; mode=display">w_{t,d} = tf_{t,d} \times idf_i</script><p>其中，像“the”或“it”的<strong>idf值</strong>将会非常小</p><h3 id="tf的计算方法"><a href="#tf的计算方法" class="headerlink" title="tf的计算方法"></a>tf的计算方法</h3><script type="math/tex; mode=display">tf_{t,d}=count(t,d)</script><p>通常不使用原始数据，我们将其压缩一下：</p><script type="math/tex; mode=display">tf_{t,d}=log_{10}({count(t,d)+1})</script><h3 id="idf的计算方法"><a href="#idf的计算方法" class="headerlink" title="idf的计算方法"></a>idf的计算方法</h3><p>注意df不是指该单词在所有文档中出现的总次数(collection Frequency)，而是指该单词出现在了多少个文档中(Document Frequency)</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109272204110.png" alt="image-20210927220135195" style="zoom:100%;box-shadow:none"></p><script type="math/tex; mode=display">idf_t = log_{10}(\frac{N}{df_t})其中N是总的文本数</script><p>可以注意到，加入一个单词在所有训练的文本中都有出现，那么它的idf就会是0。而出现的频率越低，它的idf就越大。</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109272212407.png" alt="image-20210927221238680" style="zoom:90%;box-shadow:none"></p><h2 id="PMI"><a href="#PMI" class="headerlink" title="PMI"></a>PMI</h2><p>经常会用到PMI（Pointwise Mutual Information，逐点互信息）这个指标来衡量两个事物之间的相关性（比如两个词）：</p><script type="math/tex; mode=display">PMI(w_1,w_2) = log\frac{p(w_1,w_2)}{p(w_1)p(w_2)}</script><p>虽然PMI的取值是负无穷到正无穷，但是取负值是有问题的。</p><p>所以我们用0取代负的PMI，得到PPMI：</p><script type="math/tex; mode=display">PPMI(w_1,w_2) = max(log\frac{p(w_1,w_2)}{p(w_1)p(w_2)},0)</script><h3 id="举例，计算过程"><a href="#举例，计算过程" class="headerlink" title="举例，计算过程"></a>举例，计算过程</h3><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109272228918.png" alt="image-20210927222604844" style="zoom:80%;box-shadow:none"></p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109272228966.png" alt="image-20210927222523541" style="zoom:80%;box-shadow:none"></p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109272228347.png" alt="image-20210927222536175" style="zoom:80%;box-shadow:none"></p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109272228752.png" alt="image-20210927222704853" style="zoom:80%;box-shadow:none"></p><h2 id="Word2vec"><a href="#Word2vec" class="headerlink" title="Word2vec"></a>Word2vec</h2><h3 id="稠密向量"><a href="#稠密向量" class="headerlink" title="稠密向量"></a>稠密向量</h3><p>相比于tf-idf更加稠密，且大部分元素不为零。</p><p>为什么要使用稠密向量：</p><ul><li>维度更小可以更好地用于机器学习(需要调整的权重更少)</li><li>稠密向量可能比显式计数更通用</li><li>维度过大可能拟合到一些噪音。维度更小的向量可以缓解<strong>过拟合</strong>的问题</li><li>更好地获取同义词之间的关系</li><li>实践证明，Word2vec可以做的更好</li></ul><p>获取稠密向量的方法：</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109282237909.png" alt="image-20210927164801858" style="zoom:100%;box-shadow:none"></p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li><p>基于<strong>二进制预测任务</strong>来训练一个<strong>分类器</strong>：w会喜欢出现在c的附近吗？(true/false)</p></li><li><p>寻找到一个中心词$target$，在设定一个窗口大小（如下图为+/-2）下，如果$c$出现在$target$周围，就设为T，否则为F。</p></li><li>我们并不关心这个分类器本身，而是将其权重作为词向量。</li><li><strong>自监督</strong>的学习方式。标签不是人为设置的，而是根据单词是否出现在窗口中自己形成的。c和w之间是非常弱的标签关系(它们可能在某个地方邻近，在其它可能又没有)。</li></ul><blockquote><p>一个简单地例子：</p><p>“她们 夸 吴彦祖 帅 到 没朋友”</p><p>“她们 夸 我 帅 到 没朋友”</p><p>由于“吴彦祖”和“我”使用邻近的词语表示的词向量是非常近似的，所以“我”约等于“吴彦祖”</p></blockquote><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol><li>通过邻居词语context word来获取<strong>正面例子</strong>(true)</li><li>随机获取其他词汇来作为<strong>负面例子</strong>(false)</li><li>训练<strong>逻辑回归分类器</strong>来区分这两种情况</li><li>学习到的权重，最终作为词向量。</li></ol><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109282239534.png" alt="image-20210927165913777" style="zoom:100%;box-shadow:none"></p><p>预测出$P(+|w,c)$的概率。</p><p>如果两个向量是相似的，那么它们的点积是会非常大的。cosine只是一种标准化的点积。所以我们可以直接使用点积来表示相似性：</p><script type="math/tex; mode=display">Similarity(w,c) \approx w · c</script><p>使用逻辑回归分类器中的$\sigma$将其变为概率：</p><script type="math/tex; mode=display">P(+|w,c) = \sigma(c·w) = \frac{1}{1+exp(-c·w)}</script><script type="math/tex; mode=display">P(-|w,c) = 1- P(+|w,c) =\sigma(-c·w) = \frac{1}{1+exp(c·w)}</script><p>上面的公式，只是针对一个context word，但是我们需要针对很多个context word。我们可以假设每个context word之间是相互独立的，所以可以将他们直接乘起来喔：</p><script type="math/tex; mode=display">P(+|w,c_{1:L})=\Pi_{i=1}^ {L} \sigma(c_i · w)</script><script type="math/tex; mode=display">log P(+|w,c_{1:L})=\sum_{i=1}^ {L} log\sigma(c_i · w)</script><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109282336861.png" alt="image-20210928233333561" style="zoom:100%;box-shadow:none"></p><p>学习的目标是：</p><ul><li>最大化正例中的target word和context word之间的相似性</li><li>最小化反例中的target word和non-neighbor word之间的相似性</li></ul><p>可得到损失函数如下：</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109282337596.png" alt="image-20210928233633250" style="zoom:100%;box-shadow:none"></p><p>如何学习？</p><p>使用随机梯度下降法(Stochastic gradient descent)；针对整个训练集，使正例的可能性更大，使反例的可能性更小。</p><p>对于每一步：</p><ul><li>方向：从损失函数的梯度向相反方向移动</li><li>梯度幅值：我们移动的梯度值为$\frac{d}{dw}L(f(x;w),y)$，乘以一个learning rate $\eta$</li><li>learning rate 越大就意味着下降得越快：</li></ul><script type="math/tex; mode=display">w^{t+1} = w^{t}-\eta \frac{d}{dw}L(f(x;w),y)</script><p>转过头来看看，损失函数要怎么求导：</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202110071634380.png" alt="image-20211007163357969" style="zoom:80%;box-shadow:none"></p><p>所以我们可以先随机地初始化$c$和$w$矩阵，然后根据刚刚提到的<strong>梯度下降法</strong>来进行不断地更新：</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202110071636297.png" alt="image-20211007163616109" style="zoom:80%;box-shadow:none"></p><h3 id="总结流程"><a href="#总结流程" class="headerlink" title="总结流程"></a>总结流程</h3><ul><li>以一个随机d维地向量V作为初始词向量</li><li>基于向量的相似度来对分类器进行训练<ul><li>基于一个语料库，将同时出现的一对对词作为<strong>正例</strong></li><li>以不同时出现的一对对词作为<strong>反例</strong></li><li>通过<strong>梯度下降</strong>的方式来训练分类器，最终提高分类器区分这些词向量的性能</li><li>扔掉分类器的代码，仅仅保留词向量(<strong>词嵌入</strong> embeddings)</li></ul></li></ul><h3 id="词嵌入的特性"><a href="#词嵌入的特性" class="headerlink" title="词嵌入的特性"></a>词嵌入的特性</h3><h4 id="1-窗口大小"><a href="#1-窗口大小" class="headerlink" title="1. 窗口大小"></a>1. 窗口大小</h4><ul><li>小窗口$(C=+/-2)$，邻近的单词是同一分类法下语法相似的词。比如Hogwarts和其他虚构学院</li><li>大窗口$(C=+/-5)$，邻近的单词是同一语义领域下的。比如Hogwarts和Dumbledore</li></ul><h4 id="2-类比关系-analogical-relations"><a href="#2-类比关系-analogical-relations" class="headerlink" title="2. 类比关系(analogical relations)"></a>2. 类比关系(analogical relations)</h4><p>使用向量的平行关系来进行类比推理</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202110071854110.png" alt="image-20211007184623878" style="zoom:80%;box-shadow:none"></p><p>对于稀疏的词向量或稠密的词向量都可以使用这种方法：</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202110071854906.png" alt="image-20211007184835881" style="zoom:80%;box-shadow:none"></p><div class="note note-success">            <p>平行四边形法则需要注意的事项：</p><ul><li><p>它似乎只适用于频繁使用的单词、小距离和特定的语言关系（如国家与首都等），但对于其他的无效</p></li><li><p>此外，如何理解类比关系是开放的，多样化的。</p></li></ul>          </div>]]></content>
    
    
    
    <tags>
      
      <tag>自然语言处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(三)Text Classification</title>
    <link href="/Wuhlan3/2021/09/24/Text-Classification/"/>
    <url>/Wuhlan3/2021/09/24/Text-Classification/</url>
    
    <content type="html"><![CDATA[<h1 id="Text-Classification"><a href="#Text-Classification" class="headerlink" title="Text Classification"></a>Text Classification</h1><h2 id="基本任务"><a href="#基本任务" class="headerlink" title="基本任务"></a>基本任务</h2><ul><li><p>识别垃圾邮件(spam)</p></li><li><p>给杂志、论文贴上标签</p></li><li><p>划出句子中的正面、负面的词汇，从而把握整体的情感：</p><p><img src="image-20210915110828809.png" alt="image-20210915110828809" style="zoom: 50%;"></p></li></ul><p>情绪分析(sentiment analysis)包括:</p><ul><li>Movie : is this review positive or negative?</li><li>Products : what do people think about the new iPhone?</li><li>Public sentiment : how is consumer confidence?</li><li>Politics : what do people think about this candidate or issue?</li><li><p>Prediction : predict market trends from sentiment</p><p>情绪分析是对attitude的检测，主要关注两个方面：</p></li></ul><ol><li>positive or negative</li><li>classification</li></ol><h2 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h2><p><strong>Input</strong>:</p><ul><li>a document $d$</li><li>a fixed set of classes $C = {c_1, c_2, c_3…}$</li></ul><p><strong>Output</strong> : </p><ul><li>a predicted class $c\in C$</li></ul><p>简单来说就是确定好几个类别，将新的一个文本分进一个类别。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li><p>手动制定规则：</p><ul><li>基于单词的组合或其他特征（垃圾邮件地下有网址或其中的重复关键句）</li><li>可以非常准确</li><li>但规则制定的过程成本昂贵</li></ul></li><li><p>基于深度学习</p><p>Input:</p><ul><li><p>文档：A document d</p></li><li><p>定义好的一些类：A fixed set of classes $C={c_1,c_2,…,c_n}$</p></li><li><p>训练集：A training set of m hand-labeled documents $(d_1,c_1),…,(d_m,c_m)$</p></li></ul><p>Output:</p><ul><li>分类器：A learned classifier $f: d \rightarrow c$</li></ul></li></ol><p>一些知名的分类器：</p><ul><li>Naïve Bayes</li><li>Logistic regression</li><li>Neural networks</li><li>k-Nearest Neighbors</li></ul><h2 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h2><p>朴素贝叶斯分类器是基于贝叶斯规则的。依赖于一个简单的文档表示方法——Bag of words：</p><p><img src="image-20210919185219007.png" alt="image-20210919185219007" style="zoom:80%;"></p><p>Bag of words中包含每个单词的出现频率，我们可以通过它来计算、学习出一个分类器。</p><p><img src="image-20210919185313308.png" alt="image-20210919185313308" style="zoom:80%;"></p><p>对于一个文档d和一个类c有：</p><script type="math/tex; mode=display">P(c|d)=\frac{P(dc)}{P(d)}=\frac{P(d|c)P(c)}{P(d)}</script><script type="math/tex; mode=display">\begin{align}c_{map}&=argmax_{c\in C}P(c|d) \\\\ &=argmax_{c\in C}\frac{P(d|c)P(c)}{P(d)}\\\\ &=argmax_{c\in C}P(d|c)P(c)\\\\ &=argmax_{c\in C}P(x_1,x_2,...,x_n | c)P(c)\\\\ &c_{NB}=argmax_{c\in C}P(c)\prod_{x_i\in X}P(x_i|c)\\\\ &=argmax_{c\in C}\big[logP(c)+\sum_{i\in positions}logP(x_i|c)\big]\end{align}</script><p>上面的公式中：</p><ul><li>map指的是maximum a posteriori最大后验概率，即我们要找出一个最大可能的类；</li><li>由于所有类的算出的$c_{map}$的分母都是$P(d)$，所以可以省去</li><li>$P(c)$是先验概率，即某一个类的出现概率</li><li>如何估算$P(x_1,x_2,…,x_n | c)$，我们可以假设单词的位置、顺序是无关紧要的，且假设$P(x_i|c)$之间相互独立，则我们可以得到最后一条式子。</li><li>positions指的是所有单词再文本中的位置</li><li>考虑小数精度问题、计算的方便性，我们可以取log</li></ul><h2 id="Learning"><a href="#Learning" class="headerlink" title="Learning"></a>Learning</h2><p>在上面的式子中，主要求两个值：$P(c)$和$P(x_i|c)$</p><p>我们可以单纯的使用单词出现的频率来表示这两个值：</p><script type="math/tex; mode=display">\hat P(c_j) = \frac{N_{c_j}}{N_{total}}\\\hat P(w_i|c_j)=\frac{count(w_i,c_j)}{\sum_{w\in V}count(w,c_j)}</script><p>考虑有的单词没有出现在训练集中，可能出现P等于0的情况，所以需要进行拉普拉斯平滑：</p><script type="math/tex; mode=display">\hat P(w_i|c_j)=\frac{count(w_i,c_j)+1}{\sum_{w\in V}count(w,c_j)+|V|}</script><h2 id="Unknown-words"><a href="#Unknown-words" class="headerlink" title="Unknown words"></a>Unknown words</h2><p>对于在测试集中出现了我们训练集中没有遇到过的单词怎么办？</p><ul><li>将他们从测试集文档中移除</li><li>假装他们不存在</li><li>Don’t include any probability for them at all</li></ul><h2 id="Stop-words"><a href="#Stop-words" class="headerlink" title="Stop words"></a>Stop words</h2><p>一些系统会忽略掉stop words——非常频繁出现的词汇比如the、a</p><ul><li>在训练集中对所有的单词进行频率的排序</li><li>将出现次数最多的前10~50个单词列入stopword list</li><li>在训练集和测试集中移除这些词语，假装他们从未出现过</li></ul><p>但是移除停用词也未必起到很好的效果，在实践过程中常常使用所有单词而不会设置stopword list</p><h2 id="实例sentiment-example"><a href="#实例sentiment-example" class="headerlink" title="实例sentiment example"></a>实例sentiment example</h2><p><img src="image-20210919225343885.png" alt="image-20210919225343885" style="zoom: 100%;"></p><p>基本过程总结：</p><ol><li>计算每个类的出现频率</li><li>删除每个文档中的重复项（停用词）</li><li>使用拉普拉斯平滑计算$\hat P(w_i|c_j)$</li><li>计算$c<em>{NB}$或者说$c</em>{MAP}$</li></ol><h3 id="Optimizing-for-sentiment-analysis"><a href="#Optimizing-for-sentiment-analysis" class="headerlink" title="Optimizing for sentiment analysis"></a>Optimizing for sentiment analysis</h3><p>对于情绪分析，似乎单词的出现次数并不能告诉我们更多信息，比如说fantastic出现五次和出现一次没有太大区别。</p><p>所以我们可以将其优化成Binary multinominal Naive B ayes 或者 binary NB：</p><p>即将所有的单词计数记为1。</p><h2 id="Naive-Bayes-Relationship-toLanguage-Modeling"><a href="#Naive-Bayes-Relationship-toLanguage-Modeling" class="headerlink" title="Naïve Bayes: Relationship toLanguage Modeling"></a>Naïve Bayes: Relationship toLanguage Modeling</h2><p>朴素贝叶斯分类器可用于多种分类：URL、email address、字典等</p><p>我们只使用了单词的特征，且使用了文本中所有的单词。</p><p>这与之前文章中<a href="http://localhost:4000/Wuhlan3/2021/09/06/n-gram%E6%A8%A1%E5%9E%8B/">《N-gram语言模型》</a>提到的language modeling中的unigram模型有很多相似之处。</p><h2 id="Precision-Recall-and-F-measure"><a href="#Precision-Recall-and-F-measure" class="headerlink" title="Precision, Recall, and F measure"></a>Precision, Recall, and F measure</h2><p>让我们考虑二进制文本分类任务。</p><p>假设你是戴尔的首席执行官，你想知道人们对你的笔记本电脑的看法，所以你建立了一个“戴尔笔记本电脑”推特检测器：</p><ul><li>正面类：关于戴尔笔记本电脑的推文</li><li>负面类：所有其他推文</li></ul><p><img src="image-20210919231408871.png" alt="image-20210919231408871" style="zoom:100%;"></p><p>我们为什么不把<strong>accuracy</strong>作为衡量标准呢？</p><p>想象一下，我们看到了100万条推特，其中100人谈论戴尔笔记本电脑，999900谈了些别的事<br>我们可以建立一个愚蠢的分类器，只标记每个不关于戴尔笔记本电脑的tweet。</p><p>它将获得99.99%的准确率！！！但是这并不是我们需要寻找的东西。这就是为什么需要引入<strong>precision</strong>和<strong>recall</strong>了。我们使用以下公式来计算</p><script type="math/tex; mode=display">F_{ \beta } = \frac {( {\beta } ^ 2+1)PR}{\beta ^2P+R}</script><p>大部分情况下使用balanced $F_1取\beta=1$</p><script type="math/tex; mode=display">F_{\beta} = \frac{2PR}{P+R}</script><h2 id="交叉测试"><a href="#交叉测试" class="headerlink" title="交叉测试"></a>交叉测试</h2><p><img src="image-20210919233044082.png" alt="image-20210919233044082" style="zoom:100%;"></p><p>在训练集上训练，在development集上调整，在测试集上进行验证、报告：</p><ul><li>相比于在<strong>训练集上调整</strong>这样可以防止过拟合</li><li>但是想要尽可能多的数据进行测试，又有尽可能多的数据作为development该怎么做呢？</li></ul><p><img src="image-20210919233659699.png" alt="image-20210919233659699" style="zoom:100%;"></p>]]></content>
    
    
    
    <tags>
      
      <tag>自然语言处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(二)N-gram模型</title>
    <link href="/Wuhlan3/2021/09/22/n-gram%E6%A8%A1%E5%9E%8B/"/>
    <url>/Wuhlan3/2021/09/22/n-gram%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="N-gram语言模型"><a href="#N-gram语言模型" class="headerlink" title="N-gram语言模型"></a>N-gram语言模型</h1><p><strong>语言模型</strong>：简单来说就是用于判断一个句子是否通顺，我们的目标是要给一个句子赋予一个概率。</p><pre><code class="hljs reasonml"><span class="hljs-comment">//机器翻译</span><span class="hljs-constructor">P(<span class="hljs-params">high</span> <span class="hljs-params">winds</span> <span class="hljs-params">tonite</span>)</span> &gt; <span class="hljs-constructor">P(<span class="hljs-params">large</span> <span class="hljs-params">winds</span> <span class="hljs-params">tonite</span>)</span><span class="hljs-comment">//正确拼写</span><span class="hljs-constructor">P(<span class="hljs-params">about</span> <span class="hljs-params">fifteen</span> <span class="hljs-params">minutes</span> <span class="hljs-params">from</span>)</span> &gt; <span class="hljs-constructor">P(<span class="hljs-params">about</span> <span class="hljs-params">fifteen</span> <span class="hljs-params">minuets</span> <span class="hljs-params">from</span>)</span><span class="hljs-comment">//语言识别</span><span class="hljs-constructor">P(I <span class="hljs-params">saw</span> <span class="hljs-params">a</span> <span class="hljs-params">van</span>)</span> &gt;&gt; <span class="hljs-constructor">P(<span class="hljs-params">eyes</span> <span class="hljs-params">awe</span> <span class="hljs-params">of</span> <span class="hljs-params">an</span>)</span></code></pre><p>可以提炼成两个问题：</p><ul><li>最终问题：计算一个句子或一系列单词的概率$P(W)=P(w_1,w_2,w_3,w_4…w_n)$</li><li>相关问题：预测下一个单词出现的概率$P(w_n | w_1,w_2,w_3…w_n-1)$</li></ul><blockquote><p>将概率最大的作为预测结果返回。再比如机器翻译中，‘I like Tom so much.’ ===&gt;{‘我’，‘喜欢’，‘汤姆’，‘非常’} 将这个集合里的字词排列组合成句子，然后用语言模型去计算形成句子的概率大小。概率越大，说明翻译越顺畅，越好，就作为最终的答案返回。</p></blockquote><p><img src="image-20210906214136251.png" alt="image-20210906214136251" style="zoom: 50%;"></p><h1 id="Markov-Assumption"><a href="#Markov-Assumption" class="headerlink" title="Markov Assumption"></a>Markov Assumption</h1><p>我们一般不会这样判断：</p><p>$P(the|its\ water\ is\ so\ transparent\ that)=\frac{Count(its\ water\ is\ so\ transparent\ that\ the)}{Count(its\ water\ is\ so\ transparent\ that)}$</p><p>因为涉及到太多可能的句子了。</p><p>直接这么计算，是有很大困难的，我们可以将其简化为求：</p><p>$P(the|its\ water\ is\ so\ transparent\ that)∪P(the|that)$</p><p>或者：<br>$P(the|its\ water\ is\ so\ transparent\ that)∪P(the|transparent\ that)$</p><p>这里引入的就是<strong>马尔科夫假设，即：一个item的出现概率，只与其前m个items有关，当m=0时，就是unigram，m=1时，是bigram模型。</strong></p><p>$P(w<em>1w_2w_3…w_n)=\prod</em>{i=1}^{n}P(w<em>i|w_1w_2w_3…w</em>{i-1})$ </p><ul><li>unigram模型：$P(w<em>1w_2w_3…w_n)=\prod</em>{i=1}^{n}P(w_i)$ </li><li>bigram模型：$P(w<em>i|w_1w_2w_3…w</em>{n-1})\approx P(w<em>i|w</em>{i-1})$ </li></ul><div class="note note-success">            <p><strong>局限性</strong>：比如说，两个词语有长距离依赖关系时，起不了作用。</p>          </div><h2 id="计算流程"><a href="#计算流程" class="headerlink" title="计算流程"></a>计算流程</h2><pre><code class="hljs plain">数出现的频数——&gt;建表——&gt;计算某个句子的概率</code></pre><p><img src="image-20210906224947161.png" alt="image-20210906224947161" style="zoom: 67%;"></p><p><img src="image-20210906173428485.png" alt="image-20210906173428485" style="zoom: 50%;"></p><p>由于句子可能会很长，这个概率就会变得非常小，可能会出现下界(underflow)的问题。所以可以修改直接相乘为log相加：$log(p_1·p_2·p_3·p_4)=logp_1+logp_2+logp_3+logp_4$</p><p><strong>两个工具包</strong>：</p><p><a href="http://www.speech.sri.com/projects/srilm/">http://www.speech.sri.com/projects/srilm/</a></p><p><a href="https://kheafield.com/code/kenlm/">https://kheafield.com/code/kenlm/</a></p><h2 id="效果评估"><a href="#效果评估" class="headerlink" title="效果评估"></a>效果评估</h2><pre><code class="hljs angelscript">一般方法是：<span class="hljs-number">1.</span> 在训练集(training <span class="hljs-keyword">set</span>)中训练我们的模型参数<span class="hljs-number">2.</span> 使用区别于训练集的数据集作为测试集(test <span class="hljs-keyword">set</span>)<span class="hljs-number">3.</span> 评估指标告诉我们模型在测试集上的表现如何比较两个模型A和B的最佳评估方法是：<span class="hljs-number">1.</span> 将每个模型放入一个任务中——拼写校正器、语音识别器、机器翻译系统<span class="hljs-number">2.</span> 运行任务，获得A和B的精度，包括  o 正确纠正了多少拼写错误的单词  o 有多少单词翻译正确<span class="hljs-number">3.</span> 比较A和B的精确度</code></pre><p>Shannon Game：香农游戏。即给出前面n个单词，猜出第n+1个单词。</p><p><strong>困惑度</strong>（Perplexity）。PPL是用在自然语言处理领域（NLP）中，衡量语言模型好坏的指标。</p><p><img src="image-20210906175128920.png" alt="image-20210906175128920" style="zoom:50%;"></p><h2 id="Generalization-and-Zeros"><a href="#Generalization-and-Zeros" class="headerlink" title="Generalization and Zeros"></a>Generalization and Zeros</h2><p>如果出现从未见到过的单词，就可能出现0除的情况，困惑度无法计算。所以我们引入<strong>Laplace Smoothing</strong>。</p><p>每个部分减去一点点，分给所有没有出现过的情况。或者称为<strong>加1法</strong>（在出现次数表里，设置所有的初始值为1）。</p><p><img src="image-20210906175721810.png" alt="image-20210906175721810" style="zoom:50%;"></p><p><img src="image-20210906175734929.png" alt="image-20210906175734929" style="zoom: 50%;"></p><p><img src="image-20210906230732145.png" alt="image-20210906230732145" style="zoom: 67%;"></p><p><img src="image-20210906230755996.png" alt="image-20210906230755996" style="zoom: 80%;"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://www.jianshu.com/p/e91f061d6d91">https://www.jianshu.com/p/e91f061d6d91</a></p><p>[2] 权小军 nlp课程</p>]]></content>
    
    
    
    <tags>
      
      <tag>自然语言处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(一)Introduction and Tokenization</title>
    <link href="/Wuhlan3/2021/09/20/tokenization/"/>
    <url>/Wuhlan3/2021/09/20/tokenization/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>自然语言处理（Natural language processing，NLP）是<strong>语言学</strong>、<strong>计算机科学</strong>和<strong>人工智能</strong>的一个分支领域，研究计算机与人类语言之间的关系、相互作用，特别是如何编程计算机来<strong>处理</strong>和<strong>分析自然语言数据</strong>。</p><p>目标：使计算机能够理解文本的内容，包括上下文之间的细微差别(contextual nuances)</p><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109261720623.png" alt="image-20210926171930451" style="zoom:80%;box-shadow: none"></p><h2 id="NLP的一些难题"><a href="#NLP的一些难题" class="headerlink" title="NLP的一些难题"></a>NLP的一些难题</h2><p>Difficulty 1: Ambiguty</p><ul><li>Lexical ambiguity：词汇歧义——门把手弄坏了</li><li>Part-of-speech ambiguity：词性歧义——Time flies like an arrow.</li><li>Structural ambiguity：结构歧义——关于鲁迅的文章 。</li></ul><p>Difficulty 2: unknown language phenomena</p><ul><li>新的术语、人名、地名——裸退、非典</li><li>新的含义——苹果、凡尔赛</li><li>新的语法——百度一下、Google it</li></ul><h2 id="NLP的应用场景"><a href="#NLP的应用场景" class="headerlink" title="NLP的应用场景"></a>NLP的应用场景</h2><ul><li>Information Retrieval：百度、Google、Bing</li><li>Text Generation :九歌——人工智能诗歌写作系统</li><li>Machine Translation：百度翻译、谷歌翻译</li><li>Question Answering &amp; Dialogue Systems：天猫精灵、小度</li><li>Knowledge Graph</li><li>Automatic Summarization</li><li>Sentiment Analysis</li><li>…</li></ul><h2 id="Corpora"><a href="#Corpora" class="headerlink" title="Corpora"></a>Corpora</h2><p>corpora语料库，是可以是单个文档或多个文档的集合</p><p>一个text是由这些组成的：</p><ul><li>特定的作者</li><li>特定的事件</li><li>特定的类型</li><li>特定的语言</li><li>特定的功能</li></ul><p>语言不是凭空出现的，所以我们需要语料库来进行学习。</p><h2 id="Text-Normalization"><a href="#Text-Normalization" class="headerlink" title="Text Normalization"></a>Text Normalization</h2><p>所有自然语言处理都涉及到文本的规范化：</p><ul><li>Tokenizing words</li><li>Normalizing word formats</li><li>Segmenting sentences</li></ul><h3 id="Tokenization"><a href="#Tokenization" class="headerlink" title="Tokenization"></a>Tokenization</h3><p>简单的方法：</p><ol><li>根据space characters来划分</li></ol><p>使用Unix/Linux的工具来进行space-based tokenization</p><pre><code class="hljs shell">tr -sc ’A Za z’ ’ n’ &lt; shakes.txt | headtr ‘A Z’ ‘a z ’ &lt; shakes.txt | tr sc ‘A Za z’ ‘ n’ | sort | uniq ctr ‘A Z’ ‘a z ’ &lt; shakes.txt | tr sc ‘A Za z’ ‘ n’ | sort | uniq c | sort n r</code></pre><ol><li>当然，不能仅仅依靠标点符号来划分</li></ol><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109261826405.png" alt="image-20210926182526049" style="zoom:80%;box-shadow: none"></p><ol><li>还有很多语言，比如说中文和日文是不使用空格来分隔单词的，那么又该如何划分呢？</li></ol><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109261845190.png" alt="image-20210926184536649" style="zoom:80%;box-shadow: none"></p><ol><li>使用数据来进行划分</li></ol><p>常用算法有：</p><ul><li>Byte Pair Encoding (BPE)</li><li>Unigram language modeling tokenization</li><li>WordPiece (Schuster and Nakajima,</li></ul><p>它们都具有两个部分：</p><ol><li>token learner：以一套原始的语料库进行学习并生成一个词汇表</li><li>token segmenter：根据词汇表来对一个测试句子进行划分</li></ol><h3 id="BPE-token-learner"><a href="#BPE-token-learner" class="headerlink" title="BPE token learner"></a>BPE token learner</h3><p>基本步骤：</p><ol><li>词汇表记录所有的单独的字符</li><li>循环：<ul><li>选择两个在训练语料库中出现频率最高的相邻符号（say ‘A’,’B’）</li><li>将一个新的’AB’加入词汇表</li><li>取代所有相邻的’A’和’B’</li></ul></li><li>直到有k个合并完成</li></ol><p>由于大部分subword算法都是基于空格的划分，所以我们常常先向词汇表加入一个符号’_’</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="image-20210926185638796.png" alt="image-20210926185638796" style="zoom:80%;box-shadow: none"></p><p><img src="image-20210926185728642.png" style="zoom:80%;box-shadow: none"></p><p><img src="image-20210926185744391.png" style="zoom:80%;box-shadow: none"></p><p><img src="image-20210926185803240.png" style="zoom:80%;box-shadow: none;"></p><h3 id="Normalizing-word-formats"><a href="#Normalizing-word-formats" class="headerlink" title="Normalizing word formats"></a>Normalizing word formats</h3><ul><li>U.S.A. or USA</li><li>uhhuh or uh-huh</li><li>Fed or fed</li><li>am, is, be, are</li></ul><p>Lemmatization：转换为lemma词根</p><p>Stemming：将单词后缀删去，化繁为简</p><h2 id="小项目"><a href="#小项目" class="headerlink" title="小项目"></a>小项目</h2><p>使用python进行网页的爬取、分词、写入excel表格。<br>URL: <a href="https://news.ifeng.com/c/89TNORdIths">https://news.ifeng.com/c/89TNORdIths</a><br>Crawler: <a href="www.topcoder.com/thrive/articles/web">www.topcoder.com/thrive/articles/web</a> crawler in python<br>Chinese word tokenization: <a href="https://github.com/fxsjy/jieba">https://github.com/fxsjy/jieba</a></p><p>总体来说不算难，根据爬虫和结巴两个包的示范代码，进行稍微的修改就可以实现了。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> lxml<span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<span class="hljs-keyword">from</span> xlwt <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> jiebaworkbook = Workbook(encoding = <span class="hljs-string">'utf-8'</span>)table = workbook.add_sheet(<span class="hljs-string">'data'</span>)table.write(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'URL'</span>)table.write(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'Title'</span>)table.write(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'Content'</span>)url = <span class="hljs-string">"https://news.ifeng.com/c/89TNORdIths"</span>headers = {  <span class="hljs-string">'User-Agent'</span>: <span class="hljs-string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36'</span>}f = requests.get(url, headers = headers)<span class="hljs-comment">#开始获取html</span>soup = BeautifulSoup(f.content, <span class="hljs-string">'lxml'</span>)<span class="hljs-comment">#往excel写入URL</span>table.write(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, url)<span class="hljs-comment">#获取标题</span>heading = soup.find(<span class="hljs-string">'h1'</span>, {    <span class="hljs-string">'class'</span>: <span class="hljs-string">'topic-2Eq5D0Zm'</span>  })head_list = jieba.cut(heading.string.strip(<span class="hljs-string">'&lt;h1&gt;'</span>), cut_all=<span class="hljs-literal">False</span>)token_heading = <span class="hljs-string">"/ "</span>.join(head_list)print(token_heading)  table.write(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, token_heading)<span class="hljs-comment">#获取文章</span>article = <span class="hljs-string">""</span> paragraphs = soup.find(<span class="hljs-string">'div'</span>, {    <span class="hljs-string">'class'</span>: <span class="hljs-string">'main_content-28C-Fj2p'</span>  }).find_all(<span class="hljs-string">'p'</span>)num = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> paragraph <span class="hljs-keyword">in</span> paragraphs:  article = article + paragraph.string.strip(<span class="hljs-string">'&lt;p&gt;'</span>)seg_list = jieba.cut(article, cut_all=<span class="hljs-literal">False</span>)token_article = <span class="hljs-string">"/ "</span>.join(seg_list)print(token_article) table.write(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, token_article)workbook.save(<span class="hljs-string">'text_token.xls'</span>)</code></pre><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><p><img src="https://wuhlan3-1307602190.cos.ap-guangzhou.myqcloud.com/img/202109261914148.png" alt="image-20210926191356508" style="zoom:80%;box-shadow: none"></p>]]></content>
    
    
    
    <tags>
      
      <tag>自然语言处理</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>死水</title>
    <link href="/Wuhlan3/2021/09/17/%E6%AD%BB%E6%B0%B4/"/>
    <url>/Wuhlan3/2021/09/17/%E6%AD%BB%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<p></p><center><h3>死水</h3></center><center>这是一滩死水，</center><center>绝望得没有一丝生机，</center><center>平静得没有半点漪沦，</center><center>仅有盐绣出几朵白花。</center><br><center>任凭他人称它为“天空之镜”，</center><center>说它包容万象也好，</center><center>说它善于模仿也罢，</center><center>它终究是一滩死水，</center><center>没有一丝生机。</center><br><center>鸟儿的啼声划破天际，</center><center>离开时不带一点犹豫。</center><center>然而，</center><center>人呐，</center><center>争先恐后地用身上的色彩为它点缀，</center><center>看他们造出个什么世界。</center><br><br><p></p><blockquote><p>自然不敢与闻一多先生的《死水》相提并论。</p><p>这是我人生中最宝贵的一次旅行——毕业旅行，当时确确实实为眼前的景象所触动。</p><p>凌晨时分，寒风凛冽，我们一行人赶往景点希望迎来一场日出。眼前的景象却令我有些失望。茶卡盐湖的浓度非常高，能在里面生存的生物少之又少。它是死的，就那么静静地躺在那里。相比于气势磅礴、汹涌澎湃的大江大河，我觉得茶卡盐湖有一股小家子气。</p><p>当时茶卡盐湖貌似也是网红打卡景点，红色的裙子与冷清的环境形成强烈对比，更能显出女孩子们的美丽。</p><p>诗的最后一句既有着我对于网红景点、跟风……的厌恶；又有着一丝欣喜，似乎也因为人们的到来给这个冰冷死寂的环境带来了生机。这是一种自然而又矛盾的心态，不必说非得找出个答案。</p><p>这首诗就像是自己的孩子一样，不管它是好是坏都值得珍爱。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>不务正业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0-1字典树解决[不含连续1的非负整数]</title>
    <link href="/Wuhlan3/2021/09/11/0-1%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    <url>/Wuhlan3/2021/09/11/0-1%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="不含连续1的非负整数"><a href="#不含连续1的非负整数" class="headerlink" title="不含连续1的非负整数"></a><a href="https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/">不含连续1的非负整数</a></h2><p>在该链接的基础上添加自己的理解<a href="https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/solution/suan-fa-xiao-ai-wo-lai-gei-ni-jie-shi-qi-4nh4/">https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/solution/suan-fa-xiao-ai-wo-lai-gei-ni-jie-shi-qi-4nh4/</a></p><p><img src="image-20210911231521950.png" alt="image-20210911231521950"></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findIntegers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{        <span class="hljs-comment">//初始化一棵树，直接使用动态规划计算每一层的 所求整数</span>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">31</span>)</span></span>;        dp[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">31</span>; ++i) {            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];        }        <span class="hljs-comment">//pre用于记录上一层的值:0或1</span>        <span class="hljs-comment">//res用于返回</span>        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">29</span>; i &gt;= <span class="hljs-number">0</span>; --i) {            <span class="hljs-keyword">int</span> val = <span class="hljs-number">1</span> &lt;&lt; i;<span class="hljs-comment">//取某一位</span>            <span class="hljs-keyword">if</span> ((n &amp; val) != <span class="hljs-number">0</span>) {<span class="hljs-comment">//判断是否与这一位有关，即该层是否有右子树</span>                                n -= val;<span class="hljs-comment">//清除这一位</span>                res += dp[i + <span class="hljs-number">1</span>];<span class="hljs-comment">//有右子树的时候，把左子树的相关值添加到res</span>                                <span class="hljs-comment">//如果上一层为1且该层为1，则直接结束遍历</span>                <span class="hljs-keyword">if</span> (pre == <span class="hljs-number">1</span>) {                    <span class="hljs-keyword">break</span>;                }                pre = <span class="hljs-number">1</span>;            } <span class="hljs-keyword">else</span> {<span class="hljs-comment">//若无右子树，则进入左子树，到下一层继续判断</span>                pre = <span class="hljs-number">0</span>;            }            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) {                ++res;            }        }        <span class="hljs-keyword">return</span> res;    }};</code></pre><h2 id="关于如何使用graphviz绘制二叉树"><a href="#关于如何使用graphviz绘制二叉树" class="headerlink" title="关于如何使用graphviz绘制二叉树"></a>关于如何使用graphviz绘制二叉树</h2><h3 id="下载方式"><a href="#下载方式" class="headerlink" title="下载方式"></a>下载方式</h3><p>linux:</p><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> install graphviz</code></pre><p>windows:</p><p><a href="https://www.graphviz.org/download/">https://www.graphviz.org/download/</a></p><h3 id="绘制方式"><a href="#绘制方式" class="headerlink" title="绘制方式"></a>绘制方式</h3><p>测试程序：</p><pre><code class="hljs xl">digraph binaryTree{    node[shape=<span class="hljs-built_in">circle</span>,<span class="hljs-built_in">color</span>=red,fontcolor=blue,fontsize=<span class="hljs-number">10</span>];    root[<span class="hljs-built_in">color</span>=blue,fontcolor=black,fontsize=<span class="hljs-number">20</span>];    <span class="hljs-function"><span class="hljs-title">root</span>-&gt;</span>a[style=dotted];    <span class="hljs-function"><span class="hljs-title">root</span>-&gt;</span>b;    <span class="hljs-function"><span class="hljs-title">a</span>-&gt;</span>c;    <span class="hljs-function"><span class="hljs-title">a</span>-&gt;</span>d;    <span class="hljs-function"><span class="hljs-title">b</span>-&gt;</span>e;    <span class="hljs-function"><span class="hljs-title">b</span>-&gt;</span>f;}</code></pre><p>linux直接在终端输入/windows需要加入环境变量，在cmd输入：</p><pre><code class="hljs cmd">dot -Tpng -o <span class="hljs-built_in">tree</span>.png test.dot</code></pre><h3 id="生成效果"><a href="#生成效果" class="headerlink" title="生成效果"></a>生成效果</h3><p><img src="tree.png" alt="tree"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/62777936">https://zhuanlan.zhihu.com/p/62777936</a></p><p>[2] <a href="https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/solution/suan-fa-xiao-ai-wo-lai-gei-ni-jie-shi-qi-4nh4/">https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/solution/suan-fa-xiao-ai-wo-lai-gei-ni-jie-shi-qi-4nh4/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【置顶】Hexo更新日志</title>
    <link href="/Wuhlan3/2021/09/09/Hexo%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"/>
    <url>/Wuhlan3/2021/09/09/Hexo%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h2 id="一、添加emoji显示功能"><a href="#一、添加emoji显示功能" class="headerlink" title="一、添加emoji显示功能"></a>一、添加emoji显示功能</h2><pre><code class="hljs applescript">npm un hexo-renderer-marked <span class="hljs-comment">--save</span>npm i hexo-renderer-markdown-<span class="hljs-keyword">it</span> <span class="hljs-comment">--save</span>npm install markdown-<span class="hljs-keyword">it</span>-emoji <span class="hljs-comment">--save</span></code></pre><p>一般需要卸载原来的插件，但是我发现我的文件夹里并没有<code>hexo-renderer-marked</code>也就没有删了。</p><p>在_config.yml中添加以下代码：</p><pre><code class="hljs yml"><span class="hljs-attr">markdown:</span>  <span class="hljs-attr">render:</span>    <span class="hljs-attr">html:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">xhtmlOut:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">breaks:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">linkify:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">typographer:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">quotes:</span> <span class="hljs-string">'“”‘’'</span>  <span class="hljs-attr">plugins:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-abbr</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-footnote</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-ins</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-sub</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-sup</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-emoji</span>  <span class="hljs-comment"># add emoji</span><span class="hljs-comment">#  anchors:</span><span class="hljs-comment">#    level: 2</span><span class="hljs-comment">#    collisionSuffix: 'v'</span><span class="hljs-comment">#    permalink: false</span><span class="hljs-comment">#    permalinkClass: header-anchor</span><span class="hljs-comment">#    permalinkSymbol: ¶</span></code></pre><p>由于那个链接的东西实在是太丑了，我就注释掉了<span class="github-emoji"><span>😣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f623.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>使用<code>:persevere:</code>这样的语法就可以显示上面那个表情啦。具体可以参考<a href="https://www.cnblogs.com/zhaoruiqing/articles/12870209.html">https://www.cnblogs.com/zhaoruiqing/articles/12870209.html</a></p><h2 id="二、添加live2D"><a href="#二、添加live2D" class="headerlink" title="二、添加live2D"></a>二、添加live2D</h2><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> <span class="hljs-comment">--save hexo-helper-live2d</span></code></pre><p>在_config.yml中添加以下代码：</p><pre><code class="hljs yml"><span class="hljs-attr">live2d:</span>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 是否启动</span>  <span class="hljs-attr">scriptFrom:</span> <span class="hljs-string">local</span> <span class="hljs-comment"># 默认</span>  <span class="hljs-attr">pluginRootPath:</span> <span class="hljs-string">live2dw/</span>  <span class="hljs-comment"># 插件在站点上的根目录(相对路径)</span>  <span class="hljs-attr">pluginJsPath:</span> <span class="hljs-string">lib/</span>  <span class="hljs-comment"># 脚本文件相对与插件根目录路径</span>  <span class="hljs-attr">pluginModelPath:</span> <span class="hljs-string">assets/</span>  <span class="hljs-comment"># 模型文件相对与插件根目录路径</span>  <span class="hljs-attr">tagMode:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span>  <span class="hljs-attr">debug:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 调试, 是否在控制台输出日志</span>  <span class="hljs-attr">model:</span>    <span class="hljs-attr">use:</span> <span class="hljs-string">live2d-widget-model-tororo</span>  <span class="hljs-comment">## 模型文件</span>  <span class="hljs-attr">display:</span>    <span class="hljs-attr">position:</span> <span class="hljs-string">right</span> <span class="hljs-comment"># 定位方向 left right top bottom</span>    <span class="hljs-attr">width:</span> <span class="hljs-number">150</span>  <span class="hljs-comment"># 小人宽度</span>    <span class="hljs-attr">height:</span> <span class="hljs-number">300</span> <span class="hljs-comment">#  小人高度</span>    <span class="hljs-attr">hOffset:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># 向 偏移</span>    <span class="hljs-attr">vOffset:</span> <span class="hljs-number">-60</span>  <span class="hljs-comment"># 像 偏移</span>  <span class="hljs-attr">mobile:</span>    <span class="hljs-attr">show:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 手机端是否显示</span>  <span class="hljs-attr">react:</span>    <span class="hljs-attr">opacity:</span> <span class="hljs-number">1.0</span>  <span class="hljs-comment"># 模型透明度</span></code></pre><p>再使用cmd命令下载模型</p><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> live2d-widget-<span class="hljs-keyword">model</span>-tororo</code></pre><p>其他模型可以参考该仓库：<a href="https://github.com/xiazeyu/live2d-widget-models">https://github.com/xiazeyu/live2d-widget-models</a></p><p>在根目录里新建一个文件夹<code>live2d_models</code>，然后把模型放进去即可</p><h2 id="三、添加音乐播放器（具有收入侧栏的功能）"><a href="#三、添加音乐播放器（具有收入侧栏的功能）" class="headerlink" title="三、添加音乐播放器（具有收入侧栏的功能）"></a>三、添加音乐播放器（具有收入侧栏的功能）</h2><p>事实上，我选用的主题fluid自带有aplayer音乐播放器</p><pre><code class="hljs yml"><span class="hljs-attr">aplayer:</span>  <span class="hljs-comment"># 音乐播放器，注意不能与 hexo-tag-aplayer 插件共用</span>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">autoplay:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 音频自动播放</span>  <span class="hljs-attr">loop:</span> <span class="hljs-string">'all'</span>  <span class="hljs-comment"># 音频循环播放, 可选值: 'all', 'one', 'none'</span>  <span class="hljs-attr">order:</span> <span class="hljs-string">'random'</span>  <span class="hljs-comment"># 播放顺序，可选值: 'list', 'random'</span>  <span class="hljs-attr">theme:</span> <span class="hljs-string">'#b7daff'</span>  <span class="hljs-comment"># 主题色</span>  <span class="hljs-attr">songs:</span>  <span class="hljs-comment"># 歌曲列表，必须传入下列各参数，其中 url 与 cover 在本地需存于 source 目录，更多参数见文档：https://aplayer.js.org/#/zh-Hans/?id=%E5%8F%82%E6%95%B0</span>    <span class="hljs-bullet">-</span> { <span class="hljs-attr">name:</span> <span class="hljs-string">'Flaming'</span>, <span class="hljs-attr">artist:</span> <span class="hljs-string">'郑晟河'</span>, <span class="hljs-attr">url:</span> <span class="hljs-string">'/Wuhlan3/mp3/song1.mp3'</span>, <span class="hljs-attr">cover:</span> <span class="hljs-string">'/Wuhlan3/img/song1.jpg'</span> }    <span class="hljs-bullet">-</span> { <span class="hljs-attr">name:</span> <span class="hljs-string">'流れ行く雲'</span>, <span class="hljs-attr">artist:</span> <span class="hljs-string">'岸部真明'</span>, <span class="hljs-attr">url:</span> <span class="hljs-string">'/Wuhlan3/mp3/song2.m4a'</span>, <span class="hljs-attr">cover:</span> <span class="hljs-string">'/Wuhlan3/img/song2.jpg'</span> }    <span class="hljs-bullet">-</span> { <span class="hljs-attr">name:</span> <span class="hljs-string">'奇迹の山'</span>, <span class="hljs-attr">artist:</span> <span class="hljs-string">'岸部真明'</span>, <span class="hljs-attr">url:</span> <span class="hljs-string">'/Wuhlan3/mp3/song3.m4a'</span>, <span class="hljs-attr">cover:</span> <span class="hljs-string">'/Wuhlan3/img/song2.jpg'</span> }    <span class="hljs-bullet">-</span> { <span class="hljs-attr">name:</span> <span class="hljs-string">'Sunflower'</span>, <span class="hljs-attr">artist:</span> <span class="hljs-string">'孙培博'</span>, <span class="hljs-attr">url:</span> <span class="hljs-string">'/Wuhlan3/mp3/song5.mp3'</span>, <span class="hljs-attr">cover:</span> <span class="hljs-string">'/Wuhlan3/img/song3.jpg'</span> }    <span class="hljs-bullet">-</span> { <span class="hljs-attr">name:</span> <span class="hljs-string">'少年の梦'</span>, <span class="hljs-attr">artist:</span> <span class="hljs-string">'岸部真明'</span>, <span class="hljs-attr">url:</span> <span class="hljs-string">'/Wuhlan3/mp3/song4.m4a'</span>, <span class="hljs-attr">cover:</span> <span class="hljs-string">'/Wuhlan3/img/song2.jpg'</span> }    <span class="hljs-bullet">-</span> { <span class="hljs-attr">name:</span> <span class="hljs-string">'like a star'</span>, <span class="hljs-attr">artist:</span> <span class="hljs-string">'Youngso Kim'</span>, <span class="hljs-attr">url:</span> <span class="hljs-string">'/Wuhlan3/mp3/like a star.mp3'</span>, <span class="hljs-attr">cover:</span> <span class="hljs-string">'/Wuhlan3/img/like a star.jpg'</span> }    <span class="hljs-bullet">-</span> { <span class="hljs-attr">name:</span> <span class="hljs-string">'境'</span>, <span class="hljs-attr">artist:</span> <span class="hljs-string">'刘嘉卓'</span>, <span class="hljs-attr">url:</span> <span class="hljs-string">'/Wuhlan3/mp3/境.mp3'</span>, <span class="hljs-attr">cover:</span> <span class="hljs-string">'/Wuhlan3/img/刘嘉卓.jpg'</span> }    <span class="hljs-bullet">-</span> { <span class="hljs-attr">name:</span> <span class="hljs-string">'翼~you are the HERO~'</span>, <span class="hljs-attr">artist:</span> <span class="hljs-string">'押尾コータロー'</span>, <span class="hljs-attr">url:</span> <span class="hljs-string">'/Wuhlan3/mp3/wings.mp3'</span>, <span class="hljs-attr">cover:</span> <span class="hljs-string">'/Wuhlan3/img/押尾.jpg'</span> }</code></pre><p>只需要稍微修改一下参数就<span class="github-emoji"><span>🆗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f197.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>啦，当然，我们会发现，播放器小框框一直显示在左下角，很碍眼。</p><p>通过该路径：<code>\blog\themes\hexo-theme-fluid\source\css</code>，新建一个文件<code>custom.css</code>，在里面放下这段代码即可。</p><pre><code class="hljs css"><span class="hljs-selector-class">.aplayer</span><span class="hljs-selector-class">.aplayer-fixed</span><span class="hljs-selector-class">.aplayer-narrow</span> <span class="hljs-selector-class">.aplayer-body</span> {  <span class="hljs-attribute">left</span>: -<span class="hljs-number">66px</span> <span class="hljs-meta">!important</span>;  <span class="hljs-comment">/* 默认情况下缩进左侧66px，只留一点箭头部分 */</span>}<span class="hljs-selector-class">.aplayer</span><span class="hljs-selector-class">.aplayer-fixed</span><span class="hljs-selector-class">.aplayer-narrow</span> <span class="hljs-selector-class">.aplayer-body</span><span class="hljs-selector-pseudo">:hover</span> {  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;  <span class="hljs-comment">/* 鼠标悬停时左侧缩进归零，完全显示按钮 */</span>}</code></pre><h2 id="四、添加动态效果"><a href="#四、添加动态效果" class="headerlink" title="四、添加动态效果"></a>四、添加动态效果</h2><p>添加动态效果的方法非常简单，在<code>_config.yml</code>中找到该代码块：</p><pre><code class="hljs x86asm"><span class="hljs-symbol">custom_js:</span>  # 指定自定义 <span class="hljs-keyword">js</span> 文件路径，路径是相对 source 目录，如 /<span class="hljs-keyword">js</span>/custom<span class="hljs-number">.</span><span class="hljs-keyword">js</span> 对应存放目录 source/<span class="hljs-keyword">js</span>/custom<span class="hljs-number">.</span><span class="hljs-keyword">js</span>，支持列表    - /<span class="hljs-keyword">js</span>/dongtaicaidai<span class="hljs-number">.</span><span class="hljs-keyword">js</span> # 动态彩带    # - /<span class="hljs-keyword">js</span>/bubble<span class="hljs-number">.</span><span class="hljs-keyword">js</span>  #头部上升气泡    #- //cdn<span class="hljs-number">.</span>jsdelivr<span class="hljs-number">.</span>net/gh/bynotes/texiao/source/<span class="hljs-keyword">js</span>/xiaoxuehua<span class="hljs-number">.</span><span class="hljs-keyword">js</span>     #- //cdn<span class="hljs-number">.</span>jsdelivr<span class="hljs-number">.</span>net/gh/bynotes/texiao/source/<span class="hljs-keyword">js</span>/daxuehua<span class="hljs-number">.</span><span class="hljs-keyword">js</span></code></pre><p>可以直接按照格式调用JS代码，也可以通过本地的路径来调用JS代码</p><p>分享一个小仓库：<a href="https://cdn.jsdelivr.net/gh/bynotes/texiao@latest/source/js/">https://cdn.jsdelivr.net/gh/bynotes/texiao@latest/source/js/</a></p><h2 id="五、添加一言"><a href="#五、添加一言" class="headerlink" title="五、添加一言"></a>五、添加一言</h2><p>详情参考<a href="https://hexo.fluid-dev.com/posts/fluid-hitokoto/">https://hexo.fluid-dev.com/posts/fluid-hitokoto/</a></p><p>值得注意的是，如何进行句子的筛选呢。</p><h4 id="句子类型（参数）"><a href="#句子类型（参数）" class="headerlink" title="句子类型（参数）"></a>句子类型（参数）</h4><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>a</td><td>动画</td></tr><tr><td>b</td><td>漫画</td></tr><tr><td>c</td><td>游戏</td></tr><tr><td>d</td><td>文学</td></tr><tr><td>e</td><td>原创</td></tr><tr><td>f</td><td>来自网络</td></tr><tr><td>g</td><td>其他</td></tr><tr><td>h</td><td>影视</td></tr><tr><td>i</td><td>诗词</td></tr><tr><td>j</td><td>网易云</td></tr><tr><td>k</td><td>哲学</td></tr><tr><td>l</td><td>抖机灵</td></tr><tr><td>其他</td><td>作为 动画 类型处理</td></tr></tbody></table></div><blockquote><p>可选择多个分类，例如： <code>?c=a&amp;c=c</code></p></blockquote><p><img src="image-20210909113524581.png" alt="image-20210909113524581" style="zoom: 67%;"></p><p>在引用一言官网链接的时候，在网址后面添加相关参数即可</p><h2 id="六、对文章进行加密"><a href="#六、对文章进行加密" class="headerlink" title="六、对文章进行加密"></a>六、对文章进行加密</h2><blockquote><p>加入这个功能，会不会违背写博客这个初心呢？</p></blockquote><pre><code class="hljs bash">//安装插件yarn add hexo-blog-encrypt</code></pre><p>修改配置文件</p><pre><code class="hljs yml"><span class="hljs-comment">#文章加密</span><span class="hljs-attr">encrypt:</span>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span></code></pre><p>在文章开头加入一些信息</p><pre><code class="hljs keyvalue">password: XXXXXXmessage: 嘻嘻，有密码才能看喔excerpt: 旧的文章概要abstract: 新的文章概要</code></pre><h2 id="七、将博客搭载到云服务器上"><a href="#七、将博客搭载到云服务器上" class="headerlink" title="七、将博客搭载到云服务器上"></a>七、将博客搭载到云服务器上</h2><h2 id="八、购买域名"><a href="#八、购买域名" class="headerlink" title="八、购买域名"></a>八、购买域名</h2><h2 id="九、HTTP升级为HTTPS"><a href="#九、HTTP升级为HTTPS" class="headerlink" title="九、HTTP升级为HTTPS"></a>九、HTTP升级为HTTPS</h2><p>文章加密在gitee上可以正常运行，但是搭载到服务器上就报错了。</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220418103435172.png" alt="image-20220418103435172"></p><p>参考问题：<a href="https://github.com/D0n9X1n/hexo-blog-encrypt/issues/114">https://github.com/D0n9X1n/hexo-blog-encrypt/issues/114</a></p><p>应该是浏览器认为该操作不安全，所以需要将HTTP升级为HTTPS</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo博客相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【置顶】数据库系统概念</title>
    <link href="/Wuhlan3/2021/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/"/>
    <url>/Wuhlan3/2021/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p><a class="btn" href="https://wuhlan3.gitee.io/Wuhlan3/2021/09/04/数据库系统概念1/" title="title">一、引言</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/Wuhlan3/2021/09/06/数据库系统概念2/" title="title">二、关系型数据库</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/Wuhlan3/2021/09/08/数据库系统概念3/" title="title">三、SQL</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/Wuhlan3/2021/09/18/数据库系统概念4/" title="title">四、中级SQL</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/wuhlan3/2021/09/07/databasehomework1/" title="title">第二章课后习题</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/Wuhlan3/2021/09/16/databasehomework2/" title="title">第三章课后习题</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/Wuhlan3/2021/09/19/databasehomework3/" title="title">第四章课后习题</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/Wuhlan3/2021/09/06/lab2-表、列、索引的创建/" title="title">lab2_表、列、索引的创建</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/Wuhlan3/2021/09/13/lab3-select基础/" title="title">lab3_select基础</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>学习笔记，SQL Server</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>icc和mkl的安装与编译</title>
    <link href="/Wuhlan3/2021/09/01/mkl%E5%AE%89%E8%A3%85%E4%B8%8E%E7%BC%96%E8%AF%91/"/>
    <url>/Wuhlan3/2021/09/01/mkl%E5%AE%89%E8%A3%85%E4%B8%8E%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h2 id="icc的安装"><a href="#icc的安装" class="headerlink" title="icc的安装"></a>icc的安装</h2><ol><li><p>注册intel官网账号，进入该网址安装<a href="https://registrationcenter-download.intel.com/akdlm/irc_nas/17928/l_dpcpp-cpp-compiler_p_2021.3.0.3168_offline.sh">https://registrationcenter-download.intel.com/akdlm/irc_nas/17928/l_dpcpp-cpp-compiler_p_2021.3.0.3168_offline.sh</a></p></li><li><p>在linux中执行：</p><pre><code class="hljs c++">./l_dpcpp-cpp-compiler_p_2021<span class="hljs-number">.3</span><span class="hljs-number">.0</span><span class="hljs-number">.3168</span>_offline.sh#如果没有权限可以chmod +x l_dpcpp-cpp-compiler_p_2021<span class="hljs-number">.3</span><span class="hljs-number">.0</span><span class="hljs-number">.3168</span>_offline.sh./l_dpcpp-cpp-compiler_p_2021<span class="hljs-number">.3</span><span class="hljs-number">.0</span><span class="hljs-number">.3168</span>_offline.sh#或者使用sh命令sh l_dpcpp-cpp-compiler_p_2021<span class="hljs-number">.3</span><span class="hljs-number">.0</span><span class="hljs-number">.3168</span>_offline.sh</code></pre></li><li><p>然后根据图形化界面一步步安装</p></li><li><p>检验是否安装成功</p><pre><code class="hljs elixir">wuhlan3<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:~/Desktop/matrix</span><span class="hljs-variable">$ </span>. /opt/intel/oneapi/setvars.sh:: initializing oneAPI environment ...   <span class="hljs-symbol">bash:</span> BASH_VERSION = <span class="hljs-number">5.0</span>.<span class="hljs-number">17(1</span>)-release:: compiler -- latest:: debugger -- latest:: dev-utilities -- latest:: mkl -- latest:: tbb -- latest:: oneAPI environment initialized ::</code></pre></li></ol><h2 id="mkl的安装"><a href="#mkl的安装" class="headerlink" title="mkl的安装"></a>mkl的安装</h2><p>mkl，即英特尔数学核心函数库Intel Math Kernel Library</p><p>之前不懂oneapi怎么安装，所以先使用apt安装了mkl~<span class="github-emoji"><span>😑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f611.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h3 id="1-直接安装官网上的-sh文件"><a href="#1-直接安装官网上的-sh文件" class="headerlink" title="1.直接安装官网上的.sh文件"></a>1.直接安装官网上的.sh文件</h3><p><a href="https://registrationcenter-download.intel.com/akdlm/irc_nas/17901/l_onemkl_p_2021.3.0.520_offline.sh">https://registrationcenter-download.intel.com/akdlm/irc_nas/17901/l_onemkl_p_2021.3.0.520_offline.sh</a></p><p>与icc的安装方法类似</p><h3 id="2-apt的安装方法"><a href="#2-apt的安装方法" class="headerlink" title="2.apt的安装方法"></a>2.apt的安装方法</h3><pre><code class="hljs shell">cd /tmpwget https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS-2019.PUBsudo sh -c 'echo deb https://apt.repos.intel.com/mkl all main /etc/apt/sources.list.d/intel-mkl.list'sudo apt-get updatesudo apt-get install intel-mkl-64bit-2020.2source /opt/intel/compilers_and_libraries_2020/linux/mkl/bin/mklvars.sh intel64 ilp64</code></pre><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> min(x,y) (((x) &lt; (y)) ? (x) : (y))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"mkl.h"</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">double</span> *A, *B, *C;    <span class="hljs-keyword">int</span> m, n, k, i, j;    <span class="hljs-keyword">double</span> alpha, beta;    <span class="hljs-built_in">printf</span> (<span class="hljs-string">"\n This example computes real matrix C=alpha*A*B+beta*C using \n"</span>            <span class="hljs-string">" Intel(R) MKL function dgemm, where A, B, and  C are matrices and \n"</span>            <span class="hljs-string">" alpha and beta are double precision scalars\n\n"</span>);    m = <span class="hljs-number">2000</span>, k = <span class="hljs-number">200</span>, n = <span class="hljs-number">1000</span>;    <span class="hljs-built_in">printf</span> (<span class="hljs-string">" Initializing data for matrix multiplication C=A*B for matrix \n"</span>            <span class="hljs-string">" A(%ix%i) and matrix B(%ix%i)\n\n"</span>, m, k, k, n);    alpha = <span class="hljs-number">1.0</span>; beta = <span class="hljs-number">0.0</span>;    <span class="hljs-built_in">printf</span> (<span class="hljs-string">" Allocating memory for matrices aligned on 64-byte boundary for better \n"</span>            <span class="hljs-string">" performance \n\n"</span>);    A = (<span class="hljs-keyword">double</span> *)mkl_malloc( m*k*<span class="hljs-keyword">sizeof</span>( <span class="hljs-keyword">double</span> ), <span class="hljs-number">64</span> );    B = (<span class="hljs-keyword">double</span> *)mkl_malloc( k*n*<span class="hljs-keyword">sizeof</span>( <span class="hljs-keyword">double</span> ), <span class="hljs-number">64</span> );    C = (<span class="hljs-keyword">double</span> *)mkl_malloc( m*n*<span class="hljs-keyword">sizeof</span>( <span class="hljs-keyword">double</span> ), <span class="hljs-number">64</span> );    <span class="hljs-keyword">if</span> (A == <span class="hljs-literal">NULL</span> || B == <span class="hljs-literal">NULL</span> || C == <span class="hljs-literal">NULL</span>) {      <span class="hljs-built_in">printf</span>( <span class="hljs-string">"\n ERROR: Can't allocate memory for matrices. Aborting... \n\n"</span>);      mkl_free(A);      mkl_free(B);      mkl_free(C);      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    }    <span class="hljs-built_in">printf</span> (<span class="hljs-string">" Intializing matrix data \n\n"</span>);    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; (m*k); i++) {        A[i] = (<span class="hljs-keyword">double</span>)(i+<span class="hljs-number">1</span>);    }    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; (k*n); i++) {        B[i] = (<span class="hljs-keyword">double</span>)(-i<span class="hljs-number">-1</span>);    }    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; (m*n); i++) {        C[i] = <span class="hljs-number">0.0</span>;    }    <span class="hljs-built_in">printf</span> (<span class="hljs-string">" Computing matrix product using Intel(R) MKL dgemm function via CBLAS interface \n\n"</span>);    cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,                 m, n, k, alpha, A, k, B, n, beta, C, n);    <span class="hljs-built_in">printf</span> (<span class="hljs-string">"\n Computations completed.\n\n"</span>);    <span class="hljs-built_in">printf</span> (<span class="hljs-string">" Top left corner of matrix A: \n"</span>);    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;min(m,<span class="hljs-number">6</span>); i++) {      <span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>; j&lt;min(k,<span class="hljs-number">6</span>); j++) {        <span class="hljs-built_in">printf</span> (<span class="hljs-string">"%12.0f"</span>, A[j+i*k]);      }      <span class="hljs-built_in">printf</span> (<span class="hljs-string">"\n"</span>);    }    <span class="hljs-built_in">printf</span> (<span class="hljs-string">"\n Top left corner of matrix B: \n"</span>);    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;min(k,<span class="hljs-number">6</span>); i++) {      <span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>; j&lt;min(n,<span class="hljs-number">6</span>); j++) {        <span class="hljs-built_in">printf</span> (<span class="hljs-string">"%12.0f"</span>, B[j+i*n]);      }      <span class="hljs-built_in">printf</span> (<span class="hljs-string">"\n"</span>);    }    <span class="hljs-built_in">printf</span> (<span class="hljs-string">"\n Top left corner of matrix C: \n"</span>);    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;min(m,<span class="hljs-number">6</span>); i++) {      <span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>; j&lt;min(n,<span class="hljs-number">6</span>); j++) {        <span class="hljs-built_in">printf</span> (<span class="hljs-string">"%12.5G"</span>, C[j+i*n]);      }      <span class="hljs-built_in">printf</span> (<span class="hljs-string">"\n"</span>);    }    <span class="hljs-built_in">printf</span> (<span class="hljs-string">"\n Deallocating memory \n\n"</span>);    mkl_free(A);    mkl_free(B);    mkl_free(C);    <span class="hljs-built_in">printf</span> (<span class="hljs-string">" Example completed. \n\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><h2 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h2><p>gcc编译方法：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> . /opt/intel/bin/compilervars.sh intel64</span><span class="hljs-meta">$</span><span class="bash"> gcc matrix.c -lmkl_rt</span><span class="hljs-meta">$</span><span class="bash"> ./a.out</span></code></pre><p>icc编译方法：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> . /opt/intel/oneapi/setvars.sh</span><span class="hljs-meta">$</span><span class="bash"> icc -mkl matrix.c</span><span class="hljs-meta">$</span><span class="bash"> ./a.out</span></code></pre><p>使用icc编译器，可以达到性能优化的效果</p><h2 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h2><p>ubuntu虚拟机的磁盘空间不足：</p><ol><li>在VMware那里手动设置磁盘空间</li><li>下载gparted进行分区</li></ol><pre><code class="hljs c++">sudo apt-get install gpartedsudo gparted</code></pre><p><img src="image-20210901102704269.png" alt="image-20210901102704269"></p><p><img src="image-20210901102644127.png" alt="image-20210901102644127"></p>]]></content>
    
    
    
    <tags>
      
      <tag>超算</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Linux高性能服务器》学习笔记</title>
    <link href="/Wuhlan3/2021/08/09/%E3%80%8ALinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%8B%E6%B8%B8%E5%8F%8C%E8%91%97%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/Wuhlan3/2021/08/09/%E3%80%8ALinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%8B%E6%B8%B8%E5%8F%8C%E8%91%97%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><a class="btn" href="https://wuhlan3.gitee.io/wuhlan3/2021/08/10/Linux高性能服务器一/" title="title">一、TCP/IP通信案例：访问Internet上的Web服务器</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/wuhlan3/2021/08/10/Linux高性能服务器二/" title="title">二、Linux服务器程序规范</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/wuhlan3/2021/08/10/Linux高性能服务器三/" title="title">三、高性能服务器程序框架 </a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>linux</tag>
      
      <tag>C/C++</tag>
      
      <tag>Web</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinuxCpp实现Webserver</title>
    <link href="/Wuhlan3/2021/08/06/LinuxCpp%E5%AE%9E%E7%8E%B0Webserver/"/>
    <url>/Wuhlan3/2021/08/06/LinuxCpp%E5%AE%9E%E7%8E%B0Webserver/</url>
    
    <content type="html"><![CDATA[<p><a class="btn" href="https://wuhlan3.gitee.io/wuhlan3/2021/08/06/RAII%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%E7%9A%84%E5%B0%81%E8%A3%85/" title="title">一、RAII与线程函数的封装</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/wuhlan3/2021/08/09/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="title">二、半同步半反应堆线程池</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/wuhlan3/2021/08/09/epoll/" title="title">三、epoll</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/wuhlan3/2021/08/09/%E3%80%8ALinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%8B%E6%B8%B8%E5%8F%8C%E8%91%97%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="title">四、HTTP基础</a></p><p><a class="btn" href="" title="title">五、HTTP报文处理流程</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>C/C++</tag>
      
      <tag>Web</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UNIX网络编程导航</title>
    <link href="/Wuhlan3/2021/08/04/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AF%BC%E8%88%AA/"/>
    <url>/Wuhlan3/2021/08/04/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AF%BC%E8%88%AA/</url>
    
    <content type="html"><![CDATA[<p><a class="btn" href="https://wuhlan3.gitee.io/Wuhlan3/2021/07/29/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/" title="title">一、UNIX网络编程——introduction</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/Wuhlan3/2021/07/29/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/" title="title">二、UNIX网络编程——传输层</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/Wuhlan3/2021/07/30/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/" title="title">三、UNIX网络编程——socket编程</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/Wuhlan3/2021/07/30/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/" title="title">四、UNIX网络编程——TCP编程</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/Wuhlan3/2021/08/03/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89/" title="title">五、UNIX网络编程——echo服务器</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/Wuhlan3/2021/08/04/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89/" title="title">六、UNIX网络编程——I/O复用，select，shutdown，pselect，poll</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/Wuhlan3/2021/08/06/UNIX网络编程（七）/" title="title">七、UNIX网络编程——socket选项</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/Wuhlan3/2021/08/06/UNIX网络编程（八）/" title="title">八、UNIX网络编程——UDP编程</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/Wuhlan3/2021/08/10/UNIX网络编程（九）/" title="title">九、UNIX网络编程——守护进程与inetd超级服务器</a></p><p><a class="btn" href="https://wuhlan3.gitee.io/Wuhlan3/2021/08/10/UNIX网络编程（十）/" title="title">十、UNIX网络编程——高级I/O函数</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>linux</tag>
      
      <tag>C/C++</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础</title>
    <link href="/Wuhlan3/2021/07/27/Linux%E5%9F%BA%E7%A1%80/"/>
    <url>/Wuhlan3/2021/07/27/Linux%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1>Linux</h1><h4 id="一些名词：">一些名词：</h4><ul><li><p>Unix：</p></li><li><p>Minix：</p></li><li><p>GNU：GNU是"GNU’s Not Unix"的递归缩写</p><p>GNU几个重要的软件：</p><ul><li>Emacs</li><li>GNU C（GCC）</li><li>GNU C Library （glibc）</li><li>Bash shell</li></ul></li><li><p>FSF：自由软件基金会（FSF, Free Software Foundation）</p></li><li><p>GPL：通用公共许可证（General Public License, GPL）</p></li><li><p>LGPL：(GNU Lesser General Public License) <em>LGPL</em>是GPL的一个为主要为类库使用设计的开源协议。</p></li><li><p>Open source：</p></li><li><p>POSIX：可携式操作系统接口（Portable Operating System Interface）的缩写，重点在 规范核心与应用程序之间的接口</p></li><li><p>Linux distribution：（Kernel + Softwares + Tools + 可完整安装程序）</p></li><li><p>问：发展Linux distributions的公司那么多，是否每一个都不相同呢？</p><p>答：这就不需要担心了，因为每个Linux distributions使用的kernel都是http://www.kernel.org所释出的，而他们所选择的软件，几乎都是目前很知名的软件，重复性相当的高， 例如网页服务器的Apache，电子邮件服务器的Postfix/sendmail，文件服务器的Samba等等。</p></li><li><p>distributions的分类：</p><table><thead><tr><th></th><th>RPM软件管理</th><th><strong>DPKG</strong> 软件管理</th><th>其他</th></tr></thead><tbody><tr><td>商业公司</td><td>RHEL (Red Hat 公司) SuSE (Micro Focus)</td><td>Ubuntu (CanonicalLtd.)</td><td></td></tr><tr><td>社群单位</td><td>Fedora CentOS OpenSuSE</td><td>Debian B2D</td><td>Gentoo</td></tr></tbody></table></li><li><p>X Window System：X Window即X Window图形用户接口，是一种计算机软件系统和网络协议，提供了一个基础的图形用户界面（GUI）和丰富的输入设备能力联网计算机。</p></li></ul><h2 id="文件权限">文件权限</h2><h3 id="查看权限">查看权限</h3><ul><li>user（用户）</li><li>group（群组）</li><li>others（其他）</li><li>root（万能的神）</li></ul><p>root的相关信息记录在<code>/etc/passwd</code>这个文件内。</p><p>个人的密码则是记录 在<code>/etc/shadow</code>这个文件内。</p><p>Linux所有的群组名称都记录在<code>/etc/group</code>内</p><p>这三个文件 可以说是Linux系统里面帐号、密码、群组信息的集中地。</p><p>使用<code>ls -al</code>可以查看文件的权限信息：</p><pre><code class="hljs cmd">/*类型与权限(permission) 连结数 文件拥有者 文件所属群组 文件大小 最后修改时间 文件名*/wuhlan3@wuhlan3-VMware-Virtual-Platform:~/桌面$ sudo ls -al[sudo] wuhlan3 的密码：总用量 <span class="hljs-number">3768</span>drwxr-xr-x  <span class="hljs-number">3</span> wuhlan3 wuhlan3    <span class="hljs-number">4096</span> <span class="hljs-number">7</span>月  <span class="hljs-number">26</span> <span class="hljs-number">15</span>:<span class="hljs-number">20</span>  .drwx------ <span class="hljs-number">22</span> wuhlan3 wuhlan3    <span class="hljs-number">4096</span> <span class="hljs-number">7</span>月  <span class="hljs-number">27</span> <span class="hljs-number">11</span>:<span class="hljs-number">08</span>  ..-rw-rw-r--  <span class="hljs-number">1</span> wuhlan3 wuhlan3 <span class="hljs-number">3240860</span> <span class="hljs-number">7</span>月  <span class="hljs-number">23</span> <span class="hljs-number">16</span>:<span class="hljs-number">28</span>  <span class="hljs-number">666</span>.mp4drwx------ <span class="hljs-number">16</span> wuhlan3 wuhlan3    <span class="hljs-number">4096</span> <span class="hljs-number">7</span>月  <span class="hljs-number">26</span> <span class="hljs-number">11</span>:<span class="hljs-number">18</span>  ffmpeg-<span class="hljs-number">3</span>.<span class="hljs-number">3</span>.<span class="hljs-number">2</span>-rw-rw-r--  <span class="hljs-number">1</span> wuhlan3 wuhlan3  <span class="hljs-number">226961</span> <span class="hljs-number">7</span>月  <span class="hljs-number">26</span> <span class="hljs-number">10</span>:<span class="hljs-number">39</span>  index.html-rw-rw-r--  <span class="hljs-number">1</span> wuhlan3 wuhlan3  <span class="hljs-number">368871</span> <span class="hljs-number">7</span>月  <span class="hljs-number">26</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>  output.mp4lrwxrwxrwx  <span class="hljs-number">1</span> wuhlan3 wuhlan3      <span class="hljs-number">37</span> <span class="hljs-number">7</span>月  <span class="hljs-number">26</span> <span class="hljs-number">15</span>:<span class="hljs-number">20</span> ' qtcreator' -&gt; /opt/Qt/Tools/QtCreator/bin/qtcreator</code></pre><ol><li><p>第一栏：<strong>类型与权限</strong>，总共有十个字符，第一个字符表示目录、文件或链接文件等：</p><ul><li><p>当为[ d ]则是<strong>目录</strong>，例如上表文件名为“.config”的那一行；</p></li><li><p>当为[ - ]则是<strong>文件</strong>，例如上表文件名为“initial-setup-ks.cfg”那一行；</p></li><li><p>若是[ l ]则表示为<strong>链接文件</strong>（link file）；</p></li><li><p>若是[ b ]则表示为设备文件里面的可供<strong>储存</strong>的周边<strong>设备</strong>（可随机存取设备）；</p></li><li><p>若是[ c ]则表示为设备文件里面的<strong>序列埠</strong>(bu)/<strong>串行端口</strong>设备，例如键盘、鼠标（一次性读取设 备）。</p></li></ul><p>接下来的字符均为“rwx” 的三个参数的组合。其中，[ r ]代表<strong>可读</strong>、[ w ]代表<strong>可写</strong>、[ x ]代表<strong>可执行</strong>。</p><p>第一组为user，第二组为group，第三组为others</p></li><li><p>第二栏：表示有多少文件名链接到此节点（<strong>i-node</strong>）</p></li><li><p>第三栏：表示这个文件（或目录）的“拥有者帐号”</p></li><li><p>第四栏：表示这个文件的所属群组</p></li><li><p>第五栏：为这个文件的容量大小，默认单位为Bytes</p></li><li><p>第六栏：为这个文件的创建日期或者是最近的修改日期</p></li><li><p>第七栏：为这个文件的文件名</p></li></ol><h3 id="修改权限">修改权限</h3><pre><code class="hljs shell">chgrp ：改变文件所属群组chown ：改变文件拥有者chmod ：改变文件的权限, SUID, SGID, SBIT等等的特性    change file mode bits</code></pre><p>由于权限是三个三个一组的，所以我们可以用二进制再转为十进制表示：<code>&gt; r:4 &gt; w:2 &gt; x:1 </code></p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> chmod [-R] xyz 文件或目录</span><span class="hljs-meta">#</span><span class="bash">其中-R用来表示对该目录下的所有文件进行递归地修改权限（Recursive）</span><span class="hljs-meta">#</span><span class="bash">xyz 写做777时，全部权限开启</span></code></pre><h4 id="权限对于文件和文件夹的意义：">权限对于文件和文件夹的意义：</h4><table><thead><tr><th>类型</th><th>内容</th><th>r</th><th>w</th><th>x</th></tr></thead><tbody><tr><td>文件</td><td>详细数据</td><td>读取文件内容</td><td>修改文件内容</td><td>执行文件内容</td></tr><tr><td>文件夹（目录）</td><td>文件名</td><td>读取文件名</td><td>修改文件名</td><td>进入该目录(cd)</td></tr></tbody></table><h4 id="文件类型：">文件类型：</h4><table><thead><tr><th>文件类型</th><th>细分</th><th>备注</th></tr></thead><tbody><tr><td>正规文件（regular file ）</td><td>纯文本文件（ASCII）</td><td>[ - ]</td></tr><tr><td></td><td>二进制档（binary）</td><td>[ - ]</td></tr><tr><td></td><td>数据格式文件（data）</td><td>[ - ]</td></tr><tr><td>目录（directory）</td><td></td><td>[ d ]</td></tr><tr><td>链接文件（link）</td><td></td><td>[ l ]</td></tr><tr><td>设备与设备文件（device）</td><td>区块（block）设备文件</td><td>[ b ]</td></tr><tr><td></td><td>字符（character）设备文件</td><td>[ c ]</td></tr><tr><td>数据接口文件（sockets）</td><td></td><td>[ s ]</td></tr><tr><td>数据输送档（FIFO, pipe）</td><td></td><td>[ p ]</td></tr></tbody></table><div class="note note-success">            <p>Linux的文件是没有所谓的“扩展名”的，一个Linux文件能不能被执行，与他的第一栏的十个属性有关，与文件名根本一点关系都没有。具有“可执行的权限”以及“具有可执行的程序码”是两回事！</p>          </div><h3 id="目录配置">目录配置</h3><p>FHS：Filesystem Hierarchy Standard 。FHS的重点在于规范每个特定的目录下应该要 放置什么样的数据而已。主要分为四种交互作用的形态：shareable, unshareable, static, variable</p><p>事实上，FHS针对目录树架构仅定义出三层目录下面应该放置什么数据而已，分别是下面这 三个目录的定义：</p><ul><li><p>/       （root, 根目录）：与开机系统有关；</p></li><li><p>/usr （unix software resource）：与软件安装/执行有关；</p></li><li><p>/var （variable）：与系统运行过程有关。</p></li></ul><img src="image-20210728103045651.png" alt="image-20210728103045651" style="zoom:100%;"><p>详情可回顾《鸟哥的linux私房菜 第四版》p282</p><h4 id="绝对路径与相对路径">绝对路径与相对路径</h4><p>绝对路径：由根目录<code>/</code>开始写起的文件名或目录名称， 例如 <code>/home/dmtsai/.bashrc</code>；</p><p>相对路径：相对于目前路径的文件名写法。 例如 <code>./home/dmtsai</code> 或 <code>../../home/dmtsai/ </code>等 等。反正开头不是 / 就属于相对路径的写法</p><h2 id="目录">目录</h2><h4 id="特殊的目录">特殊的目录</h4><pre><code class="hljs asciidoc"><span class="hljs-bullet">. </span>代表此层目录 <span class="hljs-bullet">.. </span>代表上一层目录 <span class="hljs-bullet">- </span>代表前一个工作目录 ~ 代表“目前使用者身份”所在的主文件夹 ~account 代表 account 这个使用者的主文件夹（account是个帐号名称）</code></pre><h4 id="处理目录">处理目录</h4><pre><code class="hljs stata"><span class="hljs-keyword">cd</span>：变换目录<span class="hljs-keyword">pwd</span>：显示目前的目录<span class="hljs-keyword">mkdir</span>：创建一个新的目录<span class="hljs-keyword">rmdir</span>：删除一个空的目录</code></pre><h4 id="环境变量PATH">环境变量PATH</h4><p>如下，可以显示当前的所有路径。（PATH 前面加的 $ 表示后面接的是变量，所以会显示出目前的 PATH）</p><pre><code class="hljs cmd">wuhlan3@wuhlan3-VMware-Virtual-Platform:~/桌面$ <span class="hljs-built_in">echo</span> $<span class="hljs-built_in">PATH</span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games</code></pre><p>环境变量配置：</p><pre><code class="hljs cmd">$ <span class="hljs-built_in">PATH</span>="${<span class="hljs-built_in">PATH</span>}:路径名"</code></pre><h2 id="参考资料">参考资料</h2><p>[1]《鸟哥的linux私房菜 第四版》</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/Wuhlan3/2021/07/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/Wuhlan3/2021/07/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="并查集（Union-Find）"><a href="#并查集（Union-Find）" class="headerlink" title="并查集（Union-Find）"></a>并查集（Union-Find）</h2><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="并查集.png" alt="并查集"></p><h3 id="C-模板"><a href="#C-模板" class="headerlink" title="C++模板"></a>C++模板</h3><p>重点是find函数吧，一般情况下将union啥的可以嵌入到具体的实现中加以判断</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFindSet</span>{</span><span class="hljs-keyword">private</span>:        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; f;  <span class="hljs-comment">//表示第i个节点的父节点</span><span class="hljs-keyword">public</span>:    UnionFindSet(<span class="hljs-keyword">int</span> size){        f.resize(size);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;size;i ++){            f[i] = i;        }    }    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>{        <span class="hljs-keyword">if</span>(f[k] == k)<span class="hljs-keyword">return</span> k;        <span class="hljs-keyword">return</span> f[k]  = find(f[k]);      }<span class="hljs-comment">//寻找到根节点</span>    <span class="hljs-comment">//在寻找的过程中，把经过的人的父节点也变为根节点</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>{        <span class="hljs-keyword">int</span> fx = find(x);        <span class="hljs-keyword">int</span> fy = find(y);        <span class="hljs-keyword">if</span>(fx != fy){            f[fy] = fx; <span class="hljs-comment">//合并子集</span>        }    }    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isinoneset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>{        <span class="hljs-keyword">return</span> find(x) == find(y);    }};</code></pre><p>理解了之后，可以再简化一些：</p><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; f;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>{    <span class="hljs-keyword">if</span>(f[x] == x)<span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">return</span> f[x] = find(f[x]);}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">uni</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>{    f[find(y)] = find(x);}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{    f.resize(n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)f[i] = i;}</code></pre><h2 id="已解决问题"><a href="#已解决问题" class="headerlink" title="已解决问题"></a>已解决问题</h2><p>下面的中等题，思路都是非常类似的，一个套路。比较有价值的也就<a href="https://leetcode-cn.com/problems/couples-holding-hands/">情侣牵手</a>这道困难题。</p><p><strong><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/">990. 等式方程的可满足性[中等]</a></strong></p><p><strong><a href="https://leetcode-cn.com/problems/number-of-provinces/">547. 省份数量[中等]</a></strong></p><p><strong><a href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/">1319. 连通网络的操作次数[中等]</a></strong></p><p><strong><a href="https://leetcode-cn.com/problems/number-of-provinces/">547. 省份数量[中等]</a></strong></p><p><strong><a href="https://leetcode-cn.com/problems/couples-holding-hands/">765. 情侣牵手[困难]</a></strong></p><h2 id="较有趣的题：情侣牵手"><a href="#较有趣的题：情侣牵手" class="headerlink" title="较有趣的题：情侣牵手"></a>较有趣的题：情侣牵手</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><code>N</code>对情侣坐在连续排列的<code>2N</code>个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 一次交换可选择任意两人，让他们站起来交换座位。</p><p>人和座位用 0 到 2N-1 的整数表示，情侣们按顺序编号，第一对是 <code>(0, 1)</code>，第二对是<code>(2, 3)</code>，以此类推，最后一对是 <code>(2N-2, 2N-1)</code>。</p><p>这些情侣的初始座位  <code>row[i]</code> 是由最初始坐在第 <code>i</code> 个座位上的人决定的。</p><p>示例 1:</p><pre><code class="hljs angelscript">输入: row = [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>]输出: <span class="hljs-number">1</span>解释: 我们只需要交换row[<span class="hljs-number">1</span>]和row[<span class="hljs-number">2</span>]的位置即可。</code></pre><p>示例 2:</p><pre><code class="hljs angelscript">输入: row = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]输出: <span class="hljs-number">0</span>解释: 无需交换座位，所有的情侣都已经可以手牵手了。</code></pre><p>说明:</p><p><code>len(row)</code>是偶数且数值在 <code>[4, 60]</code>范围内。<br>可以保证<code>row</code>是序列 <code>0...len(row)-1</code> 的一个全排列。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>一开始想到的是：“是不是把两个情侣看作一个连通分量呢？那这样，为什么会用到并查集呢？”</p><p>事实上，这里的<strong>连通分量</strong>是<strong>相互错开的情侣</strong>。下面具体来说一下。</p><p>我们把每一组配对的情侣看作是一个单元，使用i/2作为他们的共同编号：</p><ul><li>假设两组情侣相互交错开了，他们两组之间形成了一个环，那么需要交换1次；</li><li>假设三组情侣相互交错开了，他们三组之间形成了一个环，那么需要交换2次；</li><li>假设四组情侣相互交错开了，他们四组之间形成了一个环，那么需要交换3次；</li><li>…</li></ul><p>把每一个环看作一个连通分量。所以，我们只需要计算情侣之间形成了多少个环，即有多少个集合。</p><p>从头到尾遍历一遍，如果相邻而坐的两个人不是情侣，那么这两个情侣组就处于同一个连通分量中，使用<code>union</code>将他们合并。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; f;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>{        <span class="hljs-keyword">if</span>(x == f[x])<span class="hljs-keyword">return</span> x;        <span class="hljs-keyword">return</span> f[x] = find(f[x]);    }    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">uni</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>{        f[find(x)] = find(y);    }<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSwapsCouples</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; row)</span> </span>{        <span class="hljs-keyword">int</span> n = row.size();        <span class="hljs-keyword">int</span> m = n/<span class="hljs-number">2</span>;        f.resize(m);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)f[i] = i;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span>)uni(row[i] / <span class="hljs-number">2</span>, row[i + <span class="hljs-number">1</span>] / <span class="hljs-number">2</span>);        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {            <span class="hljs-keyword">if</span> (i == find(i)) cnt++;        }        <span class="hljs-keyword">return</span> m - cnt;    }};</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://leetcode-cn.com/leetbook/read/disjoint-set/ovuxje/">https://leetcode-cn.com/leetbook/read/disjoint-set/ovuxje/</a></p><p>[2] <a href="https://leetcode-cn.com/problems/couples-holding-hands/solution/liang-chong-100-de-jie-fa-bing-cha-ji-ta-26a6/">https://leetcode-cn.com/problems/couples-holding-hands/solution/liang-chong-100-de-jie-fa-bing-cha-ji-ta-26a6/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt学习之路（一）</title>
    <link href="/Wuhlan3/2021/07/26/Qt%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/Wuhlan3/2021/07/26/Qt%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="Qt的安装"><a href="#Qt的安装" class="headerlink" title="Qt的安装"></a>Qt的安装</h2><p>我是在kylin-v10的环境下进行下载的，与ubuntu是类似的</p><p>下载地址：<a href="https://download.qt.io/official_releases/qt/">https://download.qt.io/official_releases/qt/</a></p><p>可能需要赋予权限：<code>chmod +x qt-opensource-linux-x64-5.14.2.run</code></p><p>打开安装包：<code>./qt-opensource-linux-x64-5.9.2.run</code></p><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello,world"></a>Hello,world</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QLabel&gt;</span></span><span class="hljs-comment">/*头文件对QApplication类和QLabel进行了声明*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>{    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<span class="hljs-comment">/*创建了QApplication对象，管理整个应用程序*/</span>    QLabel *label = <span class="hljs-keyword">new</span> QLabel(<span class="hljs-string">"Hello,world!"</span>); <span class="hljs-comment">/*窗口部件（widget）*/</span>    label-&gt;show();    <span class="hljs-keyword">return</span> app.exec();}</code></pre><p>成功啦，显示如下：</p><p><img src="image-20210726154217406.png" alt="image-20210726154217406" style="zoom:100%;"></p><p>有意思的，可以在上述程序的基础上添加html标签：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QLabel&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>{    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;    QLabel *label = <span class="hljs-keyword">new</span> QLabel(<span class="hljs-string">"&lt;i&gt;Hello&lt;/i&gt;,&lt;b&gt;world!&lt;/b&gt;"</span>);    label-&gt;show();    <span class="hljs-keyword">return</span> app.exec();}</code></pre><p><img src="image-20210726154105106.png" alt="image-20210726154105106" style="zoom:100%;"></p><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QPushButton&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>{    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;    QPushButton *button = <span class="hljs-keyword">new</span> QPushButton(<span class="hljs-string">"Quit"</span>);    QObject::connect(button, SIGNAL(clicked()), &amp;app, SLOT(quit()));<span class="hljs-comment">/*通过signal来表明一个用户动作的发生或状态的改变，信号与槽slot相连接，执行里面的函数*/</span>    button-&gt;show();    <span class="hljs-keyword">return</span> app.exec();}</code></pre><h3 id="窗口部件的布局"><a href="#窗口部件的布局" class="headerlink" title="窗口部件的布局"></a>窗口部件的布局</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QLabel&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QPushButton&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QHBoxLayout&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>{    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;    QWidget *window = <span class="hljs-keyword">new</span> QWidget;    QLabel *label = <span class="hljs-keyword">new</span> QLabel(<span class="hljs-string">"Hello,world!"</span>);    QPushButton *button = <span class="hljs-keyword">new</span> QPushButton(<span class="hljs-string">"Quit"</span>);    QObject::connect(button, SIGNAL(clicked()), &amp;app, SLOT(quit()));    QHBoxLayout * layout = <span class="hljs-keyword">new</span> QHBoxLayout;    layout-&gt;addWidget(label);<span class="hljs-comment">//将label添加到layout</span>    layout-&gt;addWidget(button);<span class="hljs-comment">//将button添加到layout</span>    window-&gt;setLayout(layout);<span class="hljs-comment">//将layout添加到window</span>    window-&gt;show();    <span class="hljs-keyword">return</span> app.exec();}</code></pre><p><img src="image-20210726162046549.png" alt="image-20210726162046549" style="zoom:100%;"></p><h3 id="将两个widget的值绑定在一起"><a href="#将两个widget的值绑定在一起" class="headerlink" title="将两个widget的值绑定在一起"></a>将两个widget的值绑定在一起</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QLabel&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QPushButton&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QSpinBox&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QSlider&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QHBoxLayout&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>{    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;    QWidget *window = <span class="hljs-keyword">new</span> QWidget;    QSlider *slider = <span class="hljs-keyword">new</span> QSlider(Qt::Horizontal);    QSpinBox *spinBox = <span class="hljs-keyword">new</span> QSpinBox;    spinBox-&gt;setRange(<span class="hljs-number">0</span>,<span class="hljs-number">130</span>);    slider-&gt;setRange(<span class="hljs-number">0</span>,<span class="hljs-number">130</span>);    QObject::connect(spinBox, SIGNAL(valueChanged(<span class="hljs-keyword">int</span>)), slider, SLOT(setValue(<span class="hljs-keyword">int</span>)));    QObject::connect(slider, SIGNAL(valueChanged(<span class="hljs-keyword">int</span>)), spinBox, SLOT(setValue(<span class="hljs-keyword">int</span>)));    spinBox-&gt;setValue(<span class="hljs-number">35</span>);    QHBoxLayout * layout = <span class="hljs-keyword">new</span> QHBoxLayout;    layout-&gt;addWidget(spinBox);    layout-&gt;addWidget(slider);    window-&gt;setLayout(layout);    window-&gt;show();    <span class="hljs-keyword">return</span> app.exec();}</code></pre><p><img src="image-20210726163311497.png" alt="image-20210726163311497" style="zoom:100%;"></p><div class="note note-success">            <p>对connect的理解应该会更加深刻了。可以简单理解为两个组件之间的通信。前两个参数包含组件地址和SIGNAL；后两个参数包含另一个组件地址和SLOT</p>          </div><h2 id="创建对话框"><a href="#创建对话框" class="headerlink" title="创建对话框"></a>创建对话框</h2><p><code>finddialog.h</code>文件</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> FINDDIALOG_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FINDDIALOG_H<span class="hljs-comment">/*防止对这个文件的多重包含*/</span></span><span class="hljs-comment">/*QDialog 由QWidget派生出来*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QDialog&gt;</span></span><span class="hljs-comment">/*声明一些用于对话框实现的Qt类*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QCheckBox</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QLabel</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QLineEdit</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QPushButton</span>;</span><span class="hljs-comment">/*定义FindDialog，并让它称为QDialog的子类*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FindDialog</span> :</span> <span class="hljs-keyword">public</span> QDialog{    Q_OBJECT<span class="hljs-comment">/*对所有的定义得SIGNAL和SLOT类，都需要Q_OBJECT宏*/</span><span class="hljs-keyword">public</span>:    FindDialog(QWidge*parent = <span class="hljs-number">0</span>);<span class="hljs-comment">/*默认为空指针，没有父对象*/</span>signals:<span class="hljs-comment">/*当用户单击Find时，发射两个SIGNAL，如果向前查询生效，则发射findPrevious信号，否则发射findNext信号*/</span>    <span class="hljs-comment">/*signals实际上是一个宏*/</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findNext</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp;str, Qt::CaseSensitivity cs)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findPrevious</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp;str, Qt::CaseSensitivity cs)</span></span>;<span class="hljs-comment">/*Qt::CaseSensitivity是一个枚举类型，具有Qt::CaseSensitive 和 Qt::CaseInsensitive两种取值*/</span><span class="hljs-keyword">private</span> slots:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findClicked</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enableFindButton</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp;text)</span></span>;<span class="hljs-keyword">private</span>:    QLabel *label;    QLineEdit *lineEdit;    QCheckBox *caseCheckBox;    QCheckBox *backwardCheckBox;    QPushButton *findButton;    QPushButton *closeButton;    <span class="hljs-comment">/*没有使用这些类的相关头文件，而是直接声明该类，可以使得编译过程更快*/</span>};<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// FINDDIALOG_H</span></span></code></pre><p>再来看看FindDialog的实现：</p><div class="note note-success">            <p>注意，由于版本的问题，<code>&lt;QtGui&gt;</code>改写为<code>&lt;QtWidgets&gt;</code></p>          </div><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QtWidgets&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"finddialog.h"</span></span><span class="hljs-comment">/*构造函数*/</span>FindDialog::FindDialog(QWidget *parent) : QDialog(parent){    label = <span class="hljs-keyword">new</span> QLabel(tr(<span class="hljs-string">"Find &amp;what:"</span>));<span class="hljs-comment">/*tr()函数的作用时把它翻译成其他语言的标记，在字符串周围使用tr()是一个不错的习惯*/</span>    <span class="hljs-comment">/*&amp;用来表示快捷键。比如使用Alt+F可以用来激活Find*/</span>    lineEdit = <span class="hljs-keyword">new</span> QLineEdit;    label-&gt;setBuddy(lineEdit);<span class="hljs-comment">/*buddy伙伴，在标签按下快捷键时，可以接收到焦点（focus），就会移动到行编辑器上*/</span>    caseCheckBox = <span class="hljs-keyword">new</span> QCheckBox(tr(<span class="hljs-string">"Match &amp;case"</span>));    backwardCheckBox = <span class="hljs-keyword">new</span> QCheckBox(tr(<span class="hljs-string">"Search &amp;backward"</span>));    findButton = <span class="hljs-keyword">new</span> QPushButton(tr(<span class="hljs-string">"&amp;Find"</span>));    findButton-&gt;setDefault(<span class="hljs-literal">true</span>);<span class="hljs-comment">/*指用户按下Enter时，默认按下的按钮*/</span>    findButton-&gt;setEnabled(<span class="hljs-literal">false</span>);<span class="hljs-comment">/*禁用，呈现灰色*/</span>    closeButton = <span class="hljs-keyword">new</span> QPushButton(tr(<span class="hljs-string">"Close"</span>));    connect(lineEdit, SIGNAL(textChanged(<span class="hljs-keyword">const</span> QString &amp;)), <span class="hljs-keyword">this</span>, SLOT(enableFindButton(<span class="hljs-keyword">const</span> QString &amp;)));<span class="hljs-comment">/*当有字符变化时，find按钮启用*/</span>    connect(findButton, SIGNAL(clicked()),<span class="hljs-keyword">this</span>, SLOT(findClicked()));    connect(closeButton, SIGNAL(clicked()),<span class="hljs-keyword">this</span>,SLOT(closed()));<span class="hljs-comment">/*QObject FindDialog 的父对象之一，所以可以省略 connect() 函数前面的 QObject: :前缀*/</span>    QHBoxLayout * topleftLayout = <span class="hljs-keyword">new</span> QHBoxLayout;<span class="hljs-comment">/*打横*/</span>    topleftLayout-&gt;addWidget(label);    topleftLayout-&gt;addWidget(lineEdit);    QVBoxLayout * leftLayout = <span class="hljs-keyword">new</span> QVBoxLayout;<span class="hljs-comment">/*打竖*/</span>    leftLayout-&gt;addLayout(topleftLayout);    leftLayout-&gt;addWidget(caseCheckBox);    leftLayout-&gt;addWidget(backwardCheckBox);    QVBoxLayout * rightLayout = <span class="hljs-keyword">new</span> QVBoxLayout;    rightLayout-&gt;addWidget(findButton);    rightLayout-&gt;addWidget(closeButton);    rightLayout-&gt;addStretch();<span class="hljs-comment">/*分隔符/伸展器，确保按钮占用它们所在布局的上部空间*/</span>    QHBoxLayout * mainLayout = <span class="hljs-keyword">new</span> QHBoxLayout;    mainLayout-&gt;addLayout(leftLayout);    mainLayout-&gt;addLayout(rightLayout);    setLayout(mainLayout);    setWindowTitle(tr(<span class="hljs-string">"Find"</span>));    setFixedHeight(sizeHint().height());}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FindDialog::findClicked</span><span class="hljs-params">()</span></span>{    QString text = lineEdit-&gt;text();    Qt::CaseSensitivity cs = caseCheckBox-&gt;isChecked() ? Qt::CaseSensitive : Qt::CaseInsensitive;    <span class="hljs-comment">/*根据backward的选项来确定往前搜索还是往后搜索*/</span>    <span class="hljs-keyword">if</span>(backwardCheckBox-&gt;isChecked()){        <span class="hljs-function">emit <span class="hljs-title">findPrevious</span><span class="hljs-params">(text, cs)</span></span>;    }<span class="hljs-keyword">else</span>{        emit findNext(text, cs);    }}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FindDialog::enableFindButton</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp;text)</span></span>{    findButton-&gt;setEnabled(!text.isEmpty());}</code></pre><p>main函数：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"finddialog.h"</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>{    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;    FindDialog *dialog = <span class="hljs-keyword">new</span> FindDialog;    dialog-&gt;show();    <span class="hljs-keyword">return</span> app.exec();}</code></pre><p><img src="image-20210727094518994.png" alt="image-20210727094518994" style="zoom:100%;"></p><p>父子关系：</p><p><img src="image-20210727095504820.png" alt="image-20210727095504820" style="zoom:100%;"></p><p>最终实现：</p><p>&lt;/br&gt;</p><center><img src="image-20210726175646948.png" alt="image-20210726175646948" style="zoom:100%;"></center><p></p><h2 id="关于信号与槽"><a href="#关于信号与槽" class="headerlink" title="关于信号与槽"></a>关于信号与槽</h2><ul><li>一个信号可以连接多个槽</li><li>多个信号可以连接同一个槽</li><li>一个信号可以与另外一个信号相连接</li><li>连接可以被移除</li><li>信号与槽的参数必须具有相同的顺序与类型。（信号的参数若多于槽，则多余参数会被忽略）</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《C++ GUI Qt 4 编程（第二版）》《C++ GUI programming with Qt4》电子工业出版社</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>GUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《并行程序设计导论》</title>
    <link href="/Wuhlan3/2021/07/10/%E3%80%8A%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AF%BC%E8%AE%BA%E3%80%8B/"/>
    <url>/Wuhlan3/2021/07/10/%E3%80%8A%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AF%BC%E8%AE%BA%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="并行程序设计导论"><a href="#并行程序设计导论" class="headerlink" title="并行程序设计导论"></a>并行程序设计导论</h1><h2 id="一、为什么需要并行计算"><a href="#一、为什么需要并行计算" class="headerlink" title="一、为什么需要并行计算"></a>一、为什么需要并行计算</h2><h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><p><strong>多核处理器</strong>：单个芯片上多个相对简单的处理器</p><p><strong>单核系统</strong>：只有一个CPU的处理器</p><p><strong>核</strong>：中央处理器、CPU</p><p><strong>通信</strong>：一个或多个核将自己的部分和结果发送给其他的核。</p><p><strong>负载平衡</strong>：简单来说，每个核分配大致相同数目的数据来计算。</p><p><strong>同步</strong>：比如使用<code>Synchronize_cores()</code>，每个核都会再在此处等待，直到所有的核都进入该函数——特别的，必须要等到master核进入该函数。</p><p><strong>共享内存系统</strong>：每个核能够共享访问计算机的内存，能够读、写内存的所有区域</p><p><strong>分布式内存系统</strong>：每个核都有自己的私有内存，核之间的通信是显式的，必须使用类似在网络中发送消息的机制。</p><p><strong>并发</strong>：指两个或多个事件在同一时间间隔内发生。</p><p><strong>并行</strong>：指两个或多个事件在同一时刻发生。（紧耦合）</p><p><strong>分布式</strong>：更多是指通过网络连接多台客户端与服务端进行数据处理。是把海量数据分布在不同的计算机或软件中分别处理的一种软件结构。（与并行类似，松耦合）</p><p>并行程序设计的两个基本方法：</p><ul><li><strong>任务并行</strong></li><li><strong>数据并行</strong></li></ul><p><em>举例子</em>：100个学生的试卷（总共5道题目），5个助教。批改方案有两种：</p><ul><li>每个助教负责给一个问题打分（任务并行）“执行不同的指令”</li><li>试卷分为5叠，每个助教负责一叠试卷（数据并行）“对相似的数据进行评分”</li></ul><h2 id="二、并行硬件和并行软件"><a href="#二、并行硬件和并行软件" class="headerlink" title="二、并行硬件和并行软件"></a>二、并行硬件和并行软件</h2><p>冯·诺依曼结构：<strong>主存</strong>、<strong>中央处理器</strong>（算术逻辑单元ALU+控制单元）、主存和CPU之间的<strong>互连结构</strong>（总线）</p><p>主存和CPU之间的分离，称为<strong>冯·诺依曼瓶颈</strong>。因为互连结构限定了指令和数据访问的速率。（CPU执行指令的速度远远大于从主存中取指令的速度！！！）</p><p><strong>进程</strong>：运行着的程序的一个实例。包括以下实体：</p><ul><li>可执行的机器语言程序</li><li>一块内存空间，包括 代码、栈、堆、其他内存区域</li><li>资源描述符</li><li>安全信息</li><li>进程状态信息（进程控制块PCB）</li></ul><p>大多数现代操作系统都是<strong>多任务</strong>的。即操作系统提供对同时运行多个程序的支持。这对单核系统也是可行的，使用时间片轮转的技术即可。</p><p>线程：线程间的切换比进程间的切换更快，是“轻量级”的。线程包含在进程中，所以线程可以使用相同的可执行代码，共享相同的内存和相同的I/O设备。两个线程之间最大的差别是，他们各自需要一个<strong>私有的程序计数器</strong>和<strong>函数调用栈</strong>，使他们能够独立运行。</p><p>如果进程是执行的“主线程”，其他线程由主线程启动和停止。开始时，子线程从进程中<strong>派生（fork）</strong>出来；一个进程结束后，它会<strong>合并（join）</strong>到进程中。</p><p>对冯诺依曼模型的改进有三种措施：</p><ol><li>缓存（caching）</li><li>虚拟存储器</li><li>低层次并行</li></ol><h4 id="1-Cache基础知识"><a href="#1-Cache基础知识" class="headerlink" title="1.Cache基础知识"></a>1.Cache基础知识</h4><p>高速缓冲存储器（cache）：访问时间比其它存储区域的访问时间短。本书谈到缓存，一般指CPU缓存（CPU Cache）</p><p>在访问完一个内存区域，程序在不久的将来（<strong>时间局部性</strong>），访问邻近的区域（<strong>空间局部性</strong>）</p><p>运用局部性原理，系统使用<strong>更宽</strong>的互连结构（总线）来访问数据和指令。也就是：一次内存访问能存取一整块代码和数据，而不是单条指令和单条数据。这些块称为高速缓冲块或高速缓存行。</p><p>Cache本身也分为三层：第一层（L1）最小但最快、更高层Cache（L2、L3）更大但相对较慢。当CPU访问指令或数据时，它会沿着Cache的层次结构向下查询：首先是L1，接着L2。。。最后是主存。</p><p><strong>命中</strong>与<strong>缺失</strong>是相对Cache层而言的。</p><p><strong>写直达</strong>：当CPU向Cache写数据时，高速缓存行会立即写入主存中</p><p><strong>写回</strong>：数据不是立即更新到主存中，而是将发生数据更新的高速缓存行标记成 <strong>脏（dirty）</strong></p><p>全相联映射：</p><p>直接映射：</p><p>n路组相联：</p><h4 id="2-性能"><a href="#2-性能" class="headerlink" title="2.性能"></a>2.性能</h4><p><strong>线性加速比</strong>：$T<em>{并行} = \frac{1}{p}T</em>{串行}，假设并行为p核系统上进行的$</p><p><strong>加速比</strong>：$S=\frac{T<em>{串行}}{T</em>{并行}}$</p><p><strong>效率</strong>：$E=\frac{S}{p}=\frac{T<em>{串行}}{p*T</em>{并行}}$</p><p><strong>并行开销</strong>：$T<em>{并行} = \frac{1}{p}T</em>{串行} + T_{开销}$</p><p>阿姆达尔定律：大致上，除非一个串行程序的执行几乎全部都并行化，否则，不论有多少可以利用的核，通过并行化产生的加速比都会是受限的。</p><p><strong>可扩展性</strong>：如果增加程序的进程数/线程数，在输入规模也以相应增长率增加的情况下，该程序的效率一直是E。</p><p><strong>强可扩展</strong>：进程线程数增加，不增加问题规模，却可以维持固定的效率。（线程++，问题—，E—）</p><p><strong>弱可扩展</strong>：进程线程数增加，需要增加问题规模，才可以维持固定的效率。（线程++，问题++，E—）</p><h4 id="3-计时"><a href="#3-计时" class="headerlink" title="3.计时"></a>3.计时</h4><p>我们需要记录的是什么时间呢？</p><ol><li>对程序从开始到结束的时间不感兴趣，而对程序的某个部分感兴趣</li><li>对所谓的“CPU时间”不感兴趣。<strong>CPU时间</strong>代表的是程序执行代码的总时间，但是它不包括程序空闲状态的时间！！！</li><li>我们通常使用的是<strong>墙上时钟时间</strong>，即某段代码从开始到结束总耗费的时间。</li></ol><p>不同的API使用的获取时间函数是不一样的</p><p>问题一：<strong>分辨率resolution</strong>：是指计时器的时间测量单位问题，即最短的非零时间跨度。</p><p>问题二：线程的<strong>同步</strong>问题</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> start, finish;start = Get_current_time();<span class="hljs-comment">/*执行的代码*/</span>finish = Get_current_time();elapsed = finish - start;</code></pre><p>这样的代码可能会输出多个时间，可以使用<code>barrier</code>函数来进行同步，并且取出运行时间的最大值。</p><pre><code class="hljs c++">shared <span class="hljs-keyword">double</span> global_elapsed;<span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> my_start, my_finish, my_elapsed;Barrier();<span class="hljs-comment">//路障，用于使所有进程同时开始</span>my_start = Get_current_time();<span class="hljs-comment">/*执行的代码*/</span>my_finish = Get_current_time();my_elapsed = my_finish - my_start;global_elapsed = Global_max(myelapsed);<span class="hljs-comment">//取出所有进程运行时间的最大值</span><span class="hljs-keyword">if</span>(my_rank == <span class="hljs-number">0</span>)<span class="hljs-comment">//主进程负责输出时间</span>    <span class="hljs-built_in">cout</span>&lt;&lt;global_elapsed&lt;&lt;<span class="hljs-built_in">endl</span>;</code></pre><p>问题三：<strong>易变性</strong>（variability）</p><p>多次执行同一个程序时，每次运行所花费的时间可能是不同的。看起来最好的方法是平均数或中位数，实则不然。</p><p>由于不可能存在某些外部事件使得程序的运行时间少于它可能的最短运行时间，所以我们的报告通常写上<strong>最短的运行时间</strong>。</p><h4 id="4-并行化过程"><a href="#4-并行化过程" class="headerlink" title="4.并行化过程"></a>4.并行化过程</h4><p>Foster方法：</p><ol><li>划分（partitioning）：将要执行的指令核数据按照计算部分拆分成多个小任务</li><li>通信（communication）：确定上一步所识别出来的任务之间需要执行哪些通信</li><li>凝聚或聚合（agglomeration / aggregation）：将第一步所确定的任务与通信结合成更大的任务</li><li>分配（mapping）：将上一步聚合好的任务分配到进程/线程中</li></ol><h4 id="5-编译过程"><a href="#5-编译过程" class="headerlink" title="5.编译过程"></a>5.编译过程</h4><ul><li><code>-g</code> 表示允许使用调试器</li><li><code>-Wall</code> 显示警告</li><li><code>-o&lt;outfile&gt;</code>编译出可执行文件的文件名outfile</li></ul><h2 id="三、用MPI进行分布式内存编程"><a href="#三、用MPI进行分布式内存编程" class="headerlink" title="三、用MPI进行分布式内存编程"></a>三、用MPI进行分布式内存编程</h2><p><a href="https://wuhlan3.gitee.io/wuhlan3/2021/03/23/MPI%E5%88%86%E5%B8%83%E5%BC%8F%E5%86%85%E5%AD%98%E7%BC%96%E7%A8%8B/">点我点我</a></p><h2 id="四、用Pthreads进行共享内存编程"><a href="#四、用Pthreads进行共享内存编程" class="headerlink" title="四、用Pthreads进行共享内存编程"></a>四、用Pthreads进行共享内存编程</h2><p><a href="https://wuhlan3.gitee.io/wuhlan3/2021/03/22/Pthreads%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%BC%96%E7%A8%8B/">点我点我</a></p><h2 id="五、用OpenMP进行共享内存编程"><a href="#五、用OpenMP进行共享内存编程" class="headerlink" title="五、用OpenMP进行共享内存编程"></a>五、用OpenMP进行共享内存编程</h2><p><a href="">点我点我</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>超算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI分布式内存编程</title>
    <link href="/Wuhlan3/2021/07/10/MPI%E5%88%86%E5%B8%83%E5%BC%8F%E5%86%85%E5%AD%98%E7%BC%96%E7%A8%8B/"/>
    <url>/Wuhlan3/2021/07/10/MPI%E5%88%86%E5%B8%83%E5%BC%8F%E5%86%85%E5%AD%98%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="从Hello-world开始"><a href="#从Hello-world开始" class="headerlink" title="从Hello,world开始"></a>从Hello,world开始</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mpi.h&gt;</span></span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_STRING = <span class="hljs-number">100</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>{   <span class="hljs-keyword">char</span> greeting[MAX_STRING];    <span class="hljs-keyword">int</span>  comm_sz;        <span class="hljs-comment">//进程的数量</span>   <span class="hljs-keyword">int</span>  my_rank;        <span class="hljs-comment">//进程的编号</span>   MPI_Init(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//MPI_Init(int* argc_p, char*** argv_p); argc_p和argv_p是指向参数argc和argv的指针</span>   MPI_Comm_size(MPI_COMM_WORLD, &amp;comm_sz);<span class="hljs-comment">//第一个参数是通信子，是MPI为通信子定义的特殊类型</span>   MPI_Comm_rank(MPI_COMM_WORLD, &amp;my_rank);   <span class="hljs-keyword">if</span>(my_rank != <span class="hljs-number">0</span>)   {        <span class="hljs-built_in">sprintf</span>(greeting, <span class="hljs-string">"Greetings from process %d of %d!"</span>, my_rank, comm_sz);        MPI_Send(greeting, <span class="hljs-built_in">strlen</span>(greeting)+<span class="hljs-number">1</span>, MPI_CHAR, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, MPI_COMM_WORLD);    }   <span class="hljs-keyword">else</span>   {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Greetings from process %d of %d!\n"</span>, my_rank, comm_sz);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> q=<span class="hljs-number">1</span>; q&lt;comm_sz; q++)        {             MPI_Recv(greeting, MAX_STRING, MPI_CHAR, q, <span class="hljs-number">0</span>,   MPI_COMM_WORLD, MPI_STATUS_IGNORE);             <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, greeting);        }       }   MPI_Finalize();<span class="hljs-comment">//MPI使用完毕时，可以进行释放</span>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><h3 id="编译与运行方法"><a href="#编译与运行方法" class="headerlink" title="编译与运行方法"></a>编译与运行方法</h3><pre><code class="hljs cmd">编译：$ mpicc -g -Wall -o 执行文件名 C文件名$ mpicc -g -Wall -o main main.c运行：$ mpiexec -n 线程数 ./执行文件名$ mpiexec -n <span class="hljs-number">4</span> ./main</code></pre><p>简单回顾一下上面出现的函数：<br><code>MPI_Init()</code>、<code>MPI_Finalize()</code>、<code>MPI_Comm_size()</code>、<code>MPI_Comm_rank()</code>、<code>MPI_Send()</code>、<code>MPI_Recv()</code></p><div class="note note-success">            <p><strong>通信子</strong>指的是一组可以互相发送消息的进程集合</p><p>注意：<code>MPI_COMM_WORLD</code>是<code>MPI_Comm</code>类型的变量，即MPI通信子（communicator），不需要额外定义。或者可以理解为一个通信域，你的进程都在这个域里面，里面包含了进程数和进程号等信息。</p><p>此外，通信子里面的<code>comm_sz</code>表示进程的数量，<code>my_rank</code>表示进程号，是以指针的形式传递</p>          </div><p><strong>通信</strong>相关的函数：</p><p><code>MPI_Send()</code>、<code>MPI_Recv()</code></p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Send</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span>* msg_buf_p,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>   msg_size,</span></span><span class="hljs-function"><span class="hljs-params">MPI_Datatypemsg_type,<span class="hljs-comment">//前三个参数定义了消息的内容</span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>dest,<span class="hljs-comment">//目的进程号</span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>tag,<span class="hljs-comment">//小标签，用于区分看上去完全一样的消息</span></span></span><span class="hljs-function"><span class="hljs-params">MPI_Commcommunicator)</span></span>;  <span class="hljs-comment">//通信子</span></code></pre><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Recv</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span>* msg_buf_p,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>buf_size,</span></span><span class="hljs-function"><span class="hljs-params">MPI_Datatypebuf_type,<span class="hljs-comment">//前三个参数定义了接收消息的内容</span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>source,<span class="hljs-comment">//消息来自哪个进程</span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span> tag,</span></span><span class="hljs-function"><span class="hljs-params">MPI_Commcommunicator,<span class="hljs-comment">//后三个参数用来识别消息</span></span></span><span class="hljs-function"><span class="hljs-params">MPI_Status*status_p)</span></span>;<span class="hljs-comment">//大部分不使用该参数，只需赋予特殊常量MPI_STATUS_IGNORE</span></code></pre><p><img src="image-20210323225734248.png" alt="image-20210323225734248" style="zoom:50%;"></p><p>特殊常量：<code>MPI_ANY_TAG</code>，可以将它传给<code>MPI_Recv</code>的参数tag。称为<strong>通配符</strong>（wildcard）。可以使一个进程接收多条来自另一个进程的有着不同标签的消息。</p><h3 id="关于发送和接收消息的过程"><a href="#关于发送和接收消息的过程" class="headerlink" title="关于发送和接收消息的过程"></a>关于发送和接收消息的过程</h3><p>MPI_Send有两种可能：缓冲与阻塞</p><ul><li>缓冲：即消息会存放在一个发送缓冲区中，而MPI_Send函数立即返回</li><li>阻塞：即系统将发生阻塞，一直等待，直到开始发送消息</li></ul><p>出现哪一种情况一般取决于默认的消息<strong>截止大小</strong>（”cutoff” message size）。如果消息的大小小于截止大小，则它会被缓冲；如果消息的大小大于截止大小，函数将会被阻塞</p><p>MPI_Recv则只有一种可能——阻塞。只有当收到一条匹配消息的时候，才会返回。</p><h3 id="MPI消息的特性"><a href="#MPI消息的特性" class="headerlink" title="MPI消息的特性"></a>MPI消息的特性</h3><p><strong>不可超越性</strong>（nonovertaking），即一个q进程发送两条消息给r进程，这两条消息一定是按顺序的。</p><p>而多个进程发送消息则会出现<strong>异步性</strong></p><h2 id="集合通信"><a href="#集合通信" class="headerlink" title="集合通信"></a>集合通信</h2><p>集合通信相关函数：<code>MPI_Reduce()</code></p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Reduce</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span>* input_data_p,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span>*output_data_p,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>count,<span class="hljs-comment">//若count大于1，则MPI_Reduce函数可以应用到数组上，对向量进行运算</span></span></span><span class="hljs-function"><span class="hljs-params">MPI_Datatypedatatype,</span></span><span class="hljs-function"><span class="hljs-params">MPI_Op<span class="hljs-keyword">operator</span>,<span class="hljs-comment">//关键参数，类型是MPI_Op，有多个预定义值</span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>dest_process,</span></span><span class="hljs-function"><span class="hljs-params">MPI_commcomm)</span></span>;</code></pre><p><img src="image-20210323225622760.png" alt="image-20210323225622760"></p><h3 id="关于集合通信"><a href="#关于集合通信" class="headerlink" title="关于集合通信"></a>关于集合通信</h3><p>一般情况下，count设置为1，用于一个变量的集体运算，如：</p><pre><code class="hljs c">MPI_Reduce(&amp;local_int, &amp;total_int, <span class="hljs-number">1</span> ,MPI_DOUBLE, MPI_SUM, <span class="hljs-number">0</span>, MPI_COMM_WORLD);</code></pre><p>如果设置count&gt;1，则是对一个向量的运算，如：</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> local_x[N], sum[N];MPI_Reduce(local_x, sum, N, MPI_DOUBLE, MPI_SUM, <span class="hljs-number">0</span>, MPI_COMM_WORLD);</code></pre><h3 id="集合通信的特点"><a href="#集合通信的特点" class="headerlink" title="集合通信的特点"></a>集合通信的特点</h3><ol><li>通信子中的所有进程必须调用相同的集合通信函数</li><li>每个进程传递给MPI集合通信函数的参数必须是“相容的”。比如，dest_process的值应该是相同的</li><li>参数<code>output_data_p</code>虽然只作用在目的进程中，但是其他进程也需要写上这个参数，会被置为NULL</li><li><p>集合通信不使用标签，只通过通信子和调用的顺序进行匹配。具体可看书本p69。</p></li><li><p>禁止使input_data_p和output_data_p使用同一个缓冲区，这将会不可预测。</p></li></ol><h3 id="蝶形结构"><a href="#蝶形结构" class="headerlink" title="蝶形结构"></a>蝶形结构</h3><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_AllReduce</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span>* input_data_p,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span>*output_data_p,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>count,<span class="hljs-comment">//若count大于1，则MPI_Reduce函数可以应用到数组上，对向量进行运算</span></span></span><span class="hljs-function"><span class="hljs-params">MPI_Datatypedatatype,</span></span><span class="hljs-function"><span class="hljs-params">MPI_Op<span class="hljs-keyword">operator</span>,<span class="hljs-comment">//关键参数，类型是MPI_Op，有多个预定义值</span></span></span><span class="hljs-function"><span class="hljs-params">MPI_commcomm)</span></span>;</code></pre><p>它的基本参数与reduce一致，唯一的不同是没有dest_process，这是因为它是将结果发布给所有的进程。是reduce的一个相反的过程</p><p><strong>蝶形结构</strong>：即进行全局运算之后，将结构发送给所有的进程</p><h3 id="广播函数"><a href="#广播函数" class="headerlink" title="广播函数"></a>广播函数</h3><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Bcast</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span>* data_p,<span class="hljs-comment">//广播进程发送的数据，接收进程接收的数据</span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span> count,<span class="hljs-comment">//数组的大小</span></span></span><span class="hljs-function"><span class="hljs-params">MPI_Datatypedatatype,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span> source_proc,</span></span><span class="hljs-function"><span class="hljs-params">MPI_Commcomm)</span></span>;</code></pre><h3 id="数据分发"><a href="#数据分发" class="headerlink" title="数据分发"></a>数据分发</h3><p>划分的方式：</p><ol><li>块划分</li><li>循环划分</li><li>块-循环划分</li></ol><p><strong>散射</strong>：用于0号进程读入整个向量，但只将分量发送给需要分量的其他进程：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Scatter</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span>* send_buf_p,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>send_count,<span class="hljs-comment">//发送的向量大小，注意这里的大小是本地大小</span></span></span><span class="hljs-function"><span class="hljs-params">MPI_Datatypesend_type,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span>* recv_buf_p,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>recv_count,<span class="hljs-comment">//接收的向量大小</span></span></span><span class="hljs-function"><span class="hljs-params">MPI_Datatyperecv_type,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>src_proc,</span></span><span class="hljs-function"><span class="hljs-params">MPI_Commcomm)</span></span>;</code></pre><div class="note note-success">            <p>MPI_Scatter只适用于<strong>块划分法</strong></p><p>需要注意的是，发送的向量大小不是send_buf_p的大小，而是和recv_count一样的，真正发送出去的大小</p>          </div><p><strong>聚集</strong>：将向量的所有分量都收集到0号进程上，然后0号进程再进行输出</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Gather</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span>* send_buf_p,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>send_count,<span class="hljs-comment">//发送的向量大小，注意这里的大小是本地大小</span></span></span><span class="hljs-function"><span class="hljs-params">MPI_Datatypesend_type,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span>* recv_buf_p,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>recv_count,<span class="hljs-comment">//接收的向量大小</span></span></span><span class="hljs-function"><span class="hljs-params">MPI_Datatyperecv_type,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>dst_proc,</span></span><span class="hljs-function"><span class="hljs-params">MPI_Commcomm)</span></span>;</code></pre><p>MPI_Gather同样只适用于<strong>块划分法</strong>，基本结构与MPI_Scatter类似</p><p><strong>全局聚集</strong>：将向量的所有分量都收集后，再分发到所有的进程上</p><pre><code class="hljs objectivec"><span class="hljs-keyword">int</span> <span class="hljs-built_in">MPI_AllGather</span>(    <span class="hljs-keyword">void</span>* send_buf_p,    <span class="hljs-keyword">int</span>send_count,<span class="hljs-comment">//发送的向量大小，注意这里的大小是本地大小</span>    <span class="hljs-built_in">MPI_Datatype</span>send_type,    <span class="hljs-keyword">void</span>* recv_buf_p,    <span class="hljs-keyword">int</span>recv_count,<span class="hljs-comment">//接收的向量大小</span>    <span class="hljs-built_in">MPI_Datatype</span>recv_type,    <span class="hljs-built_in">MPI_Comm</span>comm);</code></pre><p>好图，总结一下：</p><table><tbody><tr>    <td><img src="image-20210710185133518.png" alt="image-20210710185133518" style="zoom:67%;"></td><td><img src="image-20210710185200310.png" alt="image-20210710185200310" style="zoom: 67%;"></td>    </tr>    <tr>    <td><img src="image-20210710185248694.png" alt="image-20210710185248694" style="zoom:67%;"></td><td><img src="image-20210710185101011.png" alt="image-20210710185101011" style="zoom: 67%;"></td>    </tr></tbody></table><h2 id="派生数据类型"><a href="#派生数据类型" class="headerlink" title="派生数据类型"></a>派生数据类型</h2><p>由于发送消息耗费的时间巨大，我们要尽可能地减少消息的发送。具体有三种方法：</p><ol><li>通信函数中的count参数</li><li>派生数据类型</li><li>MPI_Pack/Unpack函数</li></ol><pre><code class="hljs c">MPI_Type_create_struct(    <span class="hljs-keyword">int</span>count,<span class="hljs-comment">//元素的数量</span>    <span class="hljs-keyword">int</span>array_of_blocklengths[],<span class="hljs-comment">//每种元素的长度</span>    MPI_Aintarray_of_displacements[],<span class="hljs-comment">//每种元素的地址,距离消息起始位的地址</span>    MPI_Datatypearray_of_types[],    MPI_Datatype*new_type_p<span class="hljs-comment">//输出的新的类型</span>);</code></pre><p>如何获取地址呢？</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Get_address</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span>*location_p,</span></span><span class="hljs-function"><span class="hljs-params">MPI_Aint*address_p)</span></span>;</code></pre><h2 id="计时"><a href="#计时" class="headerlink" title="计时"></a>计时</h2><p>MPI自带一个函数：</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> start,finish;start = MPI.Wtime();<span class="hljs-comment">/*串行代码*/</span>finish = MPI_Wtime();<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%e"</span>,finish-start);</code></pre><p>也可以使用timer库函数，他们两个返回的都是墙上时钟时间：</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"timer.h"</span></span><span class="hljs-keyword">double</span> start,finish;GET_TIME(start);<span class="hljs-comment">/*串行代码*/</span>GET_TIME(finish);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%e"</span>,finish-start);</code></pre><p>当然，上述的两种写法，一般用于串行代码的计时。回想第二章所学，计时需要先同步，并记录每个进程最大值，最终获取并行部分代码运行的总时间。</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> local_start, local_finish, local_elapsed, elapsed;<span class="hljs-comment">/*进程的一些初始化*/</span>MPI_Barrier(comm);local_start = MPI_Wtime();<span class="hljs-comment">/*需要计时的代码*/</span>local_finish = MPI_Wtime();local_elapsed = local_finish - local_start;MPI_Reduce(&amp;local_elapsed, &amp;elapsed, <span class="hljs-number">1</span>, MPI_DOUBLE, MPI_MAX, <span class="hljs-number">0</span> , comm);<span class="hljs-comment">//获取进程时间的最大值</span><span class="hljs-keyword">if</span>(my_rank == <span class="hljs-number">0</span>)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Elapsed time = %e seconds\n"</span>, elapsed);</code></pre><h2 id="交换奇偶排序"><a href="#交换奇偶排序" class="headerlink" title="交换奇偶排序"></a>交换奇偶排序</h2><p>是冒泡排序的一种扩展。</p><p><strong>定理</strong>：设A是一个拥有n个键值的列表，作为就交换排序算法的输入，那么经过n个阶段后，A能够排好序。</p><p><strong>定理</strong>：如果p个进程运行并行奇偶交换排序算法，则p个阶段后，输入列表排序完毕。</p><p>重点，再看看书本P86~88</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>回忆之前的，MPI_Send有两种不同的方式来实现：缓冲和阻塞。假设所有的进程都进入阻塞状态，就会导致没有进程使用MPI_Recv，进入<strong>死锁</strong>状态。</p><p>幸好，MPI提供了一个函数，它会执行一次阻塞的消息发送函数和一次消息接收函数</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Sendrecv</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span>* send_buf_p,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>   send_size,</span></span><span class="hljs-function"><span class="hljs-params">MPI_Datatypesend_type,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>dest,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>send_tag,</span></span><span class="hljs-function"><span class="hljs-params"></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span>* recv_buf_p,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>recv_size,</span></span><span class="hljs-function"><span class="hljs-params">MPI_Datatyperecv_type,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>source,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span> recv_tag,</span></span><span class="hljs-function"><span class="hljs-params">MPI_Commcommunicator,</span></span><span class="hljs-function"><span class="hljs-params">MPI_Status*status_p)</span></span>;<span class="hljs-comment">//大部分不使用该参数，只需赋予特殊常量MPI_STATUS_IGNORE</span></code></pre><p>如果接收缓冲区和发送缓冲区是一样的话，还有另一个函数：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Sendrecv</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span>* msg_buf_p,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>   msg_size,</span></span><span class="hljs-function"><span class="hljs-params">MPI_Datatypemsg_type,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>dest,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>send_tag,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span>source,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span> recv_tag,</span></span><span class="hljs-function"><span class="hljs-params">MPI_Commcommunicator,</span></span><span class="hljs-function"><span class="hljs-params">MPI_Status*status_p)</span></span>;<span class="hljs-comment">//大部分不使用该参数，只需赋予特殊常量MPI_STATUS_IGNORE</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>超算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenMP共享内存编程</title>
    <link href="/Wuhlan3/2021/07/09/OpenMP%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%BC%96%E7%A8%8B/"/>
    <url>/Wuhlan3/2021/07/09/OpenMP%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="从hello，world开始"><a href="#从hello，world开始" class="headerlink" title="从hello，world开始"></a>从hello，world开始</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;omp.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Hello</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span>{    <span class="hljs-keyword">int</span> thread_count = strtol(argv[<span class="hljs-number">1</span>],<span class="hljs-literal">NULL</span>,<span class="hljs-number">10</span>);<span class="hljs-comment">//10表示十进制</span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel num_threads(thread_count);</span>    Hello();        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Hello</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{    <span class="hljs-keyword">int</span> my_rank = omp_get_thread_num();<span class="hljs-comment">//获取线程号</span>    <span class="hljs-keyword">int</span> thread_count = omp_get_num_threads();<span class="hljs-comment">//获取线程总数</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello from thread %d of %d\n"</span>, my_rank, thread_count);}</code></pre><p>使用parallel是用来表明之后的<strong>结构化代码块</strong>（<strong>基本块</strong>）应该被多个线程并行执行。</p><p>后面跟着的叫做<strong>子句</strong>，比如<code>num_threads</code>是用来指定执行后代码块的线程数的</p><p>执行并行块的线程集合称为<strong>线程组</strong>，原始的线程称为<strong>主线程</strong>，额外的线程称为<strong>从线程</strong></p><p>存在一个<strong>隐式路障</strong>，完成代码块的线程将等待线程组中所有的其他线程完成代码块。</p><h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp critical</span>    global_result += my_result;</code></pre><p>对后面的代码进行互斥访问</p><h2 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h2><p><strong>共享作用域</strong>：一个能够被线程组中的所有线程访问的变量拥有共享作用域</p><p><strong>私有作用域</strong>：一个只能被单个线程访问的变量拥有私有作用域</p><pre><code class="hljs c">global_result = <span class="hljs-number">0.0</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel num_threads(thread_count)</span>{    <span class="hljs-keyword">double</span> my_result = <span class="hljs-number">0.0</span>;    my_result += Local_trap(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b, <span class="hljs-keyword">int</span> n);    <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp crtical</span>    global_result += my_result;}</code></pre><p>上述代码可以使用<strong>归约子句</strong>来简化成如下形式：</p><pre><code class="hljs c">global_result = <span class="hljs-number">0.0</span>;<span class="hljs-meta"># <span class="hljs-meta-keyword">pragma</span> omp parallel num_threads(thread_count) \ </span>    reduction(+: global_result)global_result += Local_trap(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b, <span class="hljs-keyword">int</span> n);</code></pre><p>代码明确了global_result是一个<strong>归约变量</strong>，加号表示<strong>归约操作符</strong>是加法。</p><div class="note note-success">            <p>注意一下：根据不同的归约操作符，私有变量会初始化为不同的值。</p><p>加法：一般初始化为0；乘法：一般初始化为1</p>          </div><h2 id="for指令"><a href="#for指令" class="headerlink" title="for指令"></a>for指令</h2><pre><code class="hljs c">h = (b-a)/n;approx = (f(a)+f(b))/<span class="hljs-number">2.0</span>;<span class="hljs-meta"># <span class="hljs-meta-keyword">pragma</span> omp parallel for num_threads(thread_count)\</span>    reduction(+: approx)<span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= n<span class="hljs-number">-1</span>; i++)    approx+= f(a+i*h);approx = h*approx;</code></pre><p>reduction子句的使用在这里是必要的</p><p>此外，parallel指令中，所有变量的<strong>缺省作用域</strong>是<strong>共享</strong>的。但是for指令中的循环变量的<strong>缺省作用域</strong>是<strong>私有</strong>的</p><p>来一张图！！！《可并行化的for语句的合法表达式》</p><h3 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h3><p>一般情况下，上述不能并行的for语句，编译器是会直接报错的。但是有更加隐匿的问题——数据依赖性。</p><ul><li>OpenMP编译器不会检查parallel for指令并行化的循环所包含的依赖关系，需要程序员自己来识别</li><li>一个或更多个迭代结果依赖于其他迭代的循环，一般不能被正确并行化</li></ul><p>以斐波那契数列为例：</p><ul><li>fib[6]和fib[5]计算间的依赖关系称为 <strong>数据依赖</strong></li><li>由于fibo[5]的值在一个迭代中计算，其结果在之后的迭代中使用，所以也称为 <strong>循环依赖</strong></li></ul><div class="note note-success">            <p>考点：判断有无数据依赖性！！！</p>          </div><h2 id="关于作用域"><a href="#关于作用域" class="headerlink" title="关于作用域"></a>关于作用域</h2><p>与其让OpenMP决定每个变量的作用域，还不如让程序员明确块中每个变量的作用域。</p><h3 id="default子句"><a href="#default子句" class="headerlink" title="default子句"></a>default子句</h3><p>使用了default（none）子句之后，编译器要求我们明确在块中和在块外声明的所有变量的作用域！</p><pre><code class="hljs c"><span class="hljs-keyword">double</span> sum = <span class="hljs-number">0.0</span>;<span class="hljs-meta"># <span class="hljs-meta-keyword">pragma</span> omp parallel for num_threads(thread_count)\</span>    <span class="hljs-keyword">default</span>(none) reduction(+:sum) <span class="hljs-keyword">private</span>(k,factor)\    shared(n)<span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt; n; k ++){    <span class="hljs-keyword">if</span>(k % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)        factor = <span class="hljs-number">1.0</span>;    <span class="hljs-keyword">else</span>         factor = <span class="hljs-number">-1.0</span>;    sum += factor/(<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>);}</code></pre><h2 id="奇偶排序"><a href="#奇偶排序" class="headerlink" title="奇偶排序"></a>奇偶排序</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel num_threads(thread_count)\</span>    <span class="hljs-keyword">default</span>(none) shared(a,n) <span class="hljs-keyword">private</span>(i, tmp, phase)<span class="hljs-keyword">for</span>(phase = <span class="hljs-number">0</span>; phase &lt; n ; phase++){    <span class="hljs-keyword">if</span>(phase % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)        <span class="hljs-meta"># <span class="hljs-meta-keyword">pragma</span> omp for</span>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; n; i += <span class="hljs-number">2</span>){            <span class="hljs-keyword">if</span>(a[i<span class="hljs-number">-1</span>]&gt;a[i]){                tmp = a[i<span class="hljs-number">-1</span>];                a[i<span class="hljs-number">-1</span>] = a[i];                a[i] = tmp;            }        }        <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp for</span>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; n<span class="hljs-number">-1</span>; i += <span class="hljs-number">2</span>){            <span class="hljs-keyword">if</span>(a[i]&gt;a[i+<span class="hljs-number">1</span>]){                tmp = a[i];                a[i] = a[i+<span class="hljs-number">1</span>];                a[i+<span class="hljs-number">1</span>] = tmp;            }        }}</code></pre><p>这里的特点就是，只创建了一次线程，在这之后使用已有的线程组来并行化for循环，节省了开销。</p><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>调度子句为如下形式：</p><pre><code class="hljs c">schedule(&lt;type&gt; [,&lt;chunksize&gt;])</code></pre><p>type有以下几种类型：</p><ul><li>static：迭代能够在循环执行前分配给线程</li><li>dynamic：当线程完成它当前的迭代集合时，它能从运行时系统中请求更多（开销大于static）</li><li>guided：编译器和运行时系统决定调度方式（开销最大）</li><li>runtime：调度在运行时决定</li></ul><p>其中runtime允许在运行时确定调度类型，因此实际调度策略只有前面三种。</p><p>一般OpenMP实现的缺省调度为：</p><pre><code class="hljs c">schedule (<span class="hljs-keyword">static</span>, total_iterations/thread_count)</code></pre><p><img src="image-20210711103038725.png" alt="image-20210711103038725" style="zoom: 80%;"></p><h2 id="路障"><a href="#路障" class="headerlink" title="路障"></a>路障</h2><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-meta-keyword">pragma</span> omp barrier</span></code></pre><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-meta-keyword">pragma</span> omp atomic</span>x &lt;op&gt;= &lt;expression&gt;</code></pre><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><ul><li>简单锁：简单锁在被释放前，只能获得一次</li><li>嵌套锁：嵌套锁在被释放前，可以被同一个线程获得多次</li></ul><p>简单锁的函数定义：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">omp_init_lock</span><span class="hljs-params">(<span class="hljs-keyword">omp_lock_t</span>* lock_P)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">omp_set_lock</span><span class="hljs-params">(<span class="hljs-keyword">omp_lock_t</span>* lock_p)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">omp_unset_lock</span><span class="hljs-params">(<span class="hljs-keyword">omp_lock_t</span>* lock_p)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">omp_destroy_lock</span><span class="hljs-params">(<span class="hljs-keyword">omp_lock_t</span>* lock_p)</span></span>;</code></pre><h3 id="critical、atomic、lock的区别："><a href="#critical、atomic、lock的区别：" class="headerlink" title="critical、atomic、lock的区别："></a>critical、atomic、lock的区别：</h3><ol><li>critical易使用，一般情况下都可以考虑</li><li>atomic可能会把两个变量不一样的语句也强制进行互斥，比如说<code>x++</code>和<code>y++</code>，需要注意</li><li>锁机制适用于需要互斥的是某个数据结构而不是代码块的情况。</li></ol><p>互斥需要非常谨慎：</p><ul><li><p>对同一个临界区，不能混合使用不同的互斥技术</p></li><li><p>互斥不能保证公平性，可能会有一个线程一直被阻塞</p></li><li><p>嵌套互斥可能会产生意想不到的结果：</p><pre><code class="hljs c"><span class="hljs-comment">//该程序会进入死锁状态</span><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp critical</span>    y = f(x)l    ...    <span class="hljs-keyword">double</span> f(<span class="hljs-keyword">double</span> x){    # pragma omp critical    z = g(x);}</code></pre><p>解决方法，是命名临界区：</p><pre><code class="hljs c"><span class="hljs-comment">//命名临界区</span><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp critical(one)</span>    y = f(x)l    ...    <span class="hljs-keyword">double</span> f(<span class="hljs-keyword">double</span> x){    # pragma omp critical(two)    z = g(x);}</code></pre></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>超算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pthreads共享内存编程</title>
    <link href="/Wuhlan3/2021/06/20/Pthreads%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%BC%96%E7%A8%8B/"/>
    <url>/Wuhlan3/2021/06/20/Pthreads%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="共享内存编程"><a href="#共享内存编程" class="headerlink" title="共享内存编程"></a>共享内存编程</h2><p><img src="image-20210620225347320.png" alt="image-20210620225347320"></p><p><strong>临界区</strong>：对共享内存区域进行更新的代码段</p><p><strong>线程</strong>：在共享内存编程中，运行在每一个处理器上的一个程序的实例</p><p><strong>进程</strong>：正在运行（或挂起）的程序的一个实例，除了可执行代码外，它还包括：</p><ul><li>栈段</li><li>堆段</li><li>系统为进程分配的资源描述符</li><li>安全信息</li><li>描述进程状态的信息</li></ul><p>一般来说，一个进程的内存块是私有的，其他进程无法直接访问，除非操作系统进行干涉。但是有的时候，我们又希望进程之间可以互相访问各自的内存区域，所以我们呢引入<strong>轻量级进程</strong>的概念——线程。</p><p>下面我们使用POSIX线程库，也称为Pthread线程库。它定义了一套多线程编程的应用程序编程接口。它是一个C语言库，也可以应用在C++程序中。</p><h2 id="从Hello，world开始"><a href="#从Hello，world开始" class="headerlink" title="从Hello，world开始"></a>从Hello，world开始</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-keyword">int</span> thread_count;<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">Hello</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* rank)</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span><span class="hljs-function"></span>{     <span class="hljs-keyword">long</span> thread;    <span class="hljs-keyword">pthread_t</span>* thread_handles;         thread_count = strtol(argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>);    thread_handles =(<span class="hljs-keyword">pthread_t</span>*) <span class="hljs-built_in">malloc</span>(thread_count * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">pthread_t</span>));    <span class="hljs-keyword">for</span>(thread = <span class="hljs-number">0</span>; thread &lt; thread_count; thread++)        pthread_create(&amp;thread_handles[thread], <span class="hljs-literal">NULL</span>, Hello, (<span class="hljs-keyword">void</span>*)thread);    <span class="hljs-comment">//Hello 为函数名</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello from the main thread\n"</span>);    <span class="hljs-keyword">for</span>(thread = <span class="hljs-number">0</span>; thread &lt; thread_count; thread++)        pthread_join(thread_handles[thread], <span class="hljs-literal">NULL</span>);        <span class="hljs-built_in">free</span>(thread_handles);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;} <span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">Hello</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* rank)</span> </span><span class="hljs-function"></span>{     <span class="hljs-keyword">long</span> my_rank = (<span class="hljs-keyword">long</span>)rank;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello from thread %ld of %d\n"</span>,my_rank,thread_count);     <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;}</code></pre><h5 id="编译与运行方法："><a href="#编译与运行方法：" class="headerlink" title="编译与运行方法："></a>编译与运行方法：</h5><pre><code class="hljs cmd">$ gcc -g -Wall -o pth_hello pth_hello.c -lpthread$ ./pth_hello <span class="hljs-number">4</span></code></pre><p>线程的生成，主要涉及下述几个语句：</p><pre><code class="hljs c++"><span class="hljs-keyword">pthread_t</span>* thread_handles; thread_count = strtol(argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>);<span class="hljs-comment">//线程数</span>thread_handles =(<span class="hljs-keyword">pthread_t</span>*) <span class="hljs-built_in">malloc</span>(thread_count * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">pthread_t</span>));<span class="hljs-comment">//分配线程空间</span><span class="hljs-comment">//创造线程并且开始执行</span><span class="hljs-keyword">for</span>(rank = <span class="hljs-number">0</span>; rank &lt; thread_count; rank++)    pthread_create(&amp;thread_handles[rank], <span class="hljs-literal">NULL</span>, Hello, (<span class="hljs-keyword">void</span>*)rank);  <span class="hljs-comment">//线程的派生</span><span class="hljs-keyword">for</span>(rank = <span class="hljs-number">0</span>; rank &lt; thread_count; rank++)    pthread_join(thread_handles[rank], <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//线程的合并，等待线程完成并结束</span><span class="hljs-built_in">free</span>(thread_handles);<span class="hljs-comment">//释放线程空间</span></code></pre><h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>由于是共享内存，当多个线程尝试更新一个共享资源时，结果是无法预测的。</p><p><strong>竞争条件：</strong></p><p>当多个线程都要访问共享变量或共享文件这样的共享资源时，如果至少其中一个访问的是更新操作，那么这些访问就可能导致某种错误。</p><p><strong>临界区：</strong></p><p>是一个更新共享资源的代码段，一次只允许一个线程执行该代码段。</p><h3 id="忙等待-busy-waiting"><a href="#忙等待-busy-waiting" class="headerlink" title="忙等待(busy waiting)"></a>忙等待(busy waiting)</h3><pre><code class="hljs c"><span class="hljs-keyword">for</span>(...){    <span class="hljs-keyword">while</span>(flag != my_rank);    ...    flag = (flag+<span class="hljs-number">1</span>)%thread_count;}</code></pre><p>循环等待，只有当flag为线程号的时候，该线程才能够执行</p><h3 id="互斥量-Mutex"><a href="#互斥量-Mutex" class="headerlink" title="互斥量(Mutex)"></a>互斥量(Mutex)</h3><p>初始化一个互斥量：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_mutex_init</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pthread_mutex_t</span>* mutex_p,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">pthread_mutexattr_t</span>*attr_p</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre><p>删除互斥量：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_mutex_destroy</span><span class="hljs-params">(<span class="hljs-keyword">pthread_mutex_t</span>* mutex_p)</span></span>;</code></pre><p>p操作：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-keyword">pthread_mutex_t</span>* mutex_p)</span></span>;</code></pre><p>v操作：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-keyword">pthread_mutex_t</span>* mutex_p)</span></span>;</code></pre><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>初始化一个信号量：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sem_init</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sem_t</span>*semaphore,</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span>shared,</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">unsigned</span>initial_val</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre><p>删除信号量：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sem_destroy</span><span class="hljs-params">(<span class="hljs-keyword">sem_t</span>*semaphore_p)</span></span>;</code></pre><p>v操作：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sem_post</span><span class="hljs-params">(<span class="hljs-keyword">sem_t</span>*semaphore_p)</span></span>;</code></pre><p>p操作：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sem_wait</span><span class="hljs-params">(<span class="hljs-keyword">sem_t</span>*semaphore_p)</span></span>;</code></pre><p>需要加头文件：<code>#include &lt;semaphore.h&gt;</code></p><h3 id="路障（barrier）"><a href="#路障（barrier）" class="headerlink" title="路障（barrier）"></a>路障（barrier）</h3><p><strong>条件变量：</strong></p><p>是一个数据对象，允许线程在某个特定条件或事件发生前都处于挂起状态。当事件或条件发生时，另一个线程可以通过信号来唤醒挂起的线程。一个<strong>条件变量</strong>总是与一个<strong>互斥量</strong>相关联。、</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_cond_signal</span><span class="hljs-params">(<span class="hljs-keyword">pthread_cond_t</span>* cond_var_p)</span></span>;<span class="hljs-comment">//唤醒一个阻塞进程</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_cond_broadcast</span><span class="hljs-params">(<span class="hljs-keyword">pthread_cond_t</span>* cond_var_p)</span></span>;<span class="hljs-comment">//唤醒所有阻塞进程</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_cond_wait</span><span class="hljs-params">(<span class="hljs-keyword">pthread_cond_t</span>* cond_var_p, <span class="hljs-keyword">pthread_mutex_t</span>* mutex_p)</span></span>;<span class="hljs-comment">//通过互斥量mutex_p来阻塞线程，直到其他线程调用pthread_cond_signal或pthread_cond_broadcast</span></code></pre><p>条件变量的初始化与销毁：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_cond_init</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pthread_cond_t</span> cond_p,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">pthread_condattr_t</span>*cond_attr_p<span class="hljs-comment">//通常传递NULL</span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_cond_destroy</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pthread_cond_t</span>*cond_p</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre><p>路障的实现：</p><pre><code class="hljs c">pthread_mutex_lock($mutex);<span class="hljs-comment">//锁住</span>counter++;<span class="hljs-keyword">if</span>(counter == thread_count){<span class="hljs-comment">//当所有线程抵达路障时</span>    counter = <span class="hljs-number">0</span>;    pthread_cond_broadcast(&amp;cond_var);<span class="hljs-comment">//唤醒所有阻塞线程</span>}<span class="hljs-keyword">else</span>{    <span class="hljs-keyword">while</span>(pthread_cond_wait(&amp;cond_var, &amp;mutex)!= <span class="hljs-number">0</span>);}pthread_mutex_unlock(&amp;mutex);<span class="hljs-comment">//解锁</span></code></pre><p><strong>直接使用barrier</strong></p><p>在进行nbody的时候我使用过下面的函数，这个是书本上没有提到的：</p><pre><code class="hljs c"><span class="hljs-keyword">pthread_barrier_t</span> barrier;<span class="hljs-comment">//全局变量的定义</span>pthread_barrier_init(&amp;barrier,<span class="hljs-literal">NULL</span>,thread_count);<span class="hljs-comment">//初始化</span>pthread_barrier_wait(&amp;barrier);<span class="hljs-comment">//只有当所有线程都到达该语句，才能继续执行</span>pthread_barrier_destroy(&amp;barrier);<span class="hljs-comment">//删除</span></code></pre><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>对链表，同时读、同时写，可能会出现<strong>段错误</strong></p><p>两种不太好的解决方案：</p><ul><li>对整个函数进行互斥量保护</li><li><strong>“细粒度”锁</strong>：对每一个结点添加一个互斥量</li></ul><p>读写锁：</p><pre><code class="hljs c"><span class="hljs-comment">//初始化</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_rwlock_init</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pthread_rwlock_t</span>*rwlock_p,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">pthread_rwlockattr_t</span>attr_p<span class="hljs-comment">//不使用时，传递NULL</span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;<span class="hljs-comment">//读</span>pthread_rwlock_rdlock(&amp;rwlock);Member(value);pthread_rwlock_unlock(&amp;rwlock);<span class="hljs-comment">//写：插入</span>pthread_rwlock_wrlock(&amp;rwlock);Insert(value);pthread_rwlock_unlock(&amp;rwlock);<span class="hljs-comment">//写：删除</span>pthread_rwlock_wrlock(&amp;rwlock);Delete(value);pthread_rwlock_unlock(&amp;rwlock);<span class="hljs-comment">//销毁</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_rwlock_destroy</span><span class="hljs-params">(<span class="hljs-keyword">pthread_rwlock_t</span>* rwlock_p)</span></span>;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>超算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实验6：二态进程模型内核</title>
    <link href="/Wuhlan3/2021/06/01/%E5%AE%9E%E9%AA%8C6%EF%BC%9A%E4%BA%8C%E6%80%81%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%86%85%E6%A0%B8/"/>
    <url>/Wuhlan3/2021/06/01/%E5%AE%9E%E9%AA%8C6%EF%BC%9A%E4%BA%8C%E6%80%81%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%86%85%E6%A0%B8/</url>
    
    <content type="html"><![CDATA[<h1>实验6：二态进程模型内核</h1><h3 id="实验目的">实验目的</h3><p>1、学习多道程序与CPU分时技术</p><p>2、掌握操作系统内核的二态进程模型设计与实现方法</p><p>3、掌握进程表示方法</p><p>4、掌握时间片轮转调度的实现</p><h3 id="实验要求">实验要求</h3><p>1、了解操作系统内核的二态进程模型</p><p>2、扩展实验五的的内核程序，增加一条命令可同时创建多个进程分时运行，增加进程控制块和进程表数据结构。</p><p>3、修改时钟中断处理程序，调用时间片轮转调度算法。</p><p>4、设计实现时间片轮转调度算法，每次时钟中断，就切换进程，实现进程轮流运行。</p><p>5、修改save()和restart()两个汇编过程，利用进程控制块保存当前被中断进程的现场，并从进程控制块恢复下一个进程的现场。</p><p>6、编写实验报告，描述实验工作的过程和必要的细节，如截屏或录屏，以证实实验工作的真实性</p><p><img src="v2-c7b1619e9ee778610063a2129f3176f1_r.jpg" alt="fly"></p><h3 id="实验内容">实验内容</h3><ol><li><p>修改实验5的内核代码，内核执行期间，关中断，实现内核不可再入。</p></li><li><p>修改实验5的内核代码，定义进程控制块，包括进程号、程序名、进程内存地址信息、CPU寄存器保存区、进程状态等必要数据项。</p></li><li><p>扩展实验五的的内核程序，增加一条命令可同时执行多个用户程序，内核加载这些程序，创建多个进程，实现分时运行</p></li><li><p>修改时钟中断处理程序，保留无敌风火轮显示，而且增加调用进程调度过程</p></li><li><p>内核增加进程调度过程:每次调度，将当前进程转入就绪状态，选择下一个进程运行，如此反复轮流运行。</p></li><li><p>修改save()和restart()两个汇编过程，利用进程控制块保存当前被中断进程的现场，并从进程控制块恢复下一个进程的运行。</p></li><li><p>实验5的内核其他功能，如果不必要，可暂时取消服务。</p></li></ol><p><img src="image-20210516201332886.png" alt="image-20210516201332886"></p><h3 id="实验环境">实验环境</h3><h5 id="1-系统与虚拟机">1.系统与虚拟机</h5><ul><li>Windows 10 - x64 18363.1139</li><li>VMware Workstation 16 Player：用于跑ubuntu虚拟机</li><li>Ubuntu 20.04.2 LTS</li><li>VirtualBox-6.1.18-142142-Win：用于运行.img文件</li><li>DOSBox DOS Emulator 0,74,0,0：用于tcc和tasm编译，并且运行.com文件</li></ul><h5 id="2-windows上的相关软件、编译器等">2.windows上的相关软件、编译器等</h5><ul><li>NASM version 2.10.07 compiled on Jan  2 2013</li><li>TCC.EXE：用于16位C语言编程</li><li>TLINK.EXE：用于C语言与汇编语言链接</li><li>TASM.EXE：用于.asm文件的汇编</li></ul><h5 id="3-Ubuntu上的相关软件、编译器等">3.Ubuntu上的相关软件、编译器等</h5><ul><li>NASM version 2.14.02</li><li>makefile：GNU Make 4.2.1</li></ul><h3 id="实验基本架构">实验基本架构</h3><p><img src="WuhlanOS6.png" alt="Wuhlan OS6"></p><h3 id="实验过程">实验过程</h3><h4 id="1-载入内存函数的修改">1.载入内存函数的修改</h4><p>对载入内存函数<code>loadProgram</code>进行修改，添加多几个参数。因为多进程同时运行的时候，是需要几个用户程序载入内存的不同位置，段地址和偏移量不再像之前那样定死了。同时由于过去常常出现磁头号和载入扇区数等错误，所以把这两个参数也引入，使得更加灵活，减少错误的发生。</p><p>参数从右往左依次入栈，使用bp来进行寻址</p><pre><code class="hljs asm">public _loadProgram;extern int loadBlock(int es, int bx, char sector, int num, int head);从右往左依次入栈_loadProgram proc near    push bp;head/num/sector/bx/es/ip/bp    mov bp,sp        push ax    push bx    push cx    push dx    push es    mov ax,[bp+4];段地址 es    mov es,ax    mov bx,[bp+6];偏移量 bx    mov ah,2    mov al,[bp+10];扇区数num    mov ch,0    mov cl,[bp+8];扇区sector    mov dl,0    mov dh,[bp+12];磁头号 head    int 13h    pop es    pop dx    pop cx    pop bx    pop ax    pop bp        ret_loadProgram endp</code></pre><h4 id="2-save和restart的修改">2.save和restart的修改</h4><p>只需要在上一个实验的基础上进行小修改，<code>_cpuReg——&gt;_curPCB</code>，即可：</p><pre><code class="hljs asm">;保护现场，此时栈顶/flags/cs/int ip/save ip*************_save proc near    push ds;/flags/cs/ip/ip/ds    push cs    pop ds;ds=cs        push si;/flags/cs/ip/ip/ds/si        mov si,word ptr DGROUP:_curPCB;此时si是PCB结构体的地址    pop word ptr [si+16];si存入结构体,/flags/cs/ip/ip/ds    pop word ptr [si+14];ds存入结构体,/flags/cs/ip/ip        lea si,ret_temp;这个ip指的是save的返回地址    pop word ptr [si];ip存入ret_temp中,/flags/cs/ip        mov si,word ptr DGROUP:_curPCB    pop word ptr [si+22];ip存入结构体，/flags/cs    pop word ptr [si+24];cs存入结构体，/flags    pop word ptr [si+26];flags存入结构体，/，栈为空            mov [si+18],ss;ss存入结构体    mov [si+20],sp;sp存入结构体        mov si,ds    mov ss,si;将栈修改为内核栈        mov sp,word ptr DGROUP:_curPCB    add sp,14;此时指向PCB结构体的        push es    push bp    push di    push dx    push cx    push bx    push ax;PCB结构体保存es/bp/di/dx/cx/bx/ax        mov si,word ptr DGROUP:_kernelPCB    mov sp,[si+20];sp变为内核态    mov ax,cs    mov es,ax;cs变为内核态        lea si,ret_temp    mov ax,[si]    jmp ax;返回call _save的位置_save endp;********************************************************</code></pre><p>只需要在上一个实验的基础上进行小修改，<code>_cpuReg——&gt;_curPCB</code>，即可：</p><pre><code class="hljs asm">;恢复现场********************************************_restart proc near    mov si,word ptr DGROUP:_kernelPCB    mov [si+20],sp    ;lea sp,_curPCB    mov sp,word ptr DGROUP:_curPCB;将栈指针指向PCB结构体，对前7个寄存器进行出栈    pop ax    pop bx    pop cx    pop dx    pop di    pop bp    pop es                                        ;结构体中/flags/cs/ip/sp/ss/si/ds    lea si,ds_temp;使用一个临时变量存储ds,/flags/cs/ip/sp/ss/si    pop word ptr [si];结构体中/flags/cs/ip/sp/ss/si    lea si,si_temp;使用一个临时变量存储si    pop word ptr [si];结构体中/flags/cs/ip/sp/ss        lea si,bx_temp    mov [si],bx;保护一下bx    pop bx;结构体中/flags/cs/ip/sp    mov ss,bx;bx为原来的栈地址    mov bx,sp    mov sp,[bx];bx此时是结构体中sp的地址，恢复栈的sp        add bx,2;使bx指向ip        push word ptr [bx+4];原来的栈中：/flags    push word ptr [bx+2];原来的栈中：/flags/cs    push word ptr [bx];原来的栈中：/flags/cs/ip        push ax;原来的栈中：/flags/cs/ip/ax    push word ptr [si];原来的栈中：/flags/cs/ip/ax/bx    lea si,ds_temp    mov ax,[si]    lea si,si_temp    mov bx,[si]    mov ds,ax;恢复ds    mov si,bx;恢复si        pop bx;原来的栈中：/flags/cs/ip/ax    pop ax;原来的栈中：/flags/cs/ip        iret    _restart endp</code></pre><h4 id="3-进程控制块">3.进程控制块</h4><p>在实验五的基础上，将寄存器结构体修改为进程控制块，额外添加几个变量作为控制信息。其中0代表新建态；1代表运行态；2代表阻塞态。</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>{</span>    <span class="hljs-comment">/*寄存器*/</span>    <span class="hljs-keyword">int</span> ax;    <span class="hljs-keyword">int</span> bx;    <span class="hljs-keyword">int</span> cx;    <span class="hljs-keyword">int</span> dx;    <span class="hljs-keyword">int</span> di;    <span class="hljs-keyword">int</span> bp;    <span class="hljs-keyword">int</span> es;        <span class="hljs-keyword">int</span> ds;    <span class="hljs-keyword">int</span> si;    <span class="hljs-keyword">int</span> ss;    <span class="hljs-keyword">int</span> sp;    <span class="hljs-keyword">int</span> ip;    <span class="hljs-keyword">int</span> cs;    <span class="hljs-keyword">int</span> flags;    <span class="hljs-comment">/*其他信息*/</span>    <span class="hljs-keyword">int</span> pid;    <span class="hljs-keyword">char</span> name[<span class="hljs-number">10</span>];<span class="hljs-comment">/*貌似没有起到作用，不过老师写了就跟着写*/</span>    <span class="hljs-keyword">int</span> status;<span class="hljs-comment">/*新建态/结束态：0，运行：1，阻塞：2*/</span>}PCB;</code></pre><p>同时声明PCB序列，并记录当前的PCB和内核的PCB</p><pre><code class="hljs c">PCB PCBList[processNum];   <span class="hljs-comment">/*PCB序列，存储所有进程的信息*/</span>PCB *curPCB = &amp;PCBList[processNum - <span class="hljs-number">1</span>];   <span class="hljs-comment">/*当前的PCB，一开始默认为内核PCB*/</span>PCB *kernelPCB = &amp;PCBList[processNum - <span class="hljs-number">1</span>]; <span class="hljs-comment">/*把最后一个PCB作为内核的PCB*/</span></code></pre><h4 id="4-进程初始化">4.进程初始化</h4><p>将所有进程的状态置为空闲，并把内核的状态设置为运行态。在操作系统刚开始运行的时候，就需要进行初始化。</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initProcess</span><span class="hljs-params">()</span></span>{    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; processNum; i++){        PCBList[i].status = <span class="hljs-number">0</span>;    }    kernelPCB-&gt;pid = processNum - <span class="hljs-number">1</span>;    kernelPCB-&gt;status = <span class="hljs-number">1</span>;    <span class="hljs-built_in">strcpy</span>(kernelPCB-&gt;name, <span class="hljs-string">"kernel"</span>);}</code></pre><h4 id="5-进程创建">5.进程创建</h4><p>为什么flags需要初始化为512呢？是因为只需要把中断响应置为1即可，后文会详细讲述。</p><p>该函数的主要步骤为：</p><ul><li>寻找一个状态为新建态的进程</li><li>对所有的寄存器进行初始化</li><li>设置进程ID和进程名</li><li>将程序载入内存</li><li>修改进程状态为阻塞态</li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cs, <span class="hljs-keyword">int</span> ip, <span class="hljs-keyword">int</span> sector, <span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> head)</span></span>{    <span class="hljs-keyword">int</span> cur;    <span class="hljs-keyword">for</span> (cur = <span class="hljs-number">0</span>; cur &lt; processNum; cur++){        <span class="hljs-keyword">if</span> (PCBList[cur].status == <span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;    }    PCBList[cur].ax = <span class="hljs-number">0</span>;    PCBList[cur].bx = <span class="hljs-number">0</span>;    PCBList[cur].cx = <span class="hljs-number">0</span>;    PCBList[cur].dx = <span class="hljs-number">0</span>;    PCBList[cur].si = <span class="hljs-number">0</span>;    PCBList[cur].bp = <span class="hljs-number">0</span>;    PCBList[cur].di = <span class="hljs-number">0</span>;    PCBList[cur].cs = cs;    PCBList[cur].ds = cs;    PCBList[cur].es = cs;    PCBList[cur].ip = ip;    PCBList[cur].ss = cs;    PCBList[cur].sp = savePSPadd(cs);    PCBList[cur].flags = <span class="hljs-number">512</span>;    PCBList[cur].pid = cur;    PCBList[cur].name[<span class="hljs-number">0</span>] = <span class="hljs-string">'0'</span> + cur;    PCBList[cur].name[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    LoadPSP(cs);    loadProgram(cs, ip, sector, num, head);<span class="hljs-comment">/*sector:扇区，num:扇区数，head:磁头号*/</span>    PCBList[cur].status = <span class="hljs-number">2</span>;    runningNum ++;    <span class="hljs-keyword">return</span> ;}</code></pre><h4 id="6-进程切换">6.进程切换</h4><p>进程切换，需要考虑以下几种情况：</p><ul><li>若正在运行的程序数<code>runningNum</code>为0，则将进程切换或保持为内核</li><li>否则，遍历所有的PCB，直到找到一个处于阻塞状态的进程：<ul><li>若找到了阻塞态的，则将其修改为运行态；并把当前的状态（运行态的时候才改）改为阻塞态</li><li>若找不到，则继续运行当前进程</li></ul></li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">scheduleProcess</span><span class="hljs-params">()</span></span>{    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">if</span> (runningNum == <span class="hljs-number">0</span>){        curPCB = &amp;PCBList[processNum - <span class="hljs-number">1</span>];        curPCB-&gt;status = <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span>;    }    <span class="hljs-keyword">for</span> (i = curPCB-&gt;pid + <span class="hljs-number">1</span>; <span class="hljs-number">1</span>; i++){        i = i % processNum;        <span class="hljs-keyword">if</span>(i == curPCB-&gt;pid)<span class="hljs-keyword">break</span>;<span class="hljs-comment">/*遍历了一遍都没有发现阻塞态的进程，则保持当前的继续运行*/</span>        <span class="hljs-keyword">if</span> (PCBList[i].status == <span class="hljs-number">2</span>){            <span class="hljs-keyword">if</span>(curPCB-&gt;status == <span class="hljs-number">1</span>)curPCB-&gt;status = <span class="hljs-number">2</span>;<span class="hljs-comment">/*只有当状态为运行态，才修改为阻塞态*/</span>            PCBList[i].status = <span class="hljs-number">1</span>;            curPCB = &amp;PCBList[i];            <span class="hljs-keyword">return</span>;        }    }}</code></pre><p>修改时钟中断，使每一个时间片结束时，进行进程切换。</p><p>在合适的地方添加下面的语句即可：</p><pre><code class="hljs asm">call _scheduleProcess</code></pre><h4 id="7-进程结束">7.进程结束</h4><p>用户程序是使用<code>ret</code>来返回操作系统的，我们该如何判断用户程序什么时候返回呢？</p><p>当用户程序运行到<code>ret</code>语句的时候，会弹出用户栈里的两个数据，作为段地址和偏移量。我们在之前将栈初始化——保存了<code>cs</code>和<code>0</code>在栈顶。所以用户程序会跳转到PSP的段首，这里我们预先存放了<code>int 20h</code>，所以会调用20h中断。20h的主要作用是跳转并执行<code>endProcess</code>函数。</p><p>20h的中断修改如下：</p><pre><code class="hljs asm">INT20H:    mov ax,cs    mov ds,ax    mov ss,ax    mov es,ax    mov si,word ptr DGROUP:_kernelPCB    mov sp,[si+20]    jmp _endProcess</code></pre><p><code>endProcess</code>函数如下:</p><ul><li>修改进程状态为空闲状态</li><li>总的进程数减1</li><li>开中断</li><li>循环等待，直到时间片结束</li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">endProcess</span><span class="hljs-params">()</span></span>{    curPCB-&gt;status = <span class="hljs-number">0</span>;    runningNum--;    STI();    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);}</code></pre><h4 id="8-具体在main中新建进程">8.具体在main中新建进程</h4><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(isstr_eql(str,<span class="hljs-string">"programs"</span>)){            createProcess(<span class="hljs-number">0x2000</span>, <span class="hljs-number">0x8c00</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">/*四个程序载入的内存地址要不同*/</span>            createProcess(<span class="hljs-number">0x3000</span>, <span class="hljs-number">0x8c00</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);            createProcess(<span class="hljs-number">0x4000</span>, <span class="hljs-number">0x8c00</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);            createProcess(<span class="hljs-number">0x5000</span>, <span class="hljs-number">0x8c00</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);            <span class="hljs-keyword">while</span> (runningNum);<span class="hljs-comment">/*当还有用户程序正在运行，则阻塞在此处。*/</span>            cls();    }</code></pre><h3 id="实验结果">实验结果</h3><p>开机动画正常运作</p><img src="image-20210515224730500.png" alt="image-20210515224730500" style="zoom: 67%;"><p>可以注意到，右下角的风火轮可以正常转动，同时新增了一条指令<code>programs</code>可以同时运行4个用户程序：</p><img src="image-20210525144610900.png" alt="image-20210525144610900" style="zoom:67%;"><p>int22可以正常显示：</p><img src="image-20210525144816988.png" alt="image-20210525144816988" style="zoom:67%;"><p>int21执行如下：</p><img src="image-20210525144757838.png" alt="image-20210525144757838" style="zoom:67%;"><p>使用新的指令<code>programs</code>同时运行四个字符反射的用户程序，我们会发现，当其中一个进程运行结束后，其他进程的运行速度会变快，到最后只剩下A进程的时候，他的运行速度就和之前一样了。这说明进程在运行结束后，正确地变为空闲状态。当所有用户程序运行结束后，会自动返回操作系统。如下：</p><img src="image-20210525144507172.png" alt="image-20210525144507172" style="zoom:67%;"><h3 id="问题与解决方式">问题与解决方式</h3><ol><li><p>当多个用户程序同时运行的时候，有的程序运行的快，有的程序运行的慢。当其中一个程序运行结束后就会直接清屏，不能等待其他程序运行完成。这里使用一个循环语句来<strong>同步</strong>——当所有用户程序都运行完成时，才能结束循环。</p><pre><code class="hljs asm">while (runningNum);</code></pre></li><li><p>纠结了一下，flag标志寄存器该初始化位多少？</p><img src="20201024133042782.png" alt="img" style="zoom: 33%;"><p>上图中，灰色的为保留位，白色的为各种类型的标志。</p><p>x86架构CPU中，标志寄存器主要有3种作用：</p><ul><li>存储相关指令执行后的结果，例如CF（进位）、PF（奇偶）、AF（辅助进位）、ZF（0）、OF（溢出）</li><li>执行相关指令时，提供行为依据，例如执行<code>JE</code>指令时会读取ZF的值，来决定是否进行跳转。</li><li>控制CPU的工作方式，例如IF（是否响应中断）、VM、TF等标志位。</li></ul><p>因此我们只需要将<code>flag</code>初始化为512，9号位置1，使其具有中断处理的功能即可</p></li><li><p>关于<code>int 20h</code>的中断问题。</p><p>上网查阅资料发现，一般情况下是不使用<code>int 20h</code>这个中断的。这是因为本中断的入口参数为：<strong>CS=程序PSP的段地址</strong>，使用起来常常会有些错误。一般会使用<code>int 21h</code>。</p><p>那么在有多个进程交替运行的时候，如何<strong>在不修改原有用户程序</strong>的情况下，判断进程已经运行结束呢。由于一般用户程序最后使用<code>ret</code>进行返回。所以，我们只需要使栈的顶分别为段地址<code>cs</code>和偏移量<code>0</code>，那么<code>cs:0</code>指向的就是PSP代码前缀。PSP是DOS用来和被加载的程序进行通信的，它的结构如下：</p><p><img src="image-20210531232853188.png" alt="image-20210531232853188"></p><p>所以，我们将<code>int 20H</code>存放到PSP的0号位置。</p><p>所以我们只需要在运行程序之前，对用户栈进行初始化，添加<code>cs</code>和<code>0</code>，就能保证用户程序在ret的时候跳转到PSP并调用<code>int 20h</code>，然后根据我们自己写的<code>int 20h</code>就能在程序结束之后，对进程的PCB进行修改与调整。</p></li></ol><h3 id="实验总结">实验总结</h3><p>其实进程控制块PCB处理起来并不复杂，毕竟这次实验进程只需要有新建态、阻塞态、运行态，况且我用查找方式、排队方式仅仅是从头到尾的慢慢遍历，并没有用到非常复杂的算法。所以C程序部分的代码还是非常显然的，只需要用心理清代码逻辑即可。</p><p>而汇编模块的程序还是比较麻烦。需要对<code>save</code>、<code>restart</code>两个模块进行修改，对几个中断进行修改，这里涉及到汇编和C程序之间的相互调用，另外加深了我对汇编语言的各个寄存器的认识。如对FLAG寄存器各个位的作用的认识。同时了解到PSP段的使用方式，并运用到用户进程的返回当中。</p><p>虽然操作系统实验占用了我课余蛮多的时间，但是我还是想说：我爱OS！🐶</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实验5：实现系统调用</title>
    <link href="/Wuhlan3/2021/05/16/%E5%AE%9E%E9%AA%8C5%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/Wuhlan3/2021/05/16/%E5%AE%9E%E9%AA%8C5%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1>实验5：实现系统调用</h1><h3 id="实验目的">实验目的</h3><p>1、 学习掌握PC系统的软中断指令</p><p>2、掌握操作系统内核对用户提供服务的系统调用程序设计方法</p><p>3、掌握C语言的库设计方法</p><p>4、掌握用户程序请求系统服务的方法</p><h3 id="实验要求">实验要求</h3><p>1、了解PC系统的软中断指令的原理</p><p>2、掌握x86汇编语言软中断的响应处理编程方法</p><p>3、扩展实验四的的内核程序，增加输入输出服务的系统调用。</p><p>4、C语言的库设计，实现<code>putch()</code>、<code>getch()</code>、<code>printf()</code>等基本输入输出库过程。</p><p>5、编写实验报告，描述实验工作的过程和必要的细节，如截屏或录屏，以证实实验工作的真实性</p><h3 id="实验内容">实验内容</h3><p>(1) 修改实验4的内核代码，先编写save()和restart()两个汇编过程，分别用于中断处理的现场保护和现场恢复，内核定义一个保护现场的数据结构，以后，处理程序的开头都调用save()保存中断现场，处理完后都用restart()恢复中断现场。</p><p>(2) 内核增加int 20h、int 21h和int 22h软中断的处理程序，其中，int 20h用于用户程序结束是返回内核准备接受命令的状态；int 21h用于系统调用，并实现3-5个简单系统调用功能；int22h功能未定，先实现为屏幕某处显示INT22H。</p><p>(3) 保留无敌风火轮显示，取消触碰键盘显示OUCH!这样功能。</p><p>(4) 进行C语言的库设计，实现putch()、getch()、gets()、puts()、printf()、scanf()等基本输入输出库过程，汇编产生libs.obj。</p><p>(5) 利用自己设计的C库libs.obj，编写一个使用这些库函数的C语言用户程序，再编译，再与libs.obj一起链接，产生COM程序。增加内核命令执行这个程序：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{   <span class="hljs-keyword">char</span> ch,str[<span class="hljs-number">80</span>];   <span class="hljs-keyword">int</span> a;   getch(&amp;ch);   gets(str);   scnf(“a=%d”,&amp;a);  putch(ch);  <span class="hljs-built_in">puts</span>(str);   printint(“ch=%c, a=%d, str=%s”, ch, a, str);}</code></pre><p>(6) 编写实验报告，描述实验工作的过程和必要的细节，如截屏或录屏，以证实实验工作的真实性</p><p><img src="new.png" alt="new"></p><h3 id="实验环境">实验环境</h3><h5 id="1-系统与虚拟机">1.系统与虚拟机</h5><ul><li>Windows 10 - x64 18363.1139</li><li>VMware Workstation 16 Player：用于跑ubuntu虚拟机</li><li>Ubuntu 20.04.2 LTS</li><li>VirtualBox-6.1.18-142142-Win：用于运行.img文件</li><li>DOSBox DOS Emulator 0,74,0,0：用于tcc和tasm编译，并且运行.com文件</li></ul><h5 id="2-windows上的相关软件、编译器等">2.windows上的相关软件、编译器等</h5><ul><li>NASM version 2.10.07 compiled on Jan  2 2013</li><li>TCC.EXE：用于16位C语言编程</li><li>TLINK.EXE：用于C语言与汇编语言链接</li><li>TASM.EXE：用于.asm文件的汇编</li></ul><h5 id="3-Ubuntu上的相关软件、编译器等">3.Ubuntu上的相关软件、编译器等</h5><ul><li>NASM version 2.14.02</li><li>makefile：GNU Make 4.2.1</li></ul><h3 id="实验基本架构">实验基本架构</h3><p><img src="1.png" alt="Wuhlan OS"></p><h3 id="实验过程">实验过程</h3><h4 id="1-根据例程，写出保护现场与恢复现场">1.根据例程，写出保护现场与恢复现场</h4><p>在C程序中定义了一个结构体，包含了汇编中的14个寄存器，用于存储原来的状态，结构体如下：</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpuRegisters</span>{</span>    <span class="hljs-keyword">int</span> ax;<span class="hljs-comment">/*0*/</span>    <span class="hljs-keyword">int</span> bx;    <span class="hljs-keyword">int</span> cx;    <span class="hljs-keyword">int</span> dx;    <span class="hljs-keyword">int</span> di;    <span class="hljs-keyword">int</span> bp;    <span class="hljs-keyword">int</span> es;    <span class="hljs-keyword">int</span> ds;<span class="hljs-comment">/*14*/</span>    <span class="hljs-keyword">int</span> si;<span class="hljs-comment">/*16*/</span>    <span class="hljs-keyword">int</span> ss;<span class="hljs-comment">/*18*/</span>    <span class="hljs-keyword">int</span> sp;<span class="hljs-comment">/*20*/</span>    <span class="hljs-keyword">int</span> ip;<span class="hljs-comment">/*22*/</span>    <span class="hljs-keyword">int</span> cs;<span class="hljs-comment">/*24*/</span>    <span class="hljs-keyword">int</span> flags;<span class="hljs-comment">/*26*/</span>};</code></pre><p>老师给出了<code>Minix</code>中的<code>save</code>和<code>restart</code>过程，我们可以先看懂该程序，再写出自己的<code>_save</code>和<code>_restart</code>。我们必须要明确刚调用save的时候栈里有什么东西，包括标志寄存器flag，代码段cs，中断代码pc，和save 的返回地址。我们发现结构体中的前7个寄存器一般来说是比较容易处理的（不会对当前执行的代码造成其他意想不到的影响），且可以在save执行过程中作为中介保存一下。</p><p>仿照老师所给的代码，使用结构体保存中断现场，且在执行save之后，ss,sp,ds,cs,ip几个寄存器会变为内核态的。详情可以看下面代码的注释部分，对于栈的变化进行详细的讲述：</p><pre><code class="hljs asm">;保护中断现场，此时栈顶/flags/cs/int ip/save ip*********************_save proc near    push ds;/flags/cs/ip/ip/ds    push cs    pop ds;ds=cs        push si;/flags/cs/ip/ip/ds/si        lea si,_cpuReg;此时si是结构体的地址    pop word ptr [si+16];si存入结构体,/flags/cs/ip/ip/ds    pop word ptr [si+14];ds存入结构体,/flags/cs/ip/ip        lea si,save_ip;这个ip指的是save的返回地址    pop word ptr [si];ip存入ret_temp中,/flags/cs/ip        lea si,_cpuReg    pop word ptr [si+22];ip存入结构体，/flags/cs    pop word ptr [si+24];cs存入结构体，/flags    pop word ptr [si+26];flags存入结构体，/，栈为空        mov [si+18],ss;ss存入结构体    mov [si+20],sp;sp存入结构体        mov si,ds    mov ss,si;将栈修改为内核栈        lea si,_cpuReg    mov sp,si;使栈指针指向结构体    add sp,14;sp指向ds        push es;将剩余的寄存器存入结构体    push bp    push di    push dx    push cx    push bx    push ax        lea si,kernelsp    mov sp,[si]    ;此时ss,sp,ds,cs,ip都是内核的        lea si,save_ip;通过保存的save_iP进行返回    mov ax,[si]    jmp ax_save endp;********************************************************</code></pre><p>由于save的时候，最后才存储那7个寄存器，在恢复的时候，可以先恢复。由于我们使用si来进行寻址，所以先把恢复的si寄存器存入一个临时变量中，最后再进行恢复。比较需要注意的是栈的变化，首先把结构体作为栈，后来恢复了原来的栈，要对结构体进行手动寻址方式。</p><p>详情可以看下面代码的注释部分，对于栈的变化进行详细的讲述：</p><pre><code class="hljs asm">;恢复中断现场********************************************************_restart proc near    lea si,kernelsp    mov [si],sp    lea sp,_cpuReg;将栈指针指向结构体，对前7个寄存器进行出栈    pop ax    pop bx    pop cx    pop dx    pop di    pop bp    pop es                                ;结构体中/flags/cs/ip/sp/ss/si/ds    lea si,ds_temp;使用一个临时变量存储ds,/flags/cs/ip/sp/ss/si    pop word ptr [si];结构体中/flags/cs/ip/sp/ss/si    lea si,si_temp;使用一个临时变量存储si    pop word ptr [si];结构体中/flags/cs/ip/sp/ss        lea si,bx_temp;保护一下bx    mov [si],bx    pop bx;结构体中/flags/cs/ip/sp    mov ss,bx;bx为原来的栈地址    mov bx,sp    mov sp,[bx];bx此时是结构体中sp的地址，恢复栈的sp        add bx,2;使bx指向ip        push word ptr [bx+4];原来的栈中：/flags    push word ptr [bx+2];原来的栈中：/flags/cs    push word ptr [bx];原来的栈中：/flags/cs/ip        push ax;原来的栈中：/flags/cs/ip/ax    push word ptr [si];原来的栈中：/flags/cs/ip/ax/bx    lea si,ds_temp    mov ax,[si]    lea si,si_temp    mov bx,[si]    mov ds,ax;恢复ds    mov si,bx;恢复si        pop bx;原来的栈中：/flags/cs/ip/ax    pop ax;原来的栈中：/flags/cs/ip        iret    _restart endp;********************************************************</code></pre><p>这样，save、restart就已经写好了，我们要寻找一些方法来检验是否正确。使用方法</p><pre><code class="hljs asm">call _savecall do_INT_XXhjmp _restart</code></pre><p>可以在<code>Timer</code>的前后使用，程序照常进行。</p><p>还可以在<code>OUCH OUCH！</code>的前后使用，程序如常，说明save、restart是成功的。</p><h4 id="2-增加INT-20软中断程序">2.增加INT 20软中断程序</h4><blockquote><p>int 20h用于用户程序结束是返回内核准备接受命令的状态</p></blockquote><p>INT20h的内容主要是与jump过程相互配合的，提供新的跳转到用户程序并且返回的方法。与之前的区别在于保护了内核栈，提供了新的用户栈。在jump里把用户程序的ss=cs，sp准备好，并且将其压入用户栈中。具体代码如下：</p><pre><code class="hljs asm">public _jump_jump proc near;两个参数,要跳到的cs:ip    ;保护现场***********************************************    push bp    mov bp,sp;先获取当前的栈指针，方便寻址，/jumpdest_ip/jumpdest_cs/ip/bp    push ax    push bx    push cx    push dx    push di    push es    push ds    push si    pushf    mov bx,[bp+4];获取参数cs    mov ax,[bp+6];获取参数ip        mov es,bx    lea si,PSPBegin    mov di,0    lea cx,PSPEnd    sub cx,si    rep movsb        lea si,kernelsp    mov [si],sp    mov ss,bx    mov sp,0        xor cx,cx    push cx    push bx;要跳转的cs    push ax;要跳转的ip    retf;retf用栈中数据同时改CS,IP,远转移远返回指令。当它执行时，处理器先从栈中弹出    ;一个字到IP，再弹出一个字到CS。retf  -&gt;  pop ip   pop csPSPBegin:    int 20hPSPEnd:nop</code></pre><p>INT20h，前半部分是对中断的载入，与其他中断的载入方式一致，不必赘述。从用户程序返回到内核的方法，恢复内核栈，再恢复寄存器最后直接返回即可</p><pre><code class="hljs asm">public _loadINT_20h_loadINT_20h proc near;载入中断，基本固定化的格式了，不必赘述    push ax    push es    CLI    xor ax,ax    mov es,ax    lea ax,INT20H    mov [es:80h],ax    mov ax,cs    mov [es:82h],ax    mov es,ax    STI    pop es    pop ax    retINT20H:    mov ax,cs    mov ds,ax;ds = cs    mov ss,ax;ss = ss lea si,kernelsp    mov sp,[si];恢复栈指针    popf;因为在调用jump过程后，push了很多寄存器，所以需要返回前需要pop    pop si    pop ds    pop es    pop di    pop dx    pop cx    pop bx    pop ax    pop bp    ret_loadINT_20h endp</code></pre><h4 id="3-增加INT-21软中断程序">3.增加INT 21软中断程序</h4><p>基本结构如下：</p><ul><li>载入int 21h（与其他中断的载入方式类似，偏移量存放在地址84h，代码段地址存放在86h的位置）</li><li>执行int 21h</li><li>三个功能号，分别是：输出一个字符、获取键盘输入的字符（这个并不是完整的getchar）、返回内核（与int 20h一致）。</li></ul><pre><code class="hljs asm">;INT 21h****************************************************INT_21h:    call _save    call do_INT_21h    jmp _restartdo_INT_21h:    lea si, _cpuReg    mov ax, [si];此时si的地址就是ax        cmpah, 01h    jz INT_21h_1h        cmp ah, 02h    jz INT_21h_2h        cmp ah, 4ch    jz INT_21h_3h_21h_end:    ret;***********************************************************</code></pre><p>1h：获取键盘输入的字符</p><pre><code class="hljs asm">INT_21h_1h proc near    mov ax,cs    mov ds,ax    mov ah,0    int 16h;        ;此时al已经得到了输入的字符，接着我们把ah清零，并修改cpureg中的ax    xor ah,ah    lea si,_cpuReg    mov [si],ax    jmp _21h_endINT_21h_1h endp</code></pre><p>2h：输出一个字符</p><pre><code class="hljs asm">INT_21h_2h proc near    mov ax,cs    mov es,ax        mov bh,0    mov ah,3    int 10h;    lea bp,_cpuReg    add bp,6    mov ax,1301h    mov bx,0007h    mov cx,1    int 10h    jmp _21h_end    INT_21h_2h endp</code></pre><p>3h：返回内核</p><pre><code class="hljs asm">INT_21h_3h proc near    mov ax,cs    mov ds,ax    mov ah,0    int 16h    xor ah,ah    lea si,_cpuReg    mov [si],ax    jmp _21h_endINT_21h_3h endp</code></pre><h4 id="4-增加INT-22软中断程序">4.增加INT 22软中断程序</h4><p>由于<code>save</code>和<code>restart</code>已经准备好了，所以我们可以很轻松地写出INT 22h</p><p>加载22h中断，偏移量存放在地址88h，代码段地址存放在8ah的位置</p><p>Int22h中断处理程序(屏幕某处显示INT22H):int22h功能未定，先实现为屏幕某处显示INT22H。</p><pre><code class="hljs asm">;22号中断***************************************************INT_22h:    call _save    call do_INT_22h    jmp _restartdo_INT_22h:    mov ax, cs    mov ds, ax    mov ax,0b800h    mov es,ax        mov cx, 6 ;字符串长度,用于循环计数    lea si, INT22H_str;获取字符串地址        mov bx,(12*80+40)*2;打印于屏幕中心    mov ah,07hloop_int_22:    mov al,[si]    mov es:[bx], ax    inc bx    inc bx    inc si    loop loop_int_22;loop结合cx可以使循环写的很舒服    retINT22H_str db "INT 22H";***********************************************************</code></pre><p>使用一个用户程序来调用int 22h</p><pre><code class="hljs asm">org 8c00hstart:    int 22h    ret</code></pre><h4 id="5-完善C函数库">5.完善C函数库</h4><p>事实上，在之前的实验中我已经写了一个类似的库，这一次实验的主要是实现printf和scanf.</p><p>printf和scanf都是参数变长的函数。我对此完全没有概念，只好求助于搜索引擎。</p><p>关键的操作在于取str指针的地址，通过+偏移量的方式，寻址得到后面的参数。</p><p>如：<code>itos((int)*(&amp;str+off))</code>可以获得%d对应的数字，并将其转换为字符串</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, ...)</span></span>{    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">int</span> off = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; str[i] != <span class="hljs-number">0</span>; i++){        <span class="hljs-keyword">if</span> (str[i] != <span class="hljs-string">'%'</span>){            putch(str[i]);        }        <span class="hljs-keyword">else</span>{            i++;            <span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">'d'</span>)                <span class="hljs-built_in">puts</span>(itos((<span class="hljs-keyword">int</span>)*(&amp;str + off)));            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">'c'</span>)                putch((<span class="hljs-keyword">char</span>)*(&amp;str + off));            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">'s'</span>)                <span class="hljs-built_in">puts</span>((<span class="hljs-keyword">char</span> *)*(&amp;str + off));            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;            off += <span class="hljs-number">1</span>;        }    }}</code></pre><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scanf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, ...)</span></span>{    <span class="hljs-keyword">int</span> off = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; str[i] != <span class="hljs-number">0</span>; i++){        <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">'%'</span>){            i++;            <span class="hljs-keyword">switch</span> (str[i]){            <span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">'d'</span>){                gets(num);                *((<span class="hljs-keyword">int</span> *)(*(&amp;str + off))) = stoi();            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">'c'</span>)                getch((<span class="hljs-keyword">char</span> *)*(&amp;str + off));            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">'s'</span>)                gets((<span class="hljs-keyword">char</span> *)*(&amp;str + off));            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;            }            off += <span class="hljs-number">1</span>;        }    }}</code></pre><h4 id="6-将所有文件进行编译，并写入软盘">6.将所有文件进行编译，并写入软盘</h4><p>我们再来看看实验的要求：</p><blockquote><p>(5) 利用自己设计的C库libs.obj，编写一个使用这些库函数的C语言用户程序，再编译，再与libs.obj一起链接，产生COM程序。增加内核命令执行这个程序。</p></blockquote><p>此次生成的.com程序涉及到四个代码文件，对于C函数库，经过网上搜索发现不能使用<code>.h</code>作为文件名，而应该直接使用<code>.c</code>。之后使用批处理提高生产效率（其中，后四段命令是新添加的）：</p><pre><code class="hljs bat"><span class="hljs-built_in">del</span> *.obj<span class="hljs-built_in">del</span> *.comtcc -mt -c -omain.obj main.c &gt; ccmsg.txttasm monitor.asm monitor.obj &gt; amsg.txttlink /<span class="hljs-number">3</span> /t monitor.obj main.obj, monitor.com,,tcc -mt -c -otest.obj test.c &gt; test.txttcc -mt -c -ostdio.obj stdio.c &gt; stdio.txttasm loadtest.asm loadtest.obj &gt; loadtest.txttasm lib.asm lib.obj &gt; lib.txttlink /<span class="hljs-number">3</span> /t loadtest.obj lib.obj stdio.obj test.obj, loadtest.com,,</code></pre><p>本次实验引入了两个新的用户程序：</p><ul><li><p>test_int_22.bin，是用于测试中断向量22h的，加载到磁头号1，6号扇区的位置</p></li><li><p>LOADTEST.COM是用于测试中断向量21h的，加载到磁头号1，7号扇区的位置</p></li></ul><pre><code class="hljs makefile">BIN = loader.bin startOS.bin 19335209_A.bin 19335209_B.bin 19335209_C.bin 19335209_D.bin test_int_22.binIMG = wuhlan.img<span class="hljs-section">all: clear <span class="hljs-variable">$(BIN)</span> <span class="hljs-variable">$(IMG)</span></span><span class="hljs-section">clear:</span>    rm -f <span class="hljs-variable">$(BIN)</span> <span class="hljs-variable">$(IMG)</span><span class="hljs-section">%.bin: %.asm</span>    nasm -fbin <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><span class="hljs-section">%.img:</span>    /sbin/mkfs.msdos -C <span class="hljs-variable">$@</span> 1440    dd if=loader.bin of=<span class="hljs-variable">$@</span> conv=notrunc    dd if=MONITOR.COM of=<span class="hljs-variable">$@</span> seek=1 conv=notrunc    dd if=19335209_A.bin of=<span class="hljs-variable">$@</span> seek=18 conv=notrunc    dd if=19335209_B.bin of=<span class="hljs-variable">$@</span> seek=19 conv=notrunc    dd if=19335209_C.bin of=<span class="hljs-variable">$@</span> seek=20 conv=notrunc    dd if=19335209_D.bin of=<span class="hljs-variable">$@</span> seek=21 conv=notrunc    dd if=startOS.bin of=<span class="hljs-variable">$@</span> seek=22 conv=notrunc    dd if=test_int_22.bin of=<span class="hljs-variable">$@</span> seek=23 conv=notrunc    dd if=LOADTEST.COM of=<span class="hljs-variable">$@</span> seek=24 conv=notrunc</code></pre><h3 id="实验结果">实验结果</h3><p>开机动画正常运作</p><img src="2.png" alt="image-20210515224730500" style="zoom: 67%;"><p>可以注意到，右下角的风火轮可以正常转动，同时新增加两个用户程序，分别用于测试int21和int22</p><img src="3.png" alt="image-20210515224550534" style="zoom: 67%;"><p>int22可以正常显示</p><img src="4.png" alt="image-20210515225137314" style="zoom:67%;"><p>int21执行如下</p><img src="5.png" alt="image-20210515230025451" style="zoom:67%;"><h3 id="问题与解决方式">问题与解决方式</h3><ol><li><p>终于解决了，之前实验中C语言字符串无法显示的问题【捂脸】，经过老师的轻轻一点拨，原来就是我在载入监控程序的时候，没有控制好载入扇区的数量。如下，对<code>al</code>的值进行修改即可。😊</p><pre><code class="hljs asm">mov ax,cs                ;段地址 ; 存放数据的内存基地址mov es,ax                ;设置段地址（不能直接mov es,段地址）mov bx, OS_offset   mov ah,2                 ;功能号mov al,10                 ;扇区数，内核占用扇区数  注意：不止加载了一个扇区mov dl,0                 ;驱动器号 ; 软盘为0，硬盘和U盘为80Hmov dh,0                 ;磁头号 ; 起始编号为0mov ch,0                 ;柱面号 ; 起始编号为0mov cl,2                 ;存放内核的起始扇区号 ; 起始编号为1int 13H  ;调用读磁盘BIOS的13h功能jmp 0a00h:100h</code></pre></li><li><p>在dosbox编译的时候出现神奇错误：</p><p><code>Fatal: Command line: Can't locate file: load_stdio_test.asm</code></p><p>解决方法是，将文件名改短😓</p></li><li><p>在编译<code>int 21h</code>测试程序的时候，出现调用.com程序失败的问题。原来是.com程序超过了512kb，在载入内存的时候需要多载入几个扇区。这个问题也卡了好久，以后一定要注意😡</p></li></ol><h3 id="实验总结">实验总结</h3><p>本次实验看起来内容不多，但是真正做起来，是有非常多细节需要处理的。</p><p>第一个难关就是<code>save</code>和<code>restart</code>的设计。 它起到保护中断现场的作用，可以使得多出来的在后续的实验中大概会起到非常重要的作用。看起来只不过是push和pop的简单问题，但是事实上，很多的寄存器（如ss,sp等）是会影响当前指令的正常执行的，常常需要额外的变量存储，并且需要对栈的过程、对函数调用中的栈的调用过程非常清晰。通过对上网查阅资料，我对汇编语言中所有的寄存器的特点有了更深刻的理解。</p><p>接下来一个难关，是用户程序常常遇到调用失败的问题。很多时候是自己加载的扇区数，磁头号，扇区号不正确导致的。也出现了用户栈与内核栈并不对应导致错误。希望在后续的实验中能够避免。</p><p>希望下次实验能够顺顺利利！！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实验4：具有中断处理的内核</title>
    <link href="/Wuhlan3/2021/04/16/%E5%AE%9E%E9%AA%8C4%EF%BC%9A%E5%85%B7%E6%9C%89%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%9A%84%E5%86%85%E6%A0%B8/"/>
    <url>/Wuhlan3/2021/04/16/%E5%AE%9E%E9%AA%8C4%EF%BC%9A%E5%85%B7%E6%9C%89%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%9A%84%E5%86%85%E6%A0%B8/</url>
    
    <content type="html"><![CDATA[<h1>实验4：具有中断处理的内核</h1><h3 id="实验目的">实验目的</h3><p>1、PC系统的中断机制和原理<br>2、理解操作系统内核对异步事件的处理方法<br>3、掌握中断处理编程的方法<br>4、掌握内核中断处理代码组织的设计方法<br>5、了解查询式I/O控制方式的编程方法</p><h3 id="实验要求">实验要求</h3><p>1、知道PC系统的中断硬件系统的原理<br>2、掌握x86汇编语言对时钟中断的响应处理编程方法<br>3、重写和扩展实验三的的内核程序，增加时钟中断的响应处理和键盘中断响应。<br>4、编写实验报告，描述实验工作的过程和必要的细节，如截屏或录屏，以证实实验工作的真实性</p><h3 id="实验内容">实验内容</h3><p>(1)编写x86汇编语言对时钟中断的响应处理程序：设计一个汇编程序，在一段时间内系统时钟中断发生时，屏幕变化显示信息。在屏幕24行79列位置轮流显示’|’、'/'和’\’(无敌风火轮)，适当控制显示速度，以方便观察效果，也可以屏幕上画框、反弹字符等，方便观察时钟中断多次发生。将程序生成COM格式程序，在DOS或虚拟环境运行。<br>(2)重写和扩展实验三的的内核程序，增加时钟中断的响应处理和键盘中断响应。在屏幕右下角显示一个转动的无敌风火轮，确保内核功能不比实验三的程序弱，展示原有功能或加强功能可以工作。<br>(4) 扩展实验三的的内核程序，但不修改原有的用户程序，实现在用户程序执行期间，若触碰键盘，屏幕某个位置会显示“OUCH!OUCH!”。<br>(5)编写实验报告，描述实验工作的过程和必要的细节，如截屏或录屏，以证实实验工作的真实性</p><p><img src="6.png" alt="1618293085038"></p><h3 id="实验环境">实验环境</h3><h5 id="1-系统与虚拟机">1.系统与虚拟机</h5><ul><li>Windows 10 - x64 18363.1139</li><li>VMware Workstation 16 Player：用于跑ubuntu虚拟机</li><li>Ubuntu 20.04.2 LTS</li><li>VirtualBox-6.1.18-142142-Win：用于运行.img文件</li><li>DOSBox DOS Emulator 0,74,0,0：用于tcc和tasm编译，并且运行.com文件</li></ul><h5 id="2-windows上的相关软件、编译器等">2.windows上的相关软件、编译器等</h5><ul><li>NASM version 2.10.07 compiled on Jan  2 2013</li><li>TCC.EXE：用于16位C语言编程</li><li>TLINK.EXE：用于C语言与汇编语言链接</li><li>TASM.EXE：用于.asm文件的汇编</li></ul><h5 id="3-Ubuntu上的相关软件、编译器等">3.Ubuntu上的相关软件、编译器等</h5><ul><li>NASM version 2.14.02</li><li>makefile：GNU Make 4.2.1</li></ul><h3 id="实验前置知识">实验前置知识</h3><p>x86计算机在启动时会自动进入<strong>实模式状态</strong>，在内存的低位区（地址为0~1023[3FFH]，1KB）创建含256个中断向量的表IVT （每个向量[地址]占4个字节，<mark>格式为：16位段值:16位偏移值</mark>）。</p><img src="1.png" alt="image-20210413145103907" style="zoom:50%;"><p>下图是中断向量表，我们可以看到这次实验用到的中断向量主要包括8号中断向量（时钟中断）和9号中断向量（键盘中断）</p><img src="2.png" alt="2" style="zoom:70%;"><h3 id="实验过程">实验过程</h3><h4 id="1-例程分析">1.例程分析</h4><p>该代码实现的是，在窗口坐标为（12，39）的位置，显示字符。从’!'开始，按照ASCII的顺序，依次显示之后的所有字符。每隔一段时间字符就会变化一次。</p><ol><li><p>将Timer在代码中的偏移量设置为时钟中断向量（08h）的偏移地址（中断号为8，4*8 = 32，转换为16进制即20h）；再将该代码段的地址（CS）作为时钟中断向量的段地址。</p></li><li><p>程序在将初始字符’!'窗口中显示之后，就进入死循环。</p></li><li><p>而Timer中的代码会在很短的时间内进行调用：</p><ul><li><p>设置一个延迟计数，每四次中断才进行一次字符的变化；</p></li><li><p>每次字符变化在相应的ASCII码基础上+1；</p></li><li><p>中断结束后，需要发送EOI（End of Interrupt）到ISR相应的位置，将其清零，并中断返回</p></li></ul></li></ol><pre><code class="hljs asm">org 100h; 程序加载到100h，可用于生成COM; 设置时钟中断向量（08h），初始化段寄存器    xor ax,ax; AX = 0    mov es,ax; ES = 0    mov word [es:20h],Timer; 设置时钟中断向量的偏移地址    mov ax,cs     mov word [es:22h],ax; 设置时钟中断向量的段地址=CS    mov ds,ax; DS = CS    mov es,ax; ES = CS; 在屏幕右下角显示字符‘!’    movax,0B800h; 文本窗口显存起始地址    movgs,ax; GS = B800h    mov ah,0Fh; 0000：黑底、1111：亮白字（默认值为07h）    mov al,'!'; AL = 显示字符值（默认值为20h=空格符）    mov [gs:((80*12+39)*2)],ax; 屏幕第 24 行, 第 79 列    jmp $; 死循环; 时钟中断处理程序    delay equ 4; 计时器延迟计数    count db delay; 计时器计数变量，初值=delayTimer:    dec byte [count]; 递减计数变量    jnz end; &gt;0：跳转    inc byte [gs:((80*12+39)*2)]; =0：递增显示字符的ASCII码值    mov byte[count],delay; 重置计数变量=初值delayend:    mov al,20h; AL = EOI    out 20h,al; 发送EOI到主8529A    out 0A0h,al; 发送EOI到从8529A    iret; 从中断返回</code></pre><h4 id="2-在右下角显示“无敌风火轮”">2.在右下角显示“无敌风火轮”</h4><p>在老师的代码基础上进行修改。</p><p>我们只需要将风火轮的移动到右下角，并且将字符的变化修改为<code>/|\-</code>的依次变化即可（增加多一个横杠，会使风火轮更像是风火轮）。</p><p>主要修改的是Timer部分的代码。增加一个变量<code>pos</code>来对应字符的位置，每次中断发生，改变<code>pos</code>，即可。</p><pre><code class="hljs asm">char db ' /|\-';按顺序存储风火轮的四个状态pos  dw  4;字符的索引delay equ 1; 计时器延迟计数count db delay; 计时器计数变量，初值=delayTimer:    push ax    push bx    push cx    push dx    push bp    push es    push ds    movax,0B800h    moves,ax    mov ah,0Fh        dec byte ptr [count]    jnz end1        mov bx, word ptr[pos]    mov al,byte ptr[char+bx];获取新的字符    mov [es:((80*24+79)*2)] , ax        mov byte ptr[count],delay    dec word ptr[pos]    jz loop1;若pos已为0，end1:    mov al,20h; AL = EOI    out 20h,al; 发送EOI到主8529A    out 0A0h,al; 发送EOI到从8529A        pop ds    pop es     pop bp    pop dx     pop cx    pop bx    pop ax    iretloop1:    mov word ptr[pos], 4    jmp end1</code></pre><p>而在监控程序<code>monitor.asm</code>，也需要进行修改。在程序开始之前，需要将Timer设置到时钟中断的位置。注意！！！在这之后需要对寄存器重新设置初始值。</p><pre><code class="hljs asm">xor ax,ax; AX = 0mov es,ax; ES = 0mov word ptr es:[20h],offset Timermov ax,cs mov word ptr es:[22h],axmov ax,csmov ds,ax; DS = CSmov es,ax; ES = CSmov ss,ax; SS = cs</code></pre><h4 id="3-先尝试使用键盘中断实现风火轮">3.先尝试使用键盘中断实现风火轮</h4><p>我们先来尝试一下，把无敌风火轮改写为使用键盘来控制它转动与否。只需要改写一下9号中断向量的段地址和偏移地址，并添加下述代码到Timer这一段代码的最开头。</p><p><code>60h</code>为CPU对应键盘的输入缓冲端口 <code>in al,60h</code>就从键盘缓冲中读取1个byte，到<code>al</code>中。只有这样，才能够判断是否需要发生键盘中断。</p><pre><code class="hljs x86asm"><span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">60h</span></code></pre><p>很快我们就能实现一个由键盘输入控制的风火轮了。</p><h4 id="4-OUCH">4.OUCH!</h4><p>首先，根据上述的方法，我们可以写出一个打印"OUCH! OUCH!"键盘中断程序。基本过程为：</p><pre><code class="hljs plain">寄存器入栈——&gt;输出字符串——&gt;延迟——&gt;清空输出的字符串——&gt;发送EOI——&gt;寄存器出栈——&gt;中断返回</code></pre><p>这里输出字符串，一开始使用的是BIOS中的<code>10h</code>中断，但是出现了一些bug，我改用了循环直接显示字符的方法，具体原因会在后文说明。</p><pre><code class="hljs asm">    ouch_delay equ 50000                    ouch_ddelay equ 2000                    ouch_count dw ouch_delay    ouch_dcount dw ouch_ddelayouch_str db "OUCH! OUCH!"index dw 0Keyboard:    push ax    push bx    push cx    push dx    push bp    push es    push ds    mov word ptr[index], 0showagain:    mov bx,word ptr[index]    add bx,80*3+55    mov ax,2    mul bx    mov bp,ax    movax,0B800h    moves,ax    mov ah,07h          ;  0000：黑底、1111：亮白字（默认值为07h）    mov bx,word ptr[index]    mov al,byte ptr[ouch_str+bx]           ;  AL = 显示字符值（默认值为20h=空格符）    mov es:[bp],ax          ;  显示字符的ASCII码值    inc word ptr[index]    cmp word ptr[index], 11    jnz showagaincontinue:        ;延迟    dec word ptr[ouch_count]             ; 递减计数变量    jnz continue                   ; &gt;0：跳转;    mov word ptr[ouch_count],ouch_delay       ;延时    dec word ptr[ouch_dcount]            ; 递减计数变量    jnz continue    mov word ptr[ouch_count],ouch_delay    mov word ptr[ouch_dcount],ouch_ddelay     ;延时    ;清除    mov ah,6    mov al,0    mov ch,3    mov cl,55    mov dh,3    mov dl,65    mov bh,7    int 10H        in al,60h    mov al,20h    ; AL = EOI    out 20h,al; 发送EOI到主8529A    out 0A0h,al    ; 发送EOI到从8529A        ;中断返回    pop ds    pop es    pop bp    pop dx    pop cx    pop bx    pop ax        iret</code></pre><p>那要如何实现在用户程序运行的过程中，能成功产生键盘中断，同时在用户程序结束后，还能够正常地通过键盘来进行输入与输出呢？</p><p>当运行用户程序时，要先把原有的中断向量口保存起来，然后将自己写的键盘中断<code>Keyboard</code>存放到9号中断位置。</p><pre><code class="hljs asm">xor ax, axmov es, axmov bp,offset interrupt_savedmov word ptr ax,es:[36]mov word ptr [bp],axmov word ptr ax,es:[38]mov word ptr [bp+2],ax mov word ptr es:[36], offset Keyboardmov word ptr es:[38], cs</code></pre><p>在用户程序返回内核之前，把原有键盘中断向量还原回去。</p><pre><code class="hljs asm">xor ax, axmov es, axmov bp,offset interrupt_savedmov word ptr ax,[bp]mov word ptr es:[36],axmov word ptr ax,[bp+2]mov word ptr es:[38],ax</code></pre><h4 id="5-将所有文件进行编译，并写入软盘">5.将所有文件进行编译，并写入软盘</h4><p>这一次，我将用户程序和开机程序都存放到了磁头号为1的地方，以给内核更大的空间。（扇区号0~17，当满18的时候，就要在磁头号+1；而makefile文件中的seek值只需要继续往下数就可以了）</p><pre><code class="hljs makefile">BIN = loader.bin startOS.bin 19335209_A.bin 19335209_B.bin 19335209_C.bin 19335209_D.binIMG = wuhlan.img<span class="hljs-section">all: clear <span class="hljs-variable">$(BIN)</span> <span class="hljs-variable">$(IMG)</span></span><span class="hljs-section">clear:</span>    rm -f <span class="hljs-variable">$(BIN)</span> <span class="hljs-variable">$(IMG)</span><span class="hljs-section">%.bin: %.asm</span>    nasm -fbin <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><span class="hljs-section">%.img:</span>    /sbin/mkfs.msdos -C <span class="hljs-variable">$@</span> 1440    dd if=loader.bin of=<span class="hljs-variable">$@</span> conv=notrunc    dd if=MONITOR.COM of=<span class="hljs-variable">$@</span> seek=1 conv=notrunc    dd if=19335209_A.bin of=<span class="hljs-variable">$@</span> seek=18 conv=notrunc    dd if=19335209_B.bin of=<span class="hljs-variable">$@</span> seek=19 conv=notrunc    dd if=19335209_C.bin of=<span class="hljs-variable">$@</span> seek=20 conv=notrunc    dd if=19335209_D.bin of=<span class="hljs-variable">$@</span> seek=21 conv=notrunc    dd if=startOS.bin of=<span class="hljs-variable">$@</span> seek=22 conv=notrunc</code></pre><h3 id="实验结果">实验结果</h3><p>通过观察，我们可以发现，无论是开机程序还是用户程序都可以成功显示"OUCH! OUCH!"，同时可以看到，无敌风火轮一直在右下角旋转。</p><p><img src="3.png" alt="image-20210416111142520"></p><p><img src="4.png" alt="image-20210416111029567"></p><p><img src="5.png" alt="image-20210416111057382"></p><h3 id="问题与解决方式">问题与解决方式</h3><ol><li><p>延续之前实验出现的错误，当C程序写的过多的时候，字符串的输出就会出现各种莫名错误。解决方法就是，将没有必要的函数如<code>upper()</code>、<code>lower()</code>等函数删除。</p></li><li><p>restart.bin开机动画程序可以显示"OUCH! OUCH!"，但是用户程序无法显示。</p><p>问题原因不太清楚，很可能与BIOS的<code>int 10h</code>调用有关。但是明明我已经将所有寄存器放入栈中。</p><p>我将其修改为直接将字符循环一个个地在窗口中显示，最终用户程序和开机程序都可以成功显示"OUCH!"</p><pre><code class="hljs asm">    mov word ptr[index], 0showagain:    mov bx,word ptr[index]    add bx,80*3+55    mov ax,2    mul bx    mov bp,ax    movax,0B800h    moves,ax    mov ah,07h          ;  0000：黑底、1111：亮白字（默认值为07h）    mov bx,word ptr[index]    mov al,byte ptr[ouch_str+bx]           ;  AL = 显示字符值（默认值为20h=空格符）    mov es:[bp],ax          ;  显示字符的ASCII码值    inc word ptr[index]    cmp word ptr[index], 11    jnz showagain</code></pre></li></ol><h3 id="创新性工作">创新性工作</h3><ol><li>在风火轮三种形态的基础上，再多添加一个横杠，使其更像是在转动</li><li>在"OUCH! OUCH!"出现之后，过一小段时间，会自动清空。给用户以警告——“不要再碰键盘啦！！！”。同时消失之后，不会影响用户程序的观看体验（捂脸，逃~）</li></ol><h3 id="实验总结">实验总结</h3><p>本次实验，是在上一个实验基础上完成的，仅仅加入了两个中断内容。本以为在上次搭好了基本框架后，这一次实验会相对轻松。但是。。。现实并不如我所愿。如果说之前搭的地基就歪了，接下来建造的楼只会越来越歪，最后甚至可能倒塌。</p><p>这次实验除了加入中断向量外，还需要对上次的实验进行完善，工作量并没有减少。首先是对所有的用户程序的扇区号进行后移，以提供给内核更大的空间，在这个过程中，对于磁盘的划分，磁头号扇区等有了更深的理解；其次是删除了C语言中冗余的函数；还有就是重写用户程序，曾经自以为是地使用“Esc”来返回用户程序，如今在用户程序运行的过程中，因为键盘中断被改写了，只好使用户程序在运行到某个特定地时刻，就自动返回监控程序。</p><p>本次实验重点学习了，中断向量表相关知识、用户程序执行过程中是如何发生中断的。在写中断程序相关的函数时，我特别地小心，在刚开始的时候就尽量将用到的所有寄存器都入栈，防止寄存器混乱出现莫名的错误。时间中断是相对容易实现的，只需要加入 入栈出栈的操作，并且在监控程序启动的时候就将该代码段存入中断向量表就可以了。但是键盘中断要复杂很多，涉及到用户程序启动时改变键盘中断，用户程序结束后恢复键盘中断的操作。而且很容易与现有的用户程序产生冲突，所以花的时间多很多。另外，我会尽可能地在一些完成一个小步骤或是小修改之后，就立刻进行编译debug，防止错误过多，到后期难以处理。</p><p>最后，希望接下来的操作系统实验能顺顺利利吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀树Trie</title>
    <link href="/Wuhlan3/2021/04/14/%E5%89%8D%E7%BC%80%E6%A0%91Trie/"/>
    <url>/Wuhlan3/2021/04/14/%E5%89%8D%E7%BC%80%E6%A0%91Trie/</url>
    
    <content type="html"><![CDATA[<h3 id="力扣——208-实现-Trie-前缀树"><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">力扣——208. 实现 Trie (前缀树)</a></h3><h3 id="题目">题目</h3><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>样例如下：</p><pre><code class="hljs pgsql">输入["Trie", "insert", "search", "search", "startsWith", "insert", "search"][[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]输出[<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>]解释Trie trie = <span class="hljs-built_in">new</span> Trie();trie.<span class="hljs-keyword">insert</span>("apple");trie.<span class="hljs-keyword">search</span>("apple");   // 返回 <span class="hljs-keyword">True</span>trie.<span class="hljs-keyword">search</span>("app");     // 返回 <span class="hljs-keyword">False</span>trie.startsWith("app"); // 返回 <span class="hljs-keyword">True</span>trie.<span class="hljs-keyword">insert</span>("app");trie.<span class="hljs-keyword">search</span>("app");     // 返回 <span class="hljs-keyword">True</span></code></pre><h3 id="算法思路">算法思路</h3><p>简单来说，前缀树就是一个26-叉树。</p><p>每个节点是一个结构体：</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span>{</span>    <span class="hljs-built_in">vector</span>&lt;Trie*&gt; children;  <span class="hljs-comment">//存储所有可能的下一个节点 大小为26的数组</span>    <span class="hljs-keyword">bool</span> isEnd;<span class="hljs-comment">//用于判断是否为单词的结尾</span>}</code></pre><p><img src="3.jpg" alt="来自算法4"></p><p>忽略了空节点之后可以简化为如下形式：</p><p><img src="2.jpg" alt="img"></p><h3 id="代码实现">代码实现</h3><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> {</span><span class="hljs-keyword">private</span>:    <span class="hljs-built_in">vector</span>&lt;Trie*&gt; child;    <span class="hljs-keyword">bool</span> isEnd = <span class="hljs-literal">false</span>;<span class="hljs-keyword">public</span>:    <span class="hljs-comment">/** Initialize your data structure here. */</span>    Trie():child(<span class="hljs-number">26</span>),isEnd(<span class="hljs-number">0</span>) {}        <span class="hljs-comment">/** Inserts a word into the trie. */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word)</span> </span>{        Trie* node = <span class="hljs-keyword">this</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : word){            <span class="hljs-keyword">int</span> pos = c - <span class="hljs-string">'a'</span>;            <span class="hljs-keyword">if</span>(node-&gt;child[pos] == <span class="hljs-literal">nullptr</span>){                node-&gt;child[pos] = <span class="hljs-keyword">new</span> Trie();            }            node = node-&gt;child[pos];        }        node-&gt;isEnd = <span class="hljs-number">1</span>;    }        <span class="hljs-comment">/** Returns if the word is in the trie. */</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word)</span> </span>{        Trie* node = <span class="hljs-keyword">this</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : word){            <span class="hljs-keyword">int</span> pos = c - <span class="hljs-string">'a'</span>;            <span class="hljs-keyword">if</span>(node-&gt;child[pos] == <span class="hljs-literal">nullptr</span>){                node = node-&gt;child[pos];                <span class="hljs-keyword">break</span>;            }            node = node-&gt;child[pos];        }        <span class="hljs-keyword">if</span>(node != <span class="hljs-literal">nullptr</span> &amp;&amp; node-&gt;isEnd == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    }        <span class="hljs-comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(<span class="hljs-built_in">string</span> prefix)</span> </span>{        Trie* node = <span class="hljs-keyword">this</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : prefix){            <span class="hljs-keyword">int</span> pos = c - <span class="hljs-string">'a'</span>;            <span class="hljs-keyword">if</span>(node-&gt;child[pos] == <span class="hljs-literal">nullptr</span>){                node = node-&gt;child[pos];                <span class="hljs-keyword">break</span>;            }            node = node-&gt;child[pos];        }        <span class="hljs-keyword">if</span>(node != <span class="hljs-literal">nullptr</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    }};</code></pre><p>但是，我们发现函数的重复率非常高，可以写一个搜索前缀的函数，修改为如下形式：</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> {</span><span class="hljs-keyword">private</span>:    <span class="hljs-built_in">vector</span>&lt;Trie*&gt; child;    <span class="hljs-keyword">bool</span> isEnd = <span class="hljs-literal">false</span>;        <span class="hljs-function">Trie* <span class="hljs-title">search_prefix</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word)</span></span>{        Trie* node = <span class="hljs-keyword">this</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : word){            <span class="hljs-keyword">int</span> pos = c - <span class="hljs-string">'a'</span>;            <span class="hljs-keyword">if</span>(node-&gt;child[pos] == <span class="hljs-literal">nullptr</span>){                <span class="hljs-keyword">return</span> node-&gt;child[pos];            }            node = node-&gt;child[pos];        }        <span class="hljs-keyword">return</span> node;    }<span class="hljs-keyword">public</span>:    <span class="hljs-comment">/** Initialize your data structure here. */</span>    Trie():child(<span class="hljs-number">26</span>),isEnd(<span class="hljs-number">0</span>) {}        <span class="hljs-comment">/** Inserts a word into the trie. */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word)</span> </span>{        Trie* node = <span class="hljs-keyword">this</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : word){            <span class="hljs-keyword">int</span> pos = c - <span class="hljs-string">'a'</span>;            <span class="hljs-keyword">if</span>(node-&gt;child[pos] == <span class="hljs-literal">nullptr</span>){                node-&gt;child[pos] = <span class="hljs-keyword">new</span> Trie();            }            node = node-&gt;child[pos];        }        node-&gt;isEnd = <span class="hljs-number">1</span>;    }        <span class="hljs-comment">/** Returns if the word is in the trie. */</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word)</span> </span>{        Trie* node = search_prefix(word);        <span class="hljs-keyword">if</span>(node != <span class="hljs-literal">nullptr</span> &amp;&amp; node-&gt;isEnd == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    }        <span class="hljs-comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(<span class="hljs-built_in">string</span> prefix)</span> </span>{        Trie* node = search_prefix(prefix);        <span class="hljs-keyword">if</span>(node != <span class="hljs-literal">nullptr</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    }};</code></pre><h3 id="拓展一下">拓展一下</h3><p><strong>压缩前缀树</strong></p><p>由于一个字母占用一个节点（含有大小为26的数组），非常浪费空间。压缩前缀树是前缀树的一种优化方案。</p><p><img src="1.jpg" alt="img"></p><h3 id="应用场景">应用场景</h3><p>当然在本题中前缀树起到的作用仅仅是判断是否收录了某个单词。在实际应用中可以通过修改isEnd为一个值，形成健与值的映射，增加应用范围。</p><p>这种时候，我们很自然地就会将前缀树与哈希表进行对比。</p><ul><li><p>哈希表</p><p>当哈希表hash函数选取的好，计算量少且冲突少时，效率可达$O(1)$。</p><p>哈希表不能支持动态查询功能（即写前缀，显示后缀）</p></li><li><p>前缀树</p><p>前缀树的时间复杂度为$O(L)$，其中$L$为字符串长度。处理大量字符串的时候，效率比哈希表高。但是额外消耗的空间较大。经典：以空间换时间。</p></li></ul><ol><li><p>字符串的快速检索</p></li><li><p>字符串排序</p></li><li><p>最长公共前缀</p></li><li><p>自动匹配前缀显示后缀</p><p>如我们在搜索引擎和字典中输入前面的东西，会自动显示后面的内容。（只需把后缀遍历显示出来）</p></li></ol><h3 id="参考资料">参考资料</h3><p>https://zhuanlan.zhihu.com/p/46670859</p><p>https://cloud.tencent.com/developer/article/1678886</p><p>https://leetcode-cn.com/problems/implement-trie-prefix-tree/</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实验3：开发独立内核的操作系统</title>
    <link href="/Wuhlan3/2021/04/10/%E5%AE%9E%E9%AA%8C3%EF%BC%9A%E5%BC%80%E5%8F%91%E7%8B%AC%E7%AB%8B%E5%86%85%E6%A0%B8%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/Wuhlan3/2021/04/10/%E5%AE%9E%E9%AA%8C3%EF%BC%9A%E5%BC%80%E5%8F%91%E7%8B%AC%E7%AB%8B%E5%86%85%E6%A0%B8%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1>实验3：开发独立内核的操作系统</h1><h3 id="实验要求">实验要求</h3><ol><li>寻找或测试一套匹配的汇编与c编译器组合。利用c编译器，将一个样板C程序进行编译，获得符号列表文档，分析全局变量、局部变量、变量初始化、函数调用、参数传递情况，确定一种匹配的汇编语言工具，在实验报告中描述这些工作。</li><li>写一个汇编程和c程序混合编程实例，展示你所用的这套组合环境的使用。汇编模块中定义一个字符串，调用C语言的函数，统计其中某个字符出现的次数（函数返回），汇编模块显示统计结果。执行程序可以在DOS中运行。</li><li>重写实验二程序，实验二的的监控程序从引导程序分离独立，生成一个COM格式程序的独立内核，在1.44MB软盘映像中，保存到特定的几个扇区。利用汇编程和c程序混合编程监控程序命令保留原有程序功能，如可以按操作选择，执行一个或几个用户程序、加载用户程序和返回监控程序；执行完一个用户程序后，可以执行下一个。</li><li>利用汇编程和c程序混合编程的优势，多用c语言扩展监控程序命令处理能力。</li><li>重写引导程序，加载COM格式程序的独立内核。</li><li>拓展自己的软件项目管理目录，管理实验项目相关文档</li></ol><p><img src="00.png" alt="image-20210413134036722"></p><h3 id="实验环境">实验环境</h3><h5 id="1-系统与虚拟机">1.系统与虚拟机</h5><ul><li>Windows 10 - x64 18363.1139</li><li>VMware Workstation 16 Player：用于跑ubuntu虚拟机</li><li>Ubuntu 20.04.2 LTS</li><li>VirtualBox-6.1.18-142142-Win：用于运行.img文件</li><li>DOSBox DOS Emulator 0,74,0,0：用于tcc和tasm编译，并且运行.com文件</li></ul><h5 id="2-windows上的相关软件、编译器等">2.windows上的相关软件、编译器等</h5><ul><li>NASM version 2.10.07 compiled on Jan  2 2013</li><li>TCC.EXE：用于16位C语言编程</li><li>TLINK.EXE：用于C语言与汇编语言链接</li><li>TASM.EXE：用于.asm文件的汇编</li></ul><h5 id="3-Ubuntu上的相关软件、编译器等">3.Ubuntu上的相关软件、编译器等</h5><ul><li>NASM version 2.14.02</li><li>makefile：GNU Make 4.2.1</li></ul><h3 id="实验前置知识">实验前置知识</h3><h5 id="1-汇编调用C中的函数与变量">1.汇编调用C中的函数与变量</h5><ul><li><p>在C语言中要把相关变量和函数定义在全局之中；</p></li><li><p>在汇编中要把调用的函数名与变量编程这样的形式<code>extrn _a</code>（加入了extrn和下划线），这是因为C语言在汇编后，会自动在所有变量名前面添加下划线，这可以使程序员不必为了变量名可能重名而小心翼翼。</p></li></ul><h5 id="2-C调用汇编中的函数与变量">2.C调用汇编中的函数与变量</h5><ul><li>汇编的所有函数名前面需要添加下划线，并且使用public来声明使变量成为全局变量</li><li>在C语言中使用extern来声明调用的函数，如<code>extern int sum(int a, int b);</code></li></ul><h3 id="实验过程">实验过程</h3><h4 id="1-掌握编译方法（tcc-tasm-tlink）">1.掌握编译方法（tcc+tasm+tlink）</h4><p>由于tcc和tasm都是16位的，它们无法在windows或linux下运行，所以我们需要在dosbox下编译和链接。</p><p>编译的命令主要是：</p><pre><code class="hljs shell">tcc -mt -c -oupper.obj upper.c &gt; ccmsg.txttasm showstr.asm showstr.obj &gt; amsg.txttlink /3 /t showstr.obj upper.obj, showstr.com,,</code></pre><p>当然，也有批处理的方式（老师提供的文件中有这几个写好的文件）：</p><p><img src="0" alt="image-20210408194105037"></p><p>打开文件，可以看到运行方式：</p><pre><code class="hljs shell">ta showstrtc uppertl showstr upper</code></pre><p><img src="1.png" alt="image-20210408194341220"></p><p><img src="2.png" alt="image-20210408194405268"></p><p><img src="3.png" alt="image-20210408194656964"></p><p>可以看到在这个过程中，C程序编译生成.obj文件，asm文件汇编生成.obj文件，再通过tlink将两个.obj文件链接成.com文件。最终运行结果正确，字符串中的所有字符从小写转为大写。</p><h4 id="2-写一个汇编程序和c程序混合编程实例">2.写一个汇编程序和c程序混合编程实例</h4><p>由于考虑到在后续的实验过程中我还会需要用到各种函数。并且我猜想，如果把所有IO操作/程序调用的相关函数准备好，以C语言作为主要的编程语言，我将可以非常轻松的完成自己的操作系统。</p><p>我的<strong>monitor.asm</strong>文件如下，它的主要功能是准备好各种全局变量，比如字符串Message，调用准备好的asm函数库，并且在程序运行后，立刻跳入我的mymain函数中。</p><pre><code class="hljs asm">extrn _mymain:nearpublic _Message.8086_TEXT segment byte public 'CODE'DGROUP group _TEXT,_DATA,_BSS       assume cs:_TEXTorg 100hstart:    mov ax,cs    mov ds,ax; DS = CS    mov es,ax; ES = CS    mov ss,ax; SS = cs    call near ptr _mymain ;跳入C里的mymain函数  jmp $    include asm_lib.asm;调用汇编函数库_datadef:    _Message db 'WuHaolan 19335209 WuHaolan 19335209  ',0;一个全局定义的字符串_TEXT ends;************DATA segment*************_DATA segment word public 'DATA'_DATA ends;*************BSS segment*************_BSSsegment word public 'BSS'_BSS ends;**************end of file***********end start</code></pre><p>汇编函数库<strong>asm_lib.asm</strong>中，只写了一个字符输出的函数。（具体的相关内容我会在后文解释）</p><pre><code class="hljs asm">;输出字符public _printChar_printChar proc     push bp    mov bp,sp    mov al,[bp+4]    mov bl,0    mov ah,0eh    int 10h    mov sp,bp    pop bp    ret_printChar endp</code></pre><p>C语言函数库<strong>main.c</strong>中，准备了字符串输出函数<code>print_str(char * str)</code>，数字输出函数<code>print_int(int num)</code>，小写转大写函数<code>upper()</code>，统计字符串中的"a"的数量的函数<code>word_cnt(char* str)</code>，主函数<code>mymain()</code></p><pre><code class="hljs c++"> <span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> Message[];<span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printChar</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span></span>;<span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">char</span> buf[<span class="hljs-number">20</span>];upper(){   <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span>(Message[i]) {     <span class="hljs-keyword">if</span> (Message[i]&gt;=<span class="hljs-string">'a'</span>&amp;&amp;Message[i]&lt;=<span class="hljs-string">'z'</span>)        Message[i]=Message[i]+<span class="hljs-string">'A'</span>-<span class="hljs-string">'a'</span>;      i++;    }}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_str</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* str)</span></span>{    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(str[i]){        printChar(str[i]);        i++;    }}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_int</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>{    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(num&gt;<span class="hljs-number">0</span>){        buf[i] = num % <span class="hljs-number">10</span> + <span class="hljs-string">'0'</span>;        num = num / <span class="hljs-number">10</span>;        i++;    }    buf[i] = <span class="hljs-string">'\0'</span>;    <span class="hljs-keyword">for</span> (i = i<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>;i--){        printChar(buf[i]);    }}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">word_cnt</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* str)</span></span>{    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    cnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(str[i]){        <span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">'a'</span>){            cnt++;        }        i++;    }    print_int(cnt);}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mymain</span><span class="hljs-params">( )</span></span>{    print_str(Message);    word_cnt(Message);    <span class="hljs-keyword">return</span>;}</code></pre><p>如图，可以看到，字符串<code>"WuHaolan 19335209 WuHaolan 19335209  "</code>中，总共有4个<code>'a'</code>，结果正确</p><p><img src="4.png" alt="image-20210408231153207"></p><h4 id="3-生成一个COM格式程序的独立内核">3.生成一个COM格式程序的独立内核</h4><p>基本架构：</p><ul><li>内核：MONITOR.COM由monitor.asm + main.c + asm_lib.asm 构成。</li><li>引导程序：loader.asm</li><li>开机图标：startOS.asm</li><li>用户程序：1.asm 2.asm 3.asm 4.asm</li></ul><p>接下来我将按顺序分别说明每个程序：</p><p>（1）monitor.asm的作用更像是一个桥，他起到连接C中的主函数、C函数库与汇编函数库的作用。使用<code>call</code>直接进入C函数，这是因为我对于tasm语法不够熟悉（这种上古级汇编语言），能找到相关的资料也有限。我不希望花太多功夫在汇编程序上，使用C语言来编程，我会更将轻松一些。使用<code>include</code>可以引入在另一个文件里的汇编函数库asm_lib.asm，分开文件来编写，会更加清晰一些。在最后只需要对monitor.asm和main.c进行编译即可。</p><pre><code class="hljs asm">extrn _mymain:near.8086_TEXT segment byte public 'CODE'DGROUP group _TEXT,_DATA,_BSS       assume cs:_TEXTorg 100hstart:    mov ax,cs    mov ds,ax; DS = CS    mov es,ax; ES = CS    mov ss,ax; SS = cs        call near ptr _mymain ;进入C主程序  jmp $    include asm_lib.asm ;使用include引用汇编函数库_TEXT ends;************DATA segment*************_DATA segment word public 'DATA'_DATA ends;*************BSS segment*************_BSSsegment word public 'BSS'_BSS ends;**************end of file***********end start</code></pre><p>（2）asm_lib.asm中包含了一些常用的I/O操作、清屏、将程序导入内存的过程、获取时间的过程。这些过程大都与底层硬件交互有关，在此基础上才能写出C函数库。</p><p>写汇编函数的基本方法是，以<code>函数名+proc</code>为开头，将使用到的关键寄存器<code>push</code>，并在使用后<code>pop</code>，最后<code>ret</code>以返回到调用的代码地址，以<code>函数名+endp</code>为结尾。</p><p>（i）输出一个字符</p><p>使用下述的这种功能号，可以使得输出字符，同时光标会往后移。要怎么寻找到入栈的变量呢？想将栈寄存器sp的值赋给bp，此时栈中已经压入了bp和ip，要想找到新传入的参数ch，就要将bp+4。</p><p><img src="5.png" alt="image-20210410115600056"></p><pre><code class="hljs asm">public _printChar_printChar proc     push bp    mov bp,sp    mov al,[bp+4]   ;ch\ip\bp  通过bp来寻找变量，需要bp+4    mov bl,0;测试过，非图形模式无法改变颜色    mov ah,0eh;功能号0eh teletype模式    int 10h    mov sp,bp    pop bp    ret_printChar endp</code></pre><p>（ii）输入一个字符</p><p>这只是直接获取一个字符，并将其赋值给变量cin。但是想要达成边输入边显示和光标后移的效果，需要在C函数中再做更多的处理。</p><pre><code class="hljs asm">;输入字符public _Readchar_Readchar proc    mov ah,0    int 16h    mov byte ptr [_cin],al;将输入的值赋给cin变量    ret_Readchar endp</code></pre><p>（iii）清屏</p><p>由于使用到的寄存器较多，需要将它们都入栈。调用中断int 10h，进行清屏。</p><pre><code class="hljs asm">public _cls_cls proc ; 清屏    push ax    push bx    push cx    push dx    movax, 600h; AH = 6,  AL = 0    movbx, 700h; 黑底白字(BL = 7)    movcx, 0; 左上角: (0, 0)    movdx, 184fh; 右下角: (24, 79)    int10h; 显示中断    mov ah,2    mov bh,0    mov dx,0    int 10h    pop dx    pop cx    pop bx    pop ax    ret_cls endp</code></pre><p>（iv）载入用户程序</p><p>基本结构与实验2中的类似，不再赘述。</p><p>这个函数会传递一个参数，对应的是扇区号。通过bp来寻得该参数，然后将该扇区的代码端加载到内存中。</p><pre><code class="hljs asm">public _RunProm_RunProm proc    push ds    push es    push bp    mov bp,sp    mov ax,cs                ;段地址 ; 存放数据的内存基地址    mov es,ax                ;设置段地址（不能直接mov es,段地址）    mov bx, OffSetOfUserPrg  ;偏移地址; 存放数据的内存偏移地址    mov ah,2                 ; 功能号    mov al,1                 ;扇区数    mov dl,0                 ;驱动器号 ; 软盘为0，硬盘和U盘为80H    mov dh,0                 ;磁头号 ; 起始编号为0    mov ch,0                 ;柱面号 ; 起始编号为0    mov cl,[bp+8]            ;起始扇区号 ; 起始编号为1    int 13H ;                调用读磁盘BIOS的13h功能    ; 用户程序a.com已加载到指定内存区域    mov bx,OffSetOfUserPrg     call bx ;执行用户程序    pop bp    pop  es    pop  ds      ret_RunProm endp</code></pre><p>（v）获取系统时间</p><p>调用BIOS中的<code>int 1ah</code>，功能号<code>02h</code>，可以得到小时、分钟、秒的BCD格式编码。比如现在时14：42：50，得到的数字是（0x14：0x42：0x50）。</p><p><img src="6.png" alt="image-20210410143818187"></p><pre><code class="hljs asm">public _time_time proc    push ax    push bx    push cx    push dx        mov ah,02h    int 1ah    mov byte ptr[_h], ch    mov byte ptr[_min], cl    mov byte ptr[_sec], dh        pop dx    pop cx    pop bx    pop ax    ret_time endp</code></pre><p>（3）main.c中包含了主函数与一些常用的C函数</p><p>该文件中，主要包含了C函数库，与<code>mymain()</code>函数，是整个OS最核心部分</p><p>（i）输出相关函数</p><p>使用汇编函数库中的<code>extern void printChar(char c);</code>，分别写出一个字符串与数字的输出函数</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_str</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* str)</span></span>{    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(str[i]){        printChar(str[i]);        i++;    }}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_int</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>{    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(!num)printChar(<span class="hljs-string">'0'</span>);    <span class="hljs-keyword">while</span>(num&gt;<span class="hljs-number">0</span>){        buf[i] = num % <span class="hljs-number">10</span> + <span class="hljs-string">'0'</span>;        num = num / <span class="hljs-number">10</span>;        i++;    }    <span class="hljs-keyword">for</span> (i = i<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>;i--){        printChar(buf[i]);    }}</code></pre><p>（ii）输入函数</p><p>调用readchar来读取一行字符串。由于<code>readchar</code>已经读取的字符存入<code>cin</code>，根据回车键（ASCII码为：13）来判断什么时候输入结束，需要判断用户是否按下退格键（ASCII码为：8），由于退格键的效果只能使得光标后退一个，而不能使字符去除。所以我们可以反复输出空格键和退格键，达成我们习惯的效果。具体过程可看下面代码的注释。</p><p><img src="7.png" alt="img"></p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_str</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* cin_line)</span></span>{    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;    Readchar();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>!=<span class="hljs-number">13</span>){        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cin</span>==<span class="hljs-number">8</span>){            printChar(<span class="hljs-built_in">cin</span>);<span class="hljs-comment">//如 abcd， 此时光标在d处</span>            printChar(<span class="hljs-number">32</span>);<span class="hljs-comment">// abc _， 此时光标在空格后面</span>            i--;            printChar(<span class="hljs-built_in">cin</span>);<span class="hljs-comment">// abc_， 再次回退，是光标位于c后面</span>            Readchar();            <span class="hljs-keyword">continue</span>;        }        printChar(<span class="hljs-built_in">cin</span>);        cin_line[i]=<span class="hljs-built_in">cin</span>;          i++;        Readchar();    }    cin_line[i]=<span class="hljs-string">'\0'</span>;}</code></pre><p>（iii）几个字符串处理函数：<code>void word_cnt(char* str, char c );</code>、<code>void upper(char * str);</code>、<code>void lower(char * str);</code>、<code>int isstr_eql(char* a, char* b);</code>，此处不必赘述。</p><p>（iv）输出当前的时间</p><p>根据上述我们得到了时间参数的BCD码，它是十六进制的，所以我们只需要<code>temp= h/16*10 + h%16;</code>，就可以得到十进制的时间。</p><p>吐槽：由于没有给三个变量初始化，我硬是debug了半个小时。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_time</span><span class="hljs-params">()</span></span>{    h = <span class="hljs-number">0</span>;    min = <span class="hljs-number">0</span>;    sec = <span class="hljs-number">0</span>;    time();    temp= h/<span class="hljs-number">16</span>*<span class="hljs-number">10</span> + h%<span class="hljs-number">16</span>;    <span class="hljs-keyword">if</span>(temp == <span class="hljs-number">0</span>){        print_str(<span class="hljs-string">"00"</span>);    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp &lt; <span class="hljs-number">10</span>){        printChar(<span class="hljs-string">'0'</span>);        print_int(temp);    }<span class="hljs-keyword">else</span>{        print_int(temp);    }    printChar(<span class="hljs-string">':'</span>);    temp= min/<span class="hljs-number">16</span>*<span class="hljs-number">10</span> + min%<span class="hljs-number">16</span>;    <span class="hljs-keyword">if</span>(temp == <span class="hljs-number">0</span>){        print_str(<span class="hljs-string">"00"</span>);    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp &lt; <span class="hljs-number">10</span>){        printChar(<span class="hljs-string">'0'</span>);        print_int(temp);    }<span class="hljs-keyword">else</span>{        print_int(temp);    }    printChar(<span class="hljs-string">':'</span>);    temp= sec/<span class="hljs-number">16</span>*<span class="hljs-number">10</span> + sec%<span class="hljs-number">16</span>;    <span class="hljs-keyword">if</span>(temp == <span class="hljs-number">0</span>){        print_str(<span class="hljs-string">"00"</span>);    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp &lt; <span class="hljs-number">10</span>){        printChar(<span class="hljs-string">'0'</span>);        print_int(temp);    }<span class="hljs-keyword">else</span>{        print_int(temp);    }}</code></pre><p>（v）指令判断函数<code>void get_command(char* str);</code></p><p>根据输入的字符串，进行分支判断是那种指令，如果不存在该指令则输出“非法指令”。</p><p>（vi）主函数</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mymain</span><span class="hljs-params">( )</span></span>{    cls();<span class="hljs-comment">//清屏</span>    RunProm(<span class="hljs-number">16</span>);<span class="hljs-comment">//跑开机标志的程序</span>    start();<span class="hljs-comment">//输入打招呼的语句</span>    is_loop = <span class="hljs-number">1</span>;<span class="hljs-comment">//用于判断是否结束循环</span>    <span class="hljs-keyword">while</span>(is_loop){        print_str(<span class="hljs-string">"\r\n&gt;&gt;&gt;"</span>);        get_str(Message);<span class="hljs-comment">//输入命令</span>        get_command(Message);<span class="hljs-comment">//执行命令</span>    }}</code></pre><p>（vii）文件目录</p><p>使用了一个结构体来储存文件信息，并且有函数可以直接输出所有文件信息</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fileContent</span>{</span>    <span class="hljs-keyword">char</span> filename[<span class="hljs-number">20</span>];    <span class="hljs-keyword">char</span> filesize[<span class="hljs-number">10</span>];    <span class="hljs-keyword">char</span> filesector[<span class="hljs-number">10</span>];};<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fileContent</span> <span class="hljs-title">content</span>[5]={</span>    {<span class="hljs-string">"1.bin"</span> , <span class="hljs-string">"401 bytes"</span>, <span class="hljs-string">"sec 12"</span>},    {<span class="hljs-string">"2.bin"</span> , <span class="hljs-string">"348 bytes"</span>, <span class="hljs-string">"sec 13"</span>},    {<span class="hljs-string">"3.bin"</span> , <span class="hljs-string">"365 bytes"</span>, <span class="hljs-string">"sec 14"</span>},    {<span class="hljs-string">"4.bin"</span> , <span class="hljs-string">"401 bytes"</span>, <span class="hljs-string">"sec 15"</span>},    {<span class="hljs-string">"startOS.bin"</span> , <span class="hljs-string">"512 bytes"</span>, <span class="hljs-string">"sec 16"</span>}};</code></pre><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(isstr_eql(str,<span class="hljs-string">"list"</span>)){        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i ++){            print_str(content[i].filename);            printChar('  ');            print_str(content[i].filesize);            printChar('  ');            print_str(content[i].filesector);            print_str(<span class="hljs-string">"\r\n"</span>);        }</code></pre><p>（4）引导程序loader.asm，主要作用是当虚拟机开启的时候，立刻跳转到内核文件。所以需要<code>org 7c00h</code>，以便开机执行。然后把从扇区中将内核程序载入到内存中，控制权交给内核。注意：需要确保512B的大小，并且以<code>55aa</code>结尾。</p><pre><code class="hljs asm">org  7c00h; BIOS将把引导扇区加载到0:7C00h处，并开始执行OS_offset equ 0A100hReadOs:    mov ax,cs                ;段地址 ; 存放数据的内存基地址    mov es,ax                ;设置段地址（不能直接mov es,段地址）    mov bx, OS_offset       mov ah,2                 ;功能号    mov al,5                 ;扇区数，内核占用扇区数  注意：不止加载了一个扇区    mov dl,0                 ;驱动器号 ; 软盘为0，硬盘和U盘为80H    mov dh,0                 ;磁头号 ; 起始编号为0    mov ch,0                 ;柱面号 ; 起始编号为0    mov cl,2                 ;2号扇区存放的是内核程序    int 13H  ;调用读磁盘BIOS的13h功能    jmp 0a00h:100htimes 510 - ($ - $$) db 0 db 0x55db 0xaa</code></pre><p>（5）StartOS.asm，是开机显示标志的程序</p><p>考虑到Windows和Linux开机都会由一段动画。我也决定做一个，但是做出动态的动画要花更多的时间，所以我制作了一个标志，这样能够使大家对我的操作系统印象更加深刻。</p><p>使用了三次清屏过程，来达成显示三个不同颜色框框的效果。将几行文字输出，并且仿照老师最初给的程序，使用两个延时器，达成延迟的效果。</p><pre><code class="hljs asm">    delay equ 50000                    ddelay equ 35000                org 8c00hstart:    xor ax,ax; AX = 0   程序加载到0000：100h才能正确执行    mov ax,cs; 开机这些寄存器都为0    mov es,ax; ES = 0    mov ds,ax; DS = CS    mov es,ax; ES = CS    movax,0B800h; 文本窗口显存起始地址    movgs,ax; GS = B800h    mov ah,6;清屏成蓝色 显示在显示屏幕中部    mov al,0 ;0全屏幕为空白        mov ch,4 ;左上角行号    mov cl,14 ;左上角列号    mov dh,20;右下角行号    mov dl,66;右下角列号    mov bh,00010010b;蓝色 00010010    int 10h        mov ch,5 ;左上角行号    mov cl,18 ;左上角列号    mov dh,19;右下角行号    mov dl,62;右下角列号    mov bh,00110010b;青色 00110010    int 10h        mov ch,6 ;左上角行号    mov cl,22 ;左上角列号    mov dh,18;右下角行号    mov dl,58;右下角列号    mov bh,00100010b;绿色 00100010        int 10hprint:    mov cx,11    mov ax,str0    mov si,ax    mov bp,1172    loop1:    push cx    mov cx,29     loop2:    mov ah,0fh    mov al,[si]                   mov word[gs:bp],ax    inc si    add bp,2    sub cx,1    jnz loop2    add bp,102    pop cx    sub cx,1       jnz loop1loop3:;延迟    dec word[count]             ; 递减计数变量    jnz loop3                   ; &gt;0：跳转;    mov word[count],delay       ;延时    dec word[dcount]            ; 递减计数变量    jnz loop3    mov word[count],delay    mov word[dcount],ddelay     ;延时return:     retdatadef:   str0 db  " --------------------------- "        db  " |            *     *      | "        db  " |          ***********    | "        db  " |    ***      *   *       | "        db  " |   *   *   *********     | "        db  " |   *   *  *    *    *    | "        db  " |    ***   ***********    | "        db  " |          *    *    *    | "        db  " |           *********     | "        db  " --------------------------- "        db  "        Wuhlan3's OS!        "    count dw delay    dcount dw ddelaytimes 512 - ($ - $$) db 0</code></pre><p>（6）4个用户程序，由于只做了一定的修改，便不在此处放出来了。关于如何返回内核程序，会在下文提及。</p><h4 id="4-将所有文件进行编译，并写入软盘">4.将所有文件进行编译，并写入软盘</h4><p>回想起实验二中，为了写盘，每一次修改程序，都需要使用软件Winhex，来注意复制二进制文件再粘贴。实在太浪费时间了！！！“写程序一分钟，编译五分钟”。</p><p>因此，这次学习了一下makefile，并结合linux中的创建软盘功能，子啊Ubuntu中进行编译与写盘。</p><p>由于.com程序已经再dosbox中编译成功，所以只需要对所有.asm文件使用nasm进行编译。生成一个1.44MB的软盘，将所有的文件写入相应的扇区之中。</p><pre><code class="hljs makefile">BIN = loader.bin startOS.bin 1.bin 2.bin 3.bin 4.binIMG = wuhlan.img<span class="hljs-section">all: clear <span class="hljs-variable">$(BIN)</span> <span class="hljs-variable">$(IMG)</span></span><span class="hljs-section">clear:</span>    rm -f <span class="hljs-variable">$(BIN)</span> <span class="hljs-variable">$(IMG)</span><span class="hljs-section">%.bin: %.asm</span>    nasm -fbin <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><span class="hljs-section">%.img:</span>    /sbin/mkfs.msdos -C <span class="hljs-variable">$@</span> 1440    dd if=loader.bin of=<span class="hljs-variable">$@</span> conv=notrunc    dd if=MONITOR.COM of=<span class="hljs-variable">$@</span> seek=1 conv=notrunc    dd if=1.bin of=<span class="hljs-variable">$@</span> seek=11 conv=notrunc    dd if=2.bin of=<span class="hljs-variable">$@</span> seek=12 conv=notrunc    dd if=4.bin of=<span class="hljs-variable">$@</span> seek=13 conv=notrunc    dd if=3.bin of=<span class="hljs-variable">$@</span> seek=14 conv=notrunc    dd if=startOS.bin of=<span class="hljs-variable">$@</span> seek=15 conv=notrunc</code></pre><h3 id="实验结果">实验结果</h3><p>开机标志：</p><p><img src="8.png" alt=""></p><p>help：</p><p><img src="9.png" alt=""></p><p>time/upper/wordcnt/list</p><p><img src="10.png" alt="image-20210410163703788"></p><p>用户程序，以1.bin为例</p><p><img src="11.png" alt="image-20210410163753431"></p><h3 id="问题与解决方式">问题与解决方式</h3><ol><li>使用gcc+nasm的编译和链接方式的时候，打印出来的字符始终为AaBbCcDdEe，小写转换为大写的函数没有发挥作用。与同学交流后无果，最终还是选择使用tcc+tasm的编译和链接方式。</li></ol><img src="12.png" alt="image-20210406194248993" style="zoom: 67%;"><ol start="2"><li><p>我实在厌恶了每次打开dosbox都要mount，浪费时间！！！！！！！</p><p>可以在这个路径下的文件中添加几行命令，每次打开dosbox都会自动mount到指定路径，甚至可以将所需工具添加到环境变量中。这将大大提高开发效率！！！</p><img src="13.png" alt="image-20210408200911202" style="zoom: 40%;"><pre><code class="hljs cmd">mount c: C:\Users\administrator\Desktop<span class="hljs-function">c:</span><span class="hljs-function"><span class="hljs-title">cd</span> <span class="hljs-title">newos</span></span></code></pre></li><li><p>如何加快dosbox中的编译的速度呢？</p><p>仿照老师提供的几个bat文件，我们也可以自己写出一个bat文件，它将会一键达成编译链接的所有过程.</p><p>这也将大大提高开发效率！！！</p><pre><code class="hljs cmd"><span class="hljs-built_in">del</span> *.obj<span class="hljs-built_in">del</span> *.comtcc -mt -c -oupper.obj upper.c &gt; ccmsg.txttasm showstr.asm showstr.obj &gt; amsg.txttlink /<span class="hljs-number">3</span> /t showstr.obj upper.obj, showstr.com,,</code></pre></li><li><p>如何从用户程序返回到内核呢？</p><p>本以为直接使用jmp就可以再内核和用户程序之间相互跳转。但是，实际上并不行。经过上网查阅了，很可能是用户程序准备返回的时候，ds与cs寄存器的值被修改了，导致程序运行错误。</p><p>我再尝试了一下使用call 和 ret的组合，结果成功了。</p></li><li><p>发现了一些有趣的玄学问题。</p><p><img src="14.png" alt="image-20210410104746249"></p><p>制表符<code>'\t'</code>或者<code>tab</code>会在virtualbox中显示小圈圈，无法起到制表的效果，但是在dosbox中显示正常</p></li><li><p>C程序中竟然不能有任何的注释，无论是中文还是英文。</p><p>一种可能性应该是tcc并不支持将所有的注释自动删除！！！</p></li></ol><h3 id="创新性工作">创新性工作</h3><ol><li>增加了一个获取系统时间的函数。这里需要查找BIOS中的相应功能号，并且理解BCD码的传递方式</li><li>学习了dosbox的挂载和批处理方式，提高工作效率</li><li>学习写makefile，可以一键完成编译与写盘工作</li><li>添加了一个开机显示标志，使得系统更加完整，并且学习了如何绘画出好看图案（可惜提供的颜色太少了）</li></ol><h3 id="实验总结">实验总结</h3><p>本次实验花了非常多的时间。整个过程是非常绝望的，因为可以说在最开始地七天，毫无进展。哪怕是同学们也都没有找到一个明确的方向。其中仅仅是为了把环境和编译方式确定下来就花了超过一周的时间，而且同学们在q群里也讨论无果。在gcc+nasm+ld这种编译方式，实在反人类，把所有可能性都尝试过了，最后还是失败了。但是转去使用tcc+tasm+tl的组合后，竟然很快就成功了！</p><p>当所有环境和编译方式确定好后，一切就都势如破竹了。接下来就是更深刻地理解汇编语言与C语言之间是如何相互调用的，如何调用用户程序、如何从用户程序返回内核。</p><p>当使用汇编语言写好函数库之后，我们就可以直接进行输入与输出。接下来80%的步骤都只需要使用C语言实现，立刻就变成重复性和细节性的工作。为了能使自己的操作系统与别人与众不同一些，我制作了一个开机就显示的图标，能使人印象更加深刻。</p><p>当然，还有一些问题没有解决，比如C语言当我写道大概230行的时候，我发现再继续写一些字符串处理的函数，就有可能出错！！！（开机之后的个人信息，显示失败）因此，本来写了一个显示系统日期的函数，最后只能删除掉，确保程序不会出错。具体原因呢，我猜想与存放字符串的空间已满有关。希望在后面的实验中，如果再次遇到这个问题，我能解决掉。</p><p>可以说，整个实验过程是大起大落。从完全的黑暗——可能不到一丝希望，到稍微有点起色，就开始疯狂爆肝。怎么说呢，最终看着自己的成果，还是非常开心的！</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网实验——套接字程序设计</title>
    <link href="/Wuhlan3/2021/03/11/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E5%A5%97%E6%8E%A5%E5%AD%97%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/Wuhlan3/2021/03/11/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E5%A5%97%E6%8E%A5%E5%AD%97%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1>计网实验——套接字程序设计</h1><h2 id="遇到的问题">遇到的问题</h2><h3 id="问题一：">问题一：</h3><p><strong>inet_addr在高版本的VS中不能使用</strong></p><p>网络上给出解决方法是:</p><pre><code class="hljs brainfuck"><span class="hljs-comment">项目</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">项目属性</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">c/c</span>++<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">常规</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">SDL检查改为“否”</span></code></pre><p>但是发现还是不行，另外的解决方法是：</p><pre><code class="hljs brainfuck"><span class="hljs-comment">项目</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">项目属性</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">c/c</span>++<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">常规</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">将SDL检查后面的项完全删去</span></code></pre><h3 id="问题二：">问题二：</h3><p><strong>ctime: This function or variable may be unsafe</strong></p><p>解决方法：（貌似，其实问题一解决了，问题二也就不存在了）</p><pre><code class="hljs sqf">属性————预处理器————预处理器定义————添加“<span class="hljs-variable">_CRT_SECURE_NO_WARNINGS</span>”</code></pre><img src="image-20210311202014450.png" alt="image-20210311202014450" style="zoom: 33%;"><img src="image-20210311202043133.png" alt="image-20210311202043133" style="zoom:50%;"><h3 id="问题三：">问题三：</h3><p><strong>字符串与char*的冲突</strong></p><pre><code class="hljs c"><span class="hljs-keyword">char</span>* p = <span class="hljs-string">"abc"</span>;　　<span class="hljs-comment">// valid in C, invalid in C++</span></code></pre><p>解决方法：</p><pre><code class="hljs c++"><span class="hljs-keyword">char</span>* p = (<span class="hljs-keyword">char</span>*)<span class="hljs-string">"abc"</span>;  <span class="hljs-comment">// OK</span><span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *p = <span class="hljs-string">"abc"</span>;　　<span class="hljs-comment">// OK</span></code></pre><h3 id="问题四：">问题四：</h3><p><strong>运行客户端程序而不运行服务器程序会出现什么错误</strong></p><p><img src="wps1.jpg" alt="img"></p><p>Error:10057即,connect 尝试连接时连接不通立即返回</p><p>解决方法：</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> ret = connect(sock, (struct sockaddr*)&amp;<span class="hljs-built_in">sin</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">sin</span>));  <span class="hljs-comment">// 连接到服务器，第二个参数指向存放服务器地址的结构，第三个参数为该结构的大小，返回值为0时表示无错误发生，返回SOCKET_ERROR表示出错，应用程序可通过WSAGetLastError()获取相应错误代码。</span>    <span class="hljs-comment">/*如果没有成功连接到服务器,则ret == -1*/</span>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>){        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"没有成功连接到服务器.\n"</span>);        closesocket(sock);        WSACleanup();        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    }</code></pre><h3 id="问题五：">问题五：</h3><p><strong>服务器如何可以退出循环？</strong></p><p>当接收到exit消息的时候，服务器与客户端同时关闭。</p><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">"exit"</span>)) {            (<span class="hljs-keyword">void</span>)closesocket(ssock);                              <span class="hljs-comment">// 关闭连接套接字</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"服务器已关闭！！！\n"</span>);            <span class="hljs-keyword">break</span>;        }</code></pre><img src="wps3.jpg" alt="img" style="zoom:90%;"><h2 id="前置知识的学习">前置知识的学习</h2><p>结构体<code>sockaddr_in</code></p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span>{</span> <span class="hljs-keyword">short</span> sin_family;<span class="hljs-comment">/*Address family一般来说AF_INET（地址族）PF_INET（协议族）*/</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> sin_port;<span class="hljs-comment">/*端口号 Port number(必须要采用网络数据格式,普通数字可以用htons()函数转换成网络数据格式的数字) */</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span><span class="hljs-comment">/*IP address in network byte order（Internet address）可以用来表示一个32位的IPv4地址，其字节顺序为网络顺序（network byte ordered)，即该无符号整数采用大端字节序*/</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> sin_zero[<span class="hljs-number">8</span>];<span class="hljs-comment">/*Same size as struct sockaddr没有实际意义,只是为了　跟SOCKADDR结构在内存中对齐 */</span> };<span class="hljs-comment">//总字节数：2 + 2 + 4 + 8 = 16</span></code></pre><p>上述结构体中的结构体<code>in_addr</code></p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> {</span>  <span class="hljs-keyword">in_addr_t</span> s_addr;<span class="hljs-comment">/*in_addr_t 一般为 32位的unsigned int，其字节顺序为网络顺序（network byte ordered)，即该无符号整数采用大端字节序</span><span class="hljs-comment"></span><span class="hljs-comment">其中每8位代表一个IP地址位中的一个数值.</span><span class="hljs-comment"></span><span class="hljs-comment">例如192.168.3.144记为0x9003a8c0,其中 c0 为192 ,a8 为 168, 03 为 3 , 90 为 144</span><span class="hljs-comment"></span><span class="hljs-comment">打印的时候可以调用inet_ntoa()函数将其转换为char *类型.*/</span>};</code></pre><h2 id="作业实现">作业实现</h2><p>客户端：</p><p><img src="image-20210312173653068.png" alt="image-20210312173653068"></p><p>服务器：</p><p><img src="wps4.jpg" alt="img"></p><h2 id="TCP程序设计">TCP程序设计</h2><h3 id="编写TCP-client-Echo程序">编写TCP_client_Echo程序</h3><pre><code class="hljs c"><span class="hljs-comment">/* TCPClient.cpp */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;winsock2.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>BUFLEN2000                  <span class="hljs-comment">// 缓冲区大小</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WSVERSMAKEWORD(2, 0)        <span class="hljs-comment">// 指明版本2.0 </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib,<span class="hljs-meta-string">"ws2_32.lib"</span>)         <span class="hljs-comment">// 使用winsock 2.0 Llibrary</span></span><span class="hljs-comment">/*------------------------------------------------------------------------</span><span class="hljs-comment"> * main - TCP client for TIME service</span><span class="hljs-comment"> *------------------------------------------------------------------------</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">char</span>* host = (<span class="hljs-keyword">char</span>*)<span class="hljs-string">"127.0.0.1"</span>;    <span class="hljs-comment">/* server IP to connect         */</span>    <span class="hljs-keyword">char</span>* service = (<span class="hljs-keyword">char</span>*)<span class="hljs-string">"50500"</span>;      <span class="hljs-comment">/* server port to connect       */</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">sin</span>;</span>            <span class="hljs-comment">/* an Internet endpoint address*/</span>    <span class="hljs-keyword">char</span>buf[BUFLEN + <span class="hljs-number">1</span>];       <span class="hljs-comment">/* buffer for one line of text*/</span>    SOCKETsock;              <span class="hljs-comment">/* socket descriptor    */</span>    <span class="hljs-keyword">int</span>cc;                    <span class="hljs-comment">/* recv character count    */</span>    WSADATA wsadata;    WSAStartup(WSVERS, &amp;wsadata);  <span class="hljs-comment">//加载winsock library。WSVERS为请求的版本，wsadata返回系统实际支持的最高版本</span>    sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);  <span class="hljs-comment">//创建套接字，参数：因特网协议簇(family)，流套接字，TCP协议</span>                                                          <span class="hljs-comment">//返回：要监听套接字的描述符或INVALID_SOCKET</span>    <span class="hljs-built_in">memset</span>(&amp;<span class="hljs-built_in">sin</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">sin</span>));  <span class="hljs-comment">// 从&amp;sin开始的长度为sizeof(sin)的内存清0</span>    <span class="hljs-built_in">sin</span>.sin_family = AF_INET;  <span class="hljs-comment">// 因特网地址簇</span>    <span class="hljs-built_in">sin</span>.sin_addr.s_addr = inet_addr(host);                <span class="hljs-comment">// 设置服务器IP地址(32位)</span>    <span class="hljs-built_in">sin</span>.sin_port = htons((u_short)atoi(service));         <span class="hljs-comment">// 设置服务器端口号  </span>    <span class="hljs-keyword">int</span> ret = connect(sock, (struct sockaddr*)&amp;<span class="hljs-built_in">sin</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">sin</span>));  <span class="hljs-comment">// 连接到服务器，第二个参数指向存放服务器地址的结构，第三个参数为该结构的大小，返回值为0时表示无错误发生，返回SOCKET_ERROR表示出错，应用程序可通过WSAGetLastError()获取相应错误代码。</span>    <span class="hljs-comment">/*如果没有成功连接到服务器,则ret == -1*/</span>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>){        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"没有成功连接到服务器.\n"</span>);        closesocket(sock);        WSACleanup();        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    }    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入你要发送的信息："</span>);    fgets(buf, BUFLEN, <span class="hljs-built_in">stdin</span>);    buf[<span class="hljs-built_in">strlen</span>(buf) - <span class="hljs-number">1</span>] = <span class="hljs-string">'\0'</span>; <span class="hljs-comment">// 把换行符替换为空字符</span>    send(sock, buf, <span class="hljs-built_in">strlen</span>(buf) + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);      <span class="hljs-comment">// 发送信息，信息末尾不带换行符</span>    <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">4</span>] == <span class="hljs-string">'\0'</span> &amp;&amp; !<span class="hljs-built_in">strcmp</span>(buf,<span class="hljs-string">"exit"</span>))    {        closesocket(sock);        WSACleanup();        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    } <span class="hljs-comment">// 用户退出</span>        cc = recv(sock, buf, BUFLEN, <span class="hljs-number">0</span>);                <span class="hljs-comment">// 第二个参数指向缓冲区，第三个参数为缓冲区大小(字节数)，第四个参数一般设置为0，返回值:(&gt;0)接收到的字节数,(=0)对方已关闭,(&lt;0)连接出错</span>    <span class="hljs-keyword">if</span> (cc == SOCKET_ERROR)                          <span class="hljs-comment">// 出错。其后必须关闭套接字sock</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error: %d.\n"</span>, GetLastError());    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cc == <span class="hljs-number">0</span>) {                             <span class="hljs-comment">// 对方正常关闭</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Server closed!"</span>, buf);    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cc &gt; <span class="hljs-number">0</span>) {        buf[cc] = <span class="hljs-string">'\0'</span>;                       <span class="hljs-comment">// ensure null-termination</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n服务器的echo：\n%s"</span>, buf);                         <span class="hljs-comment">// 显示所接收的字符串</span>    }    closesocket(sock);                             <span class="hljs-comment">// 关闭监听套接字</span>    WSACleanup();                                  <span class="hljs-comment">// 卸载winsock library</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"按回车键继续..."</span>);    getchar();<span class="hljs-comment">// 等待任意按键</span>    getchar();}</code></pre><h3 id="编写TCP-server-Echo程序">编写TCP_server_Echo程序</h3><pre><code class="hljs c"><span class="hljs-comment">/* TCPServer.cpp - main */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;winsock2.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"conio.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>WSVERSMAKEWORD(2, 0)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>BUFLEN2000                  <span class="hljs-comment">// 缓冲区大小</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib,<span class="hljs-meta-string">"ws2_32.lib"</span>)  <span class="hljs-comment">//使用winsock 2.2 library</span></span><span class="hljs-comment">/*------------------------------------------------------------------------</span><span class="hljs-comment"> * main - Iterative TCP server for TIME service</span><span class="hljs-comment"> *------------------------------------------------------------------------</span><span class="hljs-comment"> */</span><span class="hljs-keyword">void</span>main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])<span class="hljs-comment">/* argc: 命令行参数个数， 例如：C:\&gt; TCPServer 8080</span><span class="hljs-comment"> argc=2 argv[0]="TCPServer",argv[1]="8080" */</span>{    <span class="hljs-class"><span class="hljs-keyword">struct</span><span class="hljs-title">sockaddr_in</span> <span class="hljs-title">fsin</span>;</span>    <span class="hljs-comment">/* the from address of a client  */</span>    SOCKETmsock, ssock;    <span class="hljs-comment">/* master &amp; slave sockets      */</span>    WSADATA wsadata;    <span class="hljs-keyword">char</span>* service = (<span class="hljs-keyword">char</span>*)<span class="hljs-string">"50500"</span>;<span class="hljs-comment">/*要绑定的本地端口*/</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">sin</span>;</span>    <span class="hljs-comment">/* an Internet endpoint address*/</span>    <span class="hljs-keyword">int</span>    alen;        <span class="hljs-comment">/* from-address length来源的地址长度        */</span>    <span class="hljs-keyword">char</span>* pts;        <span class="hljs-comment">/* pointer to time string 时间字符串指针       */</span>    <span class="hljs-keyword">time_t</span>now;        <span class="hljs-comment">/* current time 时间变量           */</span>    <span class="hljs-keyword">char</span>buf[BUFLEN + <span class="hljs-number">1</span>];       <span class="hljs-comment">/* buffer for one line of text*/</span>    WSAStartup(WSVERS, &amp;wsadata);<span class="hljs-comment">// 加载winsock library。WSVERS指明请求使用的版本。wsadata返回系统实际支持的最高版本</span>    msock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);<span class="hljs-comment">// 创建套接字，参数：因特网协议簇(family)，流套接字，TCP协议</span>                                                        <span class="hljs-comment">// 返回：要监听套接字的描述符或INVALID_SOCKET</span>    <span class="hljs-built_in">memset</span>(&amp;<span class="hljs-built_in">sin</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">sin</span>));<span class="hljs-comment">// 从&amp;sin开始的长度为sizeof(sin)的内存清0</span>    <span class="hljs-built_in">sin</span>.sin_family = AF_INET;<span class="hljs-comment">// 因特网地址簇(INET-Internet)</span>    <span class="hljs-built_in">sin</span>.sin_addr.s_addr = INADDR_ANY;<span class="hljs-comment">// 监听所有(接口的)IP地址。事实上就是0.0.0.0，表示的就是任意IP地址</span>    <span class="hljs-built_in">sin</span>.sin_port = htons((u_short)atoi(service));<span class="hljs-comment">// 监听的端口号。atoi--把ascii转化为int，htons--主机序到网络序(host to network，s-short 16位)</span>    bind(msock, (struct sockaddr*)&amp;<span class="hljs-built_in">sin</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">sin</span>));  <span class="hljs-comment">// 绑定监听的IP地址和端口号</span>    listen(msock, <span class="hljs-number">5</span>);                                   <span class="hljs-comment">// 建立长度为5的连接请求队列，并把到来的连接请求加入队列等待处理。</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"服务器启动成功！！！！\n\n"</span>);    <span class="hljs-keyword">while</span> (!_kbhit()) {                                    <span class="hljs-comment">// 检测是否有按键,如果没有则进入循环体执行</span>        alen = <span class="hljs-keyword">sizeof</span>(struct sockaddr);                         <span class="hljs-comment">// 取到地址结构的长度</span>        ssock = accept(msock, (struct sockaddr*)&amp;fsin, &amp;alen); <span class="hljs-comment">// 如果在连接请求队列中有连接请求，则接受连接请求并建立连接，返回该连接的套接字，否则，本语句被阻塞直到队列非空。fsin包含客户端IP地址和端口号</span>        <span class="hljs-keyword">int</span> recvlen = recv(ssock, buf, BUFLEN, <span class="hljs-number">0</span>); <span class="hljs-comment">// 接收信息</span>        buf[recvlen] = <span class="hljs-string">'\0'</span>;                               <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">"exit"</span>)) {            (<span class="hljs-keyword">void</span>)closesocket(ssock);                              <span class="hljs-comment">// 关闭连接套接字</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"服务器已关闭！！！\n"</span>);            <span class="hljs-keyword">break</span>;        }        (<span class="hljs-keyword">void</span>)time(&amp;now);                                      <span class="hljs-comment">// 取得系统时间</span>        pts = ctime(&amp;now);                                      <span class="hljs-comment">// 把时间转换为字符串</span>        <span class="hljs-keyword">char</span>temp_buf[BUFLEN + <span class="hljs-number">1</span>];       <span class="hljs-comment">/* buffer for one line of text*/</span>        <span class="hljs-built_in">sprintf</span>(temp_buf, <span class="hljs-string">"接收到的信息：%s\n收到的时间：%s\n"</span>, buf, pts);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, temp_buf);<span class="hljs-comment">// </span>        <span class="hljs-keyword">int</span> cc = send(ssock, temp_buf, <span class="hljs-built_in">strlen</span>(temp_buf), <span class="hljs-number">0</span>);              <span class="hljs-comment">// 第二个参数指向发送缓冲区，第三个参数为要发送的字节数，第四个参数一般置0，返回值：&gt;=0 实际发送的字节数，0 对方正常关闭，SOCKET_ERROR 出错。</span>                (<span class="hljs-keyword">void</span>)closesocket(ssock);                              <span class="hljs-comment">// 关闭连接套接字</span>    }    (<span class="hljs-keyword">void</span>)closesocket(msock);                                 <span class="hljs-comment">// 关闭监听套接字</span>    WSACleanup();                                             <span class="hljs-comment">// 卸载winsock library</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"按回车键继续..."</span>);    getchar();<span class="hljs-comment">// 等待任意按键</span>    getchar();}</code></pre><h3 id="编写TCP-Echo增强程序">编写TCP Echo增强程序</h3><p>只需在原程序的基础上进行稍微的修改：</p><p>要求对<code>sockaddr_in</code>有所理解，且掌握<code>%u</code>、<code>%hu</code>的输出方法</p><pre><code class="hljs c"><span class="hljs-built_in">sprintf</span>(temp_buf, <span class="hljs-string">"接收到的信息：%s\n收到的时间：%s客户端的IP地址:%u.%u.%u.%u\n客户端的端口号:%hu\n"</span>            , buf            , pts            , fsin.sin_addr.S_un.S_un_b.s_b1            , fsin.sin_addr.S_un.S_un_b.s_b2            , fsin.sin_addr.S_un.S_un_b.s_b3            , fsin.sin_addr.S_un.S_un_b.s_b4            , fsin.sin_port        );<span class="hljs-comment">//输出所有信息</span></code></pre><h2 id="UDP程序设计">UDP程序设计</h2><h4 id="编写UDP-client程序">编写UDP_client程序</h4><pre><code class="hljs c"><span class="hljs-comment">/* UDPClient.cpp */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;winsock2.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>BUFLEN2000                  <span class="hljs-comment">// 缓冲区大小</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WSVERSMAKEWORD(2, 2)        <span class="hljs-comment">// 指明版本2.2 </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib,<span class="hljs-meta-string">"ws2_32.lib"</span>)         <span class="hljs-comment">// 加载winsock 2.2 Llibrary</span></span><span class="hljs-keyword">int</span>main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[]){    <span class="hljs-keyword">char</span>* host = (<span class="hljs-keyword">char</span>*)<span class="hljs-string">"127.0.0.1"</span>;    <span class="hljs-comment">/* server IP to connect         */</span>    u_short service = <span class="hljs-number">50500</span>;      <span class="hljs-comment">/* server port to connect       */</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">toAddr</span>;</span>        <span class="hljs-comment">/* an Internet endpoint address*/</span>    <span class="hljs-keyword">int</span> toAddrsize = <span class="hljs-keyword">sizeof</span>(toAddr);    <span class="hljs-keyword">char</span>buf[BUFLEN + <span class="hljs-number">1</span>];       <span class="hljs-comment">/* buffer for one line of text*/</span>    SOCKETsock;              <span class="hljs-comment">/* socket descriptor    */</span>    <span class="hljs-keyword">int</span>cc;                    <span class="hljs-comment">/* recv character count    */</span>    <span class="hljs-keyword">char</span>* pts;            <span class="hljs-comment">/* pointer to time string    */</span>    <span class="hljs-keyword">time_t</span>now;            <span class="hljs-comment">/* current time        */</span>    WSADATA wsadata;    WSAStartup(WSVERS, &amp;wsadata);       <span class="hljs-comment">/* 启动某版本Socket的DLL        */</span>    sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);    <span class="hljs-built_in">memset</span>(&amp;toAddr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(toAddr));    toAddr.sin_family = AF_INET;    toAddr.sin_port = htons(service);    <span class="hljs-comment">//atoi：把ascii转化为int. htons：主机序(host)转化为网络序(network), s--short</span>    toAddr.sin_addr.s_addr = inet_addr(host);           <span class="hljs-comment">//如果host为域名，需要先用函数gethostbyname把域名转化为IP地址</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"输入你要发送的信息："</span>);    fgets(buf, BUFLEN, <span class="hljs-built_in">stdin</span>);    buf[<span class="hljs-built_in">strlen</span>(buf) - <span class="hljs-number">1</span>] = <span class="hljs-string">'\0'</span>;    cc = sendto(sock, buf, BUFLEN, <span class="hljs-number">0</span>, (SOCKADDR*)&amp;toAddr, <span class="hljs-keyword">sizeof</span>(toAddr));    <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">4</span>] == <span class="hljs-string">'\0'</span> &amp;&amp; !<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">"exit"</span>))    {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"服务器关闭！！！"</span>);        closesocket(sock);        WSACleanup();        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    } <span class="hljs-comment">// 用户退出</span>    <span class="hljs-keyword">if</span> (cc == SOCKET_ERROR) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"发送失败，错误号：%d\n"</span>, WSAGetLastError());    }    <span class="hljs-keyword">else</span> {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"发送成功!\r\n"</span>);    }    cc = recvfrom(sock, buf, BUFLEN, <span class="hljs-number">0</span>, (SOCKADDR*)&amp;toAddr, &amp;toAddrsize);    buf[cc] = <span class="hljs-string">'\0'</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, buf);    closesocket(sock);    WSACleanup();                 <span class="hljs-comment">/* 卸载某版本的DLL */</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"按任意键退出..."</span>);    getchar();}</code></pre><h3 id="编写UDP-server程序">编写UDP_server程序</h3><pre><code class="hljs c"><span class="hljs-comment">/* UDPServer.cpp */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;winsock2.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"conio.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>BUFLEN2000                   </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WSVERSMAKEWORD(2, 2)        </span><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib,<span class="hljs-meta-string">"ws2_32.lib"</span>)          </span><span class="hljs-comment">/*------------------------------------------------------------------------</span><span class="hljs-comment"> * main - TCP client for DAYTIME service</span><span class="hljs-comment"> *------------------------------------------------------------------------</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">char</span>* host = (<span class="hljs-keyword">char</span>*)<span class="hljs-string">"127.0.0.1"</span>;    <span class="hljs-comment">/* server IP Address to connect */</span>    <span class="hljs-keyword">char</span>* service = (<span class="hljs-keyword">char</span>*)<span class="hljs-string">"50500"</span>;      <span class="hljs-comment">/* server port to connect       */</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">sin</span>;</span>        <span class="hljs-comment">/* an Internet endpoint address*/</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">from</span>;</span>        <span class="hljs-comment">/* sender address               */</span>    <span class="hljs-keyword">int</span>    fromsize = <span class="hljs-keyword">sizeof</span>(from);    <span class="hljs-keyword">char</span>   buf[BUFLEN + <span class="hljs-number">1</span>];       <span class="hljs-comment">/* buffer for one line of text*/</span>    SOCKETsock;          <span class="hljs-comment">/* socket descriptor    */</span>    <span class="hljs-keyword">int</span>cc;                <span class="hljs-comment">/* recv character count    */</span>    <span class="hljs-keyword">char</span> temp_buf[BUFLEN+<span class="hljs-number">1</span>];    WSADATA wsadata;    WSAStartup(WSVERS, &amp;wsadata);       sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);     <span class="hljs-built_in">memset</span>(&amp;<span class="hljs-built_in">sin</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">sin</span>));    <span class="hljs-built_in">sin</span>.sin_family = AF_INET;    <span class="hljs-built_in">sin</span>.sin_addr.s_addr = INADDR_ANY;                         <span class="hljs-built_in">sin</span>.sin_port = htons((u_short)atoi(service));             bind(sock, (struct sockaddr*)&amp;<span class="hljs-built_in">sin</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">sin</span>));            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"服务器已开启！！！\n\n"</span>);    <span class="hljs-keyword">while</span> (!_kbhit()) {                                            cc = recvfrom(sock, buf, BUFLEN, <span class="hljs-number">0</span>, (SOCKADDR*)&amp;from, &amp;fromsize);          buf[cc] = <span class="hljs-string">'\0'</span>;        <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">4</span>] == <span class="hljs-string">'\0'</span> &amp;&amp; !<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">"exit"</span>)) {            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"服务器关闭！！！"</span>);            closesocket(sock);            WSACleanup();            getchar();            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        }        <span class="hljs-keyword">if</span> (cc == SOCKET_ERROR) {            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"recvfrom() failed; %d\n"</span>, WSAGetLastError());            <span class="hljs-keyword">break</span>;        }        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cc == <span class="hljs-number">0</span>)            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">else</span> {            <span class="hljs-keyword">char</span>* pts;        <span class="hljs-comment">/* pointer to time string 时间字符串指针       */</span>            <span class="hljs-keyword">time_t</span>now;        <span class="hljs-comment">/* current time 时间变量           */</span>            (<span class="hljs-keyword">void</span>)time(&amp;now);                                      <span class="hljs-comment">// 取得系统时间</span>            pts = ctime(&amp;now);                                      <span class="hljs-comment">// 把时间转换为字符串</span>            <span class="hljs-built_in">sprintf</span>(temp_buf, <span class="hljs-string">"接收到的信息：%s\n收到的时间：%s客户端的IP地址:%u.%u.%u.%u\n客户端的端口号:%hu\n"</span>                , buf                , pts                , from.sin_addr.S_un.S_un_b.s_b1                , from.sin_addr.S_un.S_un_b.s_b2                , from.sin_addr.S_un.S_un_b.s_b3                , from.sin_addr.S_un.S_un_b.s_b4                , from.sin_port            );<span class="hljs-comment">//输出所有信息</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, temp_buf);            cc = sendto(sock, temp_buf, BUFLEN, <span class="hljs-number">0</span>, (SOCKADDR*)&amp;from, <span class="hljs-keyword">sizeof</span>(from));        }    }    closesocket(sock);    WSACleanup();                    getchar();}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《局外人》读笔</title>
    <link href="/Wuhlan3/2021/03/06/%E3%80%8A%E5%B1%80%E5%A4%96%E4%BA%BA%E3%80%8B%E8%AF%BB%E7%AC%94/"/>
    <url>/Wuhlan3/2021/03/06/%E3%80%8A%E5%B1%80%E5%A4%96%E4%BA%BA%E3%80%8B%E8%AF%BB%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<p>这本书描写了一个人——默尔索，一个三十来岁的职员，一个对周遭的一切漠不关心、将自己置身事外的人。</p><p>对于母亲的死，他说出了这样的话：“今天，妈妈死了。也可能是昨天，我不知道。”奔丧过程中，他没有哭，拒绝了看妈妈最后一眼的建议，甚至有着“想到就要上床睡上十二个钟头时心头的喜悦”。在葬礼的第二天，他就开始与新结识的女友游泳、看电影、做爱。面对女友关于爱不爱她的提问，他也认为“这种话毫无意义，但是我还像并不爱她”。</p><p>他应邀和新结识的邻居朋友雷蒙去海边度假，与雷蒙情妇的兄弟结派的几个阿拉伯人相遇，并打了一架。在那之后，默尔索再次一个人去了海滩，结果却在阿拉伯人袭击自己之前，开枪射杀对方。他入狱之后，调查人员得知他在母亲葬礼那天“表现得麻木不仁”，这很可能成为他被判刑的证据——一个没有在妈妈葬礼上哭泣的人，毫无疑问是个冷血动物，残忍的杀人犯。尽管如此，默尔索还是拒绝了说谎话来减刑，因为他确实觉得无所谓，他不想做令他讨厌的事情，哪怕是在生死面前。最终他被斩首示众，面对死亡他发出了生命中最后的呐喊：</p><blockquote><p>我也一样，我也感到准备好，把一切从头来过。好像这场勃然的怒火净除了我精神上的痛苦，也清空了我的希望，面对这样一个充满启示与星斗的夜，我第一次向这个世界温柔的冷漠敞开了胸怀。我体验到这个世界和我如此相像，终究是如此友爱，我觉得我曾是幸福的，现在依然是幸福的。为了让一切有个了结，为了使我不感到那么孤独，我还是希望我被处决的那天有很多人来观看，我希望他们用仇恨的喊声来欢迎我。</p></blockquote><p>能够与此书产生共鸣，或许是我们心中都存在着一个默尔索吧。有的时候，我们厌恶了社会中的规则，厌恶舆论裹挟司法的判决，厌恶多数人的声音淹没了少数人的呐喊。</p><p>某种角度上来说，我对默尔索是羡慕的，虽然他在社会规则这台巨大的粉碎机面前没有任何还手之力，但他的人生过着他想过的样子。加缪也认为他笔下的默尔索是赤子，是一个无比真诚的人。引用某个书评的话，<strong>“所有的规则皆是跳房子的格子线，我只需蹦着跳着越过去，有什么不可以。“</strong></p><p>他高高兴兴提着酱油瓶来了这世界，打满了酱油就走了。</p><p><img src="微信图片_20200928081908.jpg" alt=""></p><h3 id="关于葬礼与死亡"><a href="#关于葬礼与死亡" class="headerlink" title="关于葬礼与死亡"></a>关于葬礼与死亡</h3><p>或许该小说与葬礼、死亡的话题不是紧密联系的，但它确实使我想起参加过的葬礼。曾祖父、曾祖母、外公已经相继离世了，每当我得知消息的时候我的心里往往不会产生太多波动。因为我是亲眼看见他们老人家因病痛折磨得长期卧床不起，弥留之际往往已经说不出话来、无法移动身体。我真切的认为死亡，某种意义上讲，也是一种解脱。尽管如此，我还是会因为自己没有流露出悲伤而憎恨自己：“<strong>是不是太过冷漠了呀</strong>”。</p><p>外公很瘦很瘦，尤其是在得了癌症之后，好似找不到一两肉了，只剩下皮包骨。印象中的他是最典型的老人形象，由于牙齿掉光了， 嘴巴就像用针线缝过的那样，干瘪瘪的。在脑袋上有一个很大的肉瘤，记得十年前他曾经因此入过院，所幸出院之后对生活都没有什么影响。肉瘤初看着吓人，但是可以说已经与他的身体融为一体，也没有进一步恶化，倒是成为一个标志性的东西。</p><p>在外公离世的当晚，我被告知要去守夜。说来惭愧，我第一时间内心所产生出的想法是“麻烦、浪费时间、这种传统习俗大可不必”。<strong>那个时候的我就像一个局外人一样。所幸，这种想法很快就改变了</strong>。当我坐在水晶棺旁边时，水晶棺里躺着的就是永远闭上双眼的外公。我意识到这种场合下，玩手机是对逝者的不敬。便看着水晶棺、看着人来人往、看着香一点一点地烧尽。村里很多人都来了。有以往和外公天天打牌的牌友，他进门叹了几口气，站在水晶棺旁边，像老友打招呼一样说到：“军师，一路走好！”；有常常来外公开的小卖部里搭两句话的街坊，一言不发，离水晶棺非常近，看了许久才不舍地离去；也有邻居带着小孩，他们不许小孩进来看，仅仅是在门外拜了三拜，上香离去……原来外公在那么多人心中活过。</p><blockquote><p>人的一生，要死去三次。</p><p> 第一次，当你的心跳停止，呼吸消逝，你在生物学上被宣告了死亡。</p><p> 第二次，当你下葬，人们穿着黑衣出席你的葬礼。他们宣告，你在这个社会上不复存在，你悄然离去。</p><p>第三次死亡，是这个世界上最后一个记得你的人，把你忘记。于是，你就真正地死去，整个宇宙都将不再和你有关。</p><p align="right">——大卫·伊格曼《生命的清单》</p></blockquote><p>一个个片段在我的脑海里，像幻灯片一样闪过。外公是一个胆小的人，记得老一辈曾经提起过：外公在田里种地，突然轰隆隆一声雷响，他便吓得把锄头扔在地上，头也不回地奔回家里；还记得外公身体出了些毛病，无论家人怎么劝说，他就是不肯去医院看一下。尽管如此，<strong>他的一生过得也不窝囊</strong>。我自打有记忆起似乎就没见过外公生气过，虽然没怎么读过书，但是<strong>遇到一个陌生人他也能大谈特谈天下局势，因此被朋友们赠以“军师”之名</strong>。更有趣的是，在我很小很小的时候，外公的牙齿就已经掉光了，也没有装上假牙。但是一次吃饭过程中发现，外公竟然还能吃排骨、番石榴，全凭牙床嚼碎。想到这里，湿润着眼眶的我还是笑了起来。</p><p>所谓的守夜好像也没那么糟糕。<strong>这是一个好好回顾他们出现在我们生命中一点一滴的机会</strong>。当我们仔细地回想逝者的一生，真真切切地感受到他们的一生过得那么精彩，似乎也没什么遗憾的了。安息吧，进入那无尽的长眠。</p>]]></content>
    
    
    
    <tags>
      
      <tag>不务正业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《一个人的村庄》读笔</title>
    <link href="/Wuhlan3/2021/03/03/%E3%80%8A%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9D%91%E5%BA%84%E3%80%8B%E8%AF%BB%E7%AC%94/"/>
    <url>/Wuhlan3/2021/03/03/%E3%80%8A%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9D%91%E5%BA%84%E3%80%8B%E8%AF%BB%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<p>刘亮程被誉为“中国二十世纪的最后一位散文家”。他的文字都在描写他生活了多年的新疆的一个村子。可以说，这本书是乡土哲学，或者“土味”哲学。当然“土味”二字不应该带有贬义。在费孝通的《乡土中国》中对“土气”有过这样的说法：</p><blockquote><p>因为只有直接有赖于泥土的生活才会像植物一般的在一个地方生下根，这些生了根在一个小地方的人，才能在悠长的时间中，从容地去摸熟每个人的生活，像母亲对于她的儿女一样。</p></blockquote><p>也许正是如此，这本书并不适合一口气读完。因为读着读着，便怀疑作者“到底是深情还是矫情”。他对村庄中的一切都毫不吝啬地给予赞美，完全享受于村庄中的孤独与不变。带有这种强烈的主观色彩，观点自然容易变得偏激和偏颇。但是这并不影响作者通过独特的视角，给我们带来对人与村庄、人与人、人与动物植物等关系的思考。</p><h3 id="人与动物"><a href="#人与动物" class="headerlink" title="人与动物"></a>人与动物</h3><p>对不同的动物，作者有着不同的感情与态度。</p><p>对于狗，作者认为它是人的一部分、村庄的一部分，但是却是到老了才能挣脱身上的锁链。同时又暗示着人的一辈子又何尝不如此呢。在年轻气盛的时候，为了生存左右逢源、出不得一点差错；到耄耋之年，垂垂老矣，只能看着那荒宅旧院回想陈事旧影。</p><blockquote><ul><li><p>一条狗能活到老，真是件不容易的事。太厉害不行，太懦弱不行，不解人意、善解人意了均不行。总之，稍一马虎便会被人剥了皮炖了肉。狗本是看家护院的，更多时候却连自己都看守不住。</p></li><li><p>人一睡着，村庄便成了狗的世界，喧嚣一天的人再无话可说。土地和人都乏了。此时狗语大作，狗的声音在夜空飘来荡去，将远远近近的村庄连在一起。那是人之外的另一种声音，飘远、神秘。莽原之上，明月之下，人们熟睡的躯体是听者，土墙和土墙的影子是听者，路是听者。年代久远的狗吠融入空气中，已经成寂静的一部分。</p></li><li><p>在这众狗狺狺(yín)的夜晚，肯定有一条老狗，默不作声。它是黑夜的一部分。它在一个村庄转悠到老，是村庄的一部分。它再无人可咬，因而也是人的一部分。这是条终于可以冥然入睡的狗，在人们久不再去的僻远路途，废弃多年的荒宅旧院，这条狗来回地走动，眼中满是人们多年前的陈事旧影。</p></li></ul><p align="right">——《狗这一辈子》</p></blockquote><p>对于驴，作者认为自己是一个通驴性的人，他与驴相互观察、相互介入对方的生活。有时候，他甚至更加羡慕驴的生活，因为现实生活的处境常常把人畜搅得难分彼此。</p><blockquote><ul><li><p>我们是一根缰绳两头的动物，说不上谁牵着谁。</p></li><li><p>驴长了膘我比驴还高兴。我种地赔了本驴比我更垂头丧气。驴上陡坡陷泥潭时我会毫不犹豫地将绳搭在肩上四蹄爬地做一回驴。</p></li><li><p>我一生都在做一件无声的事，无声地写作，无声地发表。我从不读出我的语言，读者也不会，那是一种更加无声的哑语。我的写作生涯因此变得异常寂静和不真实，仿佛一段黑白梦境。我渴望我的声音中有朝一日爆炸出驴鸣，哪怕以沉默十年为代价换得一两句高亢鸣叫我也乐意。</p></li><li><p>所以卑微的人总要养些牲畜在身边方能安心活下去。所以高贵的人从不养牲畜而饲一群卑微的人在脚下。</p></li></ul><p align="right">——《通驴性的人》</p></blockquote><p>对于马，作者是不喜欢的。如果马象征那群忙于奔波、忙于摆脱人命中的厄运的人；那么恰恰相反，作者更乐意慢悠悠地扎根于自己的小村庄里。</p><blockquote><ul><li><p>许多年之后你再看，骑快马飞奔的人和坐在牛背上慢悠悠赶路的人，一样老态龙钟回到村庄里，他们衰老的速度是一样的。时间才不管谁跑得多快多慢呢。</p></li><li><p>一些年人们一窝蜂朝某个地方飞奔，我远远地落在后面，像是被遗弃。另一些年月人们回过头，朝相反的方向奔跑，我仍旧慢悠悠，远远地走在他们前头。我就是这样一个人。我不骑马。</p></li></ul><p align="right">——《逃跑的马》</p></blockquote><p>对于虫，作者在羡慕的同时，也在反思自己。虫子朝生暮死无忧无虑，还来不及忧愁便离去了；而人这漫长的一生中，却有无数烦恼接踵而至。也许烦人的琐事本就是生活的重要的一部分，更是漫长岁月带来的独特体验。</p><blockquote><ul><li><p>有些虫朝生暮死，有些仅有几个月或几天的短暂生命，几乎来不及干什么便匆匆离去。没时间盖房子，创造文化和艺术。没时间为自己和别人去着想。生命简洁到只剩下快乐。我们这些聪明的大生命却在漫长岁月中寻找痛苦和烦恼。一个听烦市嚣的人，躺在田野上听听虫鸣该是多么幸福。大地的音乐会永无休止。而有谁知道这些永恒之音中的每个音符是多么仓促和短暂。</p></li><li><p>当千万只小虫呼拥而至时，我已回到人世间的某个角落，默默无闻做着一件事。没几个人知道我的名字，我也不认识几个人，不知道谁死了谁还活着。一年一年地听着虫鸣，使我感到了小虫子的永恒。而我，正在世上苦度最后的几十个春秋。面朝黄土，没有叫声。</p></li></ul><p align="right">——《与虫共眠》</p></blockquote><h3 id="人与人"><a href="#人与人" class="headerlink" title="人与人"></a>人与人</h3><p>还有一篇讲了作者对于一个人的观察——《冯四》</p><blockquote><ul><li><p>一个人的一辈子完了就完了。作为邻居、亲人和同乡，我们会在心中留下几个难忘的黑白镜头，偶尔放映给自己和别人。一个人一死，他真真实实的一生便成为故事。</p><p>而一村庄人的一生结束后，一个完整的时代便过去了。除了村外新添的那片坟墓，年复一年提示着一段历史。几头老牲口，带着先人使唤时养就的毛病，遭后人鞭骂时依稀浮想昔年盛景。在活着的人眼中，一个村庄的一百年，也就是草木枯荣一百年、地耕翻一百次、庄稼收获一百次这样简单。</p><p>其实人的一生也像一株庄稼，熟透了也就死了。一代又一代人熟透在时间里，浩浩荡荡，无边无际。谁是最后的收获者呢？谁目睹了生命的大荒芜——这个孤独的收获者，在时间深处的无边金黄中，农夫一样，挥舞着镰刀。</p></li><li><p>他的那几亩地总是荒荒地夹在其他人家郁郁葱葱的麦田中间，就像他穷困的一辈子夹在村人们富富裕裕的一辈子中间——长长的一溜儿。</p></li><li><p>与一生这个漫长宏大的工程相比，任何事业都显得渺小而无意义。我们太弱小，所以才想于出些大事业来抵挡岁月，一年年地种庄稼，耕地，难道真因为饥饿吗。饥饿是什么。我们不扛一把锨势必要扛一把刀一杆枪或一支笔，我们手中总要拿一件东西——叫工具也好、武器也好。身体总要摆出一种姿势——叫劳动、体育或打斗。</p></li><li><p>有几个晚上我溜到窗根也没听到什么，屋子里一片死寂，不知冯四正面朝一生中的哪几件事昏昏而睡或黑黑地醒着。</p></li><li><p>我和冯四一样，完成着一辈子。冯四先完工了。我一辈子的一堵墙，还没垒好，透着阳光和风。</p><p align="right">——《冯四》</p></li></ul></blockquote><p>这是作者对于村庄中的一个人的观察。冯四这一生没有做过什么惊天动地的大事，也没有犯下过什么弥天大罪，仅仅是光棍一辈子、家徒四壁、日复一日的无所事事。肯定有人会问，这有什么好观察的？观察人的过程中事实上是读着一本本书，或许只是一面之缘，但是人的一生都早已写在他的脸上、写在他不经意地动作上。</p><p>曾经的我也酷爱观察人。那是高中在地铁上，由于地铁运行的嘈杂的轰鸣声，在地铁上似乎干什么都不尽如人意，我只好选择了看人。那位穿着布满皱纹的衣服的中年男人，是否在为了工作的压力而烦心呢？面对哭闹着要手机的小孩，家长紧皱着眉头，又在想着什么呢？我心中有着各种猜测，而且不需要告诉他人。形形色色的人啊，千人千面，似乎怎么看都不会腻。这是一种难得的上帝视角，似乎很轻松地，我们便能看到每个人的一生。当然，到最后还是要回到自己的一生，也许我们并不能活出另一个样子——比他们更好或更差劲。但是会有一种说不清道不明的感觉，豁然开朗，整个世界都清澈起来。就如刘亮程在《冯四》这篇文章中的一样。他看到冯四的屋内是一片死寂、黑暗的，冯四的辈子结束了，但是他自己的一辈子还透着阳光和风。</p><p>曾经看过<strong>贾平凹</strong>写的一篇小文章<strong>《看人》</strong>写的很好，与我的想法不谋而合：</p><blockquote><p>在地铁入口，在立交桥头，人的脑袋如开水锅冒出的水泡，咕噜咕噜地全涌上来，蹴下来，平视着街面，各式各样的鞋脚在起落。人的脑袋的冒出，你疑惑了他们来自的另一个世界的神秘，鞋脚起落，你恐怖了他们来在这个世界要走出什么的方阵。芸芸众生，众生芸芸，这其中有多少伟人，科学家、哲学家、艺术家、文学家，到底哪一个是，哪一个将来是？你就对所有人敬畏了，于是自然而然想起了佛教上的法门之说，认识到将军也好，小偷也好，哲学家也好，暗娼也好，他们都是以各自的生存方式在体验人生，你就一时消灭了等级差别，丑美界限，而静虚平和地对待一切了。 </p><p>这样，在街头上看一回人的风景，犹如读一本历史，一本哲学，你从此看问题，办事情，心胸就不那么窄了，目光就不那么短了，不会为蝇头小利去勾心斗角，不会因一时荣辱而狂妄和消沉，人既然如蚂蚁一样来到世上，忽生忽死，忽聚忽散，短短数十年里，该自在就自在吧，该潇洒就潇洒吧，各自完满自己的一段生命，这就是生存的全部意义了。 </p></blockquote><h3 id="人与村庄"><a href="#人与村庄" class="headerlink" title="人与村庄"></a>人与村庄</h3><p>…</p>]]></content>
    
    
    
    <tags>
      
      <tag>不务正业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS——五子棋小游戏</title>
    <link href="/Wuhlan3/2021/02/20/JS%E2%80%94%E2%80%94%E4%BA%94%E5%AD%90%E6%A3%8B%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    <url>/Wuhlan3/2021/02/20/JS%E2%80%94%E2%80%94%E4%BA%94%E5%AD%90%E6%A3%8B%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="JS——五子棋小游戏">JS——五子棋小游戏</h2><p>可以在这里玩哦http://wuhlan3.gitee.io/web/</p><ol><li>使用canvas绘制棋盘</li><li>使棋子可以显示</li><li>使棋子可以落在棋盘交点上</li><li>防止棋子落在已有位置</li><li>判断游戏输赢</li><li>重置棋盘</li></ol><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>原生JS 五子棋<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> &gt;</span><span class="javascript"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{</span><span class="javascript">        <span class="hljs-comment">//1.拿到画布</span></span><span class="javascript">        <span class="hljs-keyword">var</span> board = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"board"</span>);</span><span class="javascript">        <span class="hljs-comment">//2.得到画笔</span></span><span class="javascript">        <span class="hljs-keyword">var</span> pen = board.getContext(<span class="hljs-string">"2d"</span>);</span><span class="javascript">        <span class="hljs-comment">//3.绘制棋盘</span></span><span class="javascript">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++){</span><span class="javascript">            pen.beginPath();<span class="hljs-comment">//落笔</span></span><span class="javascript">            pen.moveTo(<span class="hljs-number">15</span>,<span class="hljs-number">15</span> + i*<span class="hljs-number">30</span>); <span class="hljs-comment">// 起始点</span></span><span class="javascript">            pen.lineTo(<span class="hljs-number">435</span>,<span class="hljs-number">15</span> + i*<span class="hljs-number">30</span>); <span class="hljs-comment">// 结束点</span></span><span class="javascript">            pen.closePath(); <span class="hljs-comment">//提笔</span></span><span class="javascript">            pen.stroke(); <span class="hljs-comment">//真正的实现绘制</span></span>        }<span class="javascript">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++){</span><span class="javascript">            pen.beginPath();<span class="hljs-comment">//落笔</span></span><span class="javascript">            pen.moveTo(<span class="hljs-number">15</span>+ i*<span class="hljs-number">30</span>,<span class="hljs-number">15</span> ); <span class="hljs-comment">// 起始点</span></span><span class="javascript">            pen.lineTo(<span class="hljs-number">15</span> + i*<span class="hljs-number">30</span>,<span class="hljs-number">435</span>); <span class="hljs-comment">// 结束点</span></span><span class="javascript">            pen.closePath(); <span class="hljs-comment">//提笔</span></span><span class="javascript">            pen.stroke(); <span class="hljs-comment">//真正的实现绘制</span></span>        }<span class="javascript">        <span class="hljs-comment">//4.准备好棋子</span></span><span class="javascript">        <span class="hljs-keyword">var</span> black_chess = <span class="hljs-keyword">new</span> Image(<span class="hljs-number">15</span>,<span class="hljs-number">15</span>);</span><span class="javascript">        black_chess.src = <span class="hljs-string">"img/黑子.png"</span>;</span><span class="javascript">        black_chess.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{</span>            black_chess.width = 15;                    }<span class="javascript">        <span class="hljs-keyword">var</span> white_chess = <span class="hljs-keyword">new</span> Image(<span class="hljs-number">15</span>,<span class="hljs-number">15</span>);</span><span class="javascript">        white_chess.src = <span class="hljs-string">"img/白子.png"</span>;</span>        <span class="javascript">        board.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>{</span>                if(flag == 1){<span class="javascript">                alert(<span class="hljs-string">"已经结束，棋盘将会重置"</span>);</span><span class="javascript">                <span class="hljs-built_in">window</span>.location.reload();</span>            }<span class="javascript">            <span class="hljs-comment">//获取坐标</span></span><span class="javascript">            <span class="hljs-keyword">var</span> x = event.clientX;</span><span class="javascript">            <span class="hljs-keyword">var</span> y = event.clientY;</span><span class="javascript">            <span class="hljs-comment">//使落在交点上</span></span><span class="javascript">            <span class="hljs-keyword">var</span> xx = <span class="hljs-built_in">parseInt</span>(x / <span class="hljs-number">30</span>);</span><span class="javascript">            <span class="hljs-keyword">var</span> yy = <span class="hljs-built_in">parseInt</span>(y / <span class="hljs-number">30</span>);</span><span class="javascript">            <span class="hljs-comment">//在此位置上显示棋子</span></span>            drawChess(xx,yy);        }<span class="javascript">        <span class="hljs-comment">//5.实现交替下棋</span></span><span class="javascript">        <span class="hljs-keyword">var</span> isBlack = <span class="hljs-literal">true</span>;</span><span class="javascript">        <span class="hljs-keyword">var</span> flag = <span class="hljs-number">0</span>;</span><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawChess</span>(<span class="hljs-params">xx,yy</span>)</span>{</span><span class="javascript">            <span class="hljs-keyword">if</span>(arr[xx][yy])<span class="hljs-keyword">return</span>;</span>            if(isBlack){                pen.drawImage(black_chess,xx*30,yy*30,30,30);<span class="javascript">                isBlack = <span class="hljs-literal">false</span>;</span>                arr[xx][yy] = 1;<span class="javascript">                <span class="hljs-keyword">if</span>(isBlack == <span class="hljs-literal">false</span> &amp;&amp; isWin(xx,yy)){</span><span class="javascript">                    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{alert(<span class="hljs-string">"黑方胜利！"</span>);},<span class="hljs-number">0.1</span>);</span>                    flag = 1;                }<span class="javascript">            }<span class="hljs-keyword">else</span>{</span>                pen.drawImage(white_chess,xx*30,yy*30,30,30);<span class="javascript">                isBlack = <span class="hljs-literal">true</span>;</span>                arr[xx][yy] = 2;                if(isWin(xx,yy)){<span class="javascript">                    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{alert(<span class="hljs-string">"白方胜利！"</span>);},<span class="hljs-number">0.1</span>);</span>                    flag = 1;                }            }        }        <span class="javascript">        <span class="hljs-comment">//6.防止棋子下到同一个地方</span></span><span class="javascript">        <span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();</span><span class="javascript">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i ++){</span><span class="javascript">            arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();</span><span class="javascript">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">15</span>; j ++ ){</span><span class="javascript">                arr[i][j] = <span class="hljs-number">0</span>;<span class="hljs-comment">//黑子为 1， 白子为 2</span></span>            }        }<span class="javascript">        <span class="hljs-comment">//7.判断输赢</span></span><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isWin</span>(<span class="hljs-params">xx,yy</span>)</span>{</span><span class="javascript">            <span class="hljs-keyword">var</span> sum = <span class="hljs-number">1</span>;</span><span class="javascript">            <span class="hljs-comment">//判断左右</span></span><span class="javascript">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span> ; i++){</span><span class="javascript">                <span class="hljs-keyword">if</span>(xx + i == <span class="hljs-number">15</span>)<span class="hljs-keyword">break</span>;</span>                if(arr[xx][yy] == arr[xx+i][yy]){                    sum++;<span class="javascript">                }<span class="hljs-keyword">else</span>{</span><span class="javascript">                    <span class="hljs-keyword">break</span>;</span>                }            }<span class="javascript">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span> ; i++){</span><span class="javascript">                <span class="hljs-keyword">if</span>(xx - i == <span class="hljs-number">-1</span>)<span class="hljs-keyword">break</span>;</span>                if(arr[xx][yy] == arr[xx-i][yy]){                    sum++;<span class="javascript">                }<span class="hljs-keyword">else</span>{</span><span class="javascript">                    <span class="hljs-keyword">break</span>;</span>                }            }<span class="javascript">            <span class="hljs-keyword">if</span>(sum &gt;= <span class="hljs-number">5</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span>            sum = 1;<span class="javascript">            <span class="hljs-comment">//判断上下  </span></span><span class="javascript">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span> ; i++){</span><span class="javascript">                <span class="hljs-keyword">if</span>(yy + i == <span class="hljs-number">15</span>)<span class="hljs-keyword">break</span>;</span>                if(arr[xx][yy] == arr[xx][yy+i]){                    sum++;<span class="javascript">                }<span class="hljs-keyword">else</span>{</span><span class="javascript">                    <span class="hljs-keyword">break</span>;</span>                }            }<span class="javascript">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span> ; i++){</span><span class="javascript">                <span class="hljs-keyword">if</span>(yy - i == <span class="hljs-number">-1</span>)<span class="hljs-keyword">break</span>;</span>                if(arr[xx][yy] == arr[xx][yy-i]){                    sum++;<span class="javascript">                }<span class="hljs-keyword">else</span>{</span><span class="javascript">                    <span class="hljs-keyword">break</span>;</span>                }            }<span class="javascript">            <span class="hljs-keyword">if</span>(sum &gt;= <span class="hljs-number">5</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span>            sum = 1;<span class="javascript">            <span class="hljs-comment">//判断左斜线</span></span><span class="javascript">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span> ; i++){</span><span class="javascript">                <span class="hljs-keyword">if</span>(xx + i == <span class="hljs-number">15</span> || yy + i == <span class="hljs-number">15</span>)<span class="hljs-keyword">break</span>;</span>                if(arr[xx][yy] == arr[xx+i][yy+i]){                    sum++;<span class="javascript">                }<span class="hljs-keyword">else</span>{</span><span class="javascript">                    <span class="hljs-keyword">break</span>;</span>                }            }<span class="javascript">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span> ; i++){</span><span class="javascript">                <span class="hljs-keyword">if</span>(xx - i == <span class="hljs-number">-1</span> || yy - i == <span class="hljs-number">-1</span>)<span class="hljs-keyword">break</span>;</span>                if(arr[xx][yy] == arr[xx-i][yy-i]){                    sum++;<span class="javascript">                }<span class="hljs-keyword">else</span>{</span><span class="javascript">                    <span class="hljs-keyword">break</span>;</span>                }            }<span class="javascript">            <span class="hljs-keyword">if</span>(sum &gt;= <span class="hljs-number">5</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span>            sum = 1;<span class="javascript">            <span class="hljs-comment">//判断右斜线</span></span><span class="javascript">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span> ; i++){</span><span class="javascript">                <span class="hljs-keyword">if</span>(xx - i == <span class="hljs-number">-1</span> || yy + i == <span class="hljs-number">15</span>)<span class="hljs-keyword">break</span>;</span>                if(arr[xx][yy] == arr[xx-i][yy+i]){                    sum++;<span class="javascript">                }<span class="hljs-keyword">else</span>{</span><span class="javascript">                    <span class="hljs-keyword">break</span>;</span>                }            }<span class="javascript">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span> ; i++){</span><span class="javascript">                <span class="hljs-keyword">if</span>(xx + i == <span class="hljs-number">15</span> || yy - i == <span class="hljs-number">-1</span>)<span class="hljs-keyword">break</span>;</span>                if(arr[xx][yy] == arr[xx+i][yy-i]){                    sum++;<span class="javascript">                }<span class="hljs-keyword">else</span>{</span><span class="javascript">                    <span class="hljs-keyword">break</span>;</span>                }            }<span class="javascript">            <span class="hljs-keyword">if</span>(sum &gt;= <span class="hljs-number">5</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><span class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span>        }    }    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span> = <span class="hljs-string">"board"</span> <span class="hljs-attr">width</span> = <span class="hljs-string">"450px"</span> <span class="hljs-attr">height</span> = <span class="hljs-string">"450px"</span> <span class="hljs-attr">style</span> = <span class="hljs-string">"background: url(img/board.jpg) repeat"</span> &gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS学习之路</title>
    <link href="/Wuhlan3/2021/02/07/JS%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    <url>/Wuhlan3/2021/02/07/JS%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h1>JS学习之路</h1><h2 id="目录">目录</h2><h3 id="JS基础语法"><a href="#1">JS基础语法</a></h3><p><a href="#1.1">几个输出语句</a></p><p><a href="#1.2">JS的编写位置</a></p><p><a href="#1.2">标识符</a></p><p><a href="#1.4">字符串</a></p><p><a href="#1.5">强制类型转换</a></p><p><a href="#1.6">运算</a></p><p><a href="#1.7">对象</a></p><p><a href="#1.8">函数</a></p><p><a href="#1.9">this相关</a></p><p><a href="#1.10">构造函数</a></p><p><a href="#1.11">数组</a></p><p><a href="#1.12">Date</a></p><p><a href="#1.13">包装类</a></p><p><a href="#1.14">正则表达式</a></p><h3 id="DOM"><a href="#2">DOM</a></h3><p><a href="#2.1">事件</a></p><p><a href="#2.2">DOM 查询</a></p><p><a href="#2.3">图片切换</a></p><p><a href="#2.4">全选练习</a></p><p><a href="#2.5">DOM增删改</a></p><p><a href="#2.6">DOM与CSS样式</a></p><p><a href="#2.7">事件对象</a></p><h3 id="BOM"><a href="#3">BOM</a></h3><p><a href="#3.1">定时器简介</a></p><h3 id="综合练习"><a href="#4">综合练习</a></h3><p><a href="#4.1">轮播图制作</a></p><p><a href="#4.2">二级菜单制作</a></p><p><a href="#4.3">JSON</a></p><h2 id="1">JS基础语法</h2><ol><li>解释型语言（不需要编译）</li><li>类似于C和JAVA的语法结构</li><li>动态语言</li><li>基于原型的面向对象</li></ol><p><img src="1.png" alt=""></p><h3 id="1.1">几个输出语句</h3><ol><li><code>alert("");</code> 用于控制浏览器弹出一个警告框</li><li><code>document.write("");</code> 用于在页面中写一个内容</li><li><code>console.log("");</code> 用于向控制台输出语句</li></ol><p>输出方式：</p><p>​1. <code>var name = prompt("输入的你的名字");</code>弹出一个输入框</p><h3 id="1.2">JS的编写位置</h3><ol><li><p>可以编写到<code>button</code>中、<code>a</code>中（但是，结构与行为耦合，不方便维护，不推荐使用）</p><pre><code class="hljs js">&lt;button onclick=<span class="hljs-string">"alert('讨厌，你点我干嘛~~')"</span>&gt;点我一下&lt;/button&gt;&lt;a href=<span class="hljs-string">"javascript:alert('让你点你就点啊？？？？')"</span>&gt;也点我一下&lt;/a&gt;</code></pre></li><li><p>可以编写到<code>script</code>中</p></li><li><p>可以编写到外部文件（最佳方式）（一旦用于外部文件，里面就能填写代码，会自动忽略）</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"first.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></li></ol><h3 id="1.3">标识符</h3><p>在JS中所有有我们自主命名的都可以称为标识符：变量名、函数名、属性名</p><p>明明标识符需要遵守如下规则：</p><ol><li>标识符中含有字母、数字、_、$</li><li>标识符不能以数字开头</li><li>标识符不能是ES中的关键字或保留字</li><li>一般采用驼峰命名法</li></ol><p><mark>注意：</mark>与C不同的地方在于可以使用<code>$</code></p><p><mark>注意：</mark>JS底层保存标识符时实际上采用的Unicode编码，所以理论上讲，所有utf-8中含有的内容都可以作为标识符</p><pre><code class="hljs JS"><span class="hljs-keyword">var</span> 锄禾日当午 = <span class="hljs-number">123</span>;<span class="hljs-built_in">console</span>.log(锄禾日当午);</code></pre><h3 id="1.4">字面量</h3><p>JS共有六种数据类型：</p><p><code>String 字符串</code></p><p><code>Number 数值</code></p><p><code>Boolean 布尔值</code></p><p><code>Null 空值</code></p><p><code>Undefined 未定义</code></p><p><code>Object 对象</code></p><p>前五个为基本数据类型，后者为引用数据类型</p><p>可以使用<code>typeof</code>来检查类型</p><p>使用<code>Number.MAX_VALUE</code>表示数字最大值，其中<code>infinity</code>表示正无穷</p><p>使用<code>Number.MIN_VALUE</code>表示数字最小值</p><p>使用<code>NaN</code>表示一个特殊的数字类型</p><p>访问<code>null</code>时，返回<code>null</code>类型</p><p>访问<code>var c;</code>时，返回undefined类型</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;<span class="hljs-keyword">var</span> b = <span class="hljs-string">"123"</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a);<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> b);<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.MAX_VALUE);<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.MAX_VALUE * <span class="hljs-built_in">Number</span>.MAX_VALUE);<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.MIN_VALUE);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"abc"</span> * <span class="hljs-string">"cde"</span>);<span class="hljs-keyword">var</span> d = <span class="hljs-literal">null</span>;<span class="hljs-built_in">console</span>.log(d);<span class="hljs-keyword">var</span> c;<span class="hljs-built_in">console</span>.log(c);</code></pre><p><img src="2.png" alt="2"></p><h3 id="1.5">强制类型转换</h3><p>转换为字符串：</p><ol><li><code>a.toString()</code>方法</li><li><code>a = String(a)</code>函数</li><li><code>a = a + ""</code>利用字符串的加法性质</li></ol><p>转换为数字：</p><ol><li><p><code>a.parseInt()</code>、<code>a.parseFloat</code>方法</p><pre><code class="hljs angelscript">可以将字符串中的有效的整数内容取出来如 <span class="hljs-number">123</span>abc567取出来的是 <span class="hljs-number">123</span></code></pre></li><li><p><code>a = Number(a)</code>函数</p><pre><code class="hljs angelscript"><span class="hljs-comment">//字符串————&gt;数字</span>    <span class="hljs-number">1.</span> 如果是纯数字的字符串，直接转换为数字    <span class="hljs-number">2.</span> 如果字符串中有非数字的内容，则转换为NaN    <span class="hljs-number">3.</span> 如果字符串是一个空串或者是一个全是空格的字符串，则转换为<span class="hljs-number">0</span><span class="hljs-comment">//布尔————&gt;数字</span>    <span class="hljs-number">1.</span> <span class="hljs-literal">true</span>  转换为 <span class="hljs-number">1</span>    <span class="hljs-number">2.</span> <span class="hljs-literal">false</span> 转换为 <span class="hljs-number">0</span><span class="hljs-comment">//null————&gt;数字 0</span><span class="hljs-comment">//undefined ————&gt; 数字NaN</span></code></pre></li><li><p><code>a = a - 0</code>、<code>a = a*1</code>、<code>a = a /1</code>利用运算的性质</p></li><li><p><code>a = + a</code>直接加一个正号</p></li></ol><p>进制的转换</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = oxff;<span class="hljs-comment">//十六进制</span><span class="hljs-keyword">var</span> b = <span class="hljs-number">070</span>;<span class="hljs-comment">//八进制，有些浏览器会把它当作八进制，有些浏览器会把它当作十进制</span><span class="hljs-keyword">var</span> c = <span class="hljs-number">0b10</span>;<span class="hljs-comment">//二进制</span>b = <span class="hljs-built_in">parseInt</span>(b,<span class="hljs-number">10</span>)<span class="hljs-comment">//可通过这种方式来统一规范</span></code></pre><p>转换为布尔值</p><pre><code class="hljs awk"><span class="hljs-regexp">//</span>字符串————&gt;布尔值    除了空串，其余都为true<span class="hljs-regexp">//</span>数字————&gt;布尔值    除了<span class="hljs-number">0</span>和NaN，其余的都是true<span class="hljs-regexp">//</span>null————&gt;false<span class="hljs-regexp">//u</span>ndefined————&gt;false<span class="hljs-regexp">//</span>对象————&gt; true</code></pre><h3 id="1.6">运算</h3><p>做加法运算时，自动转换为字符串</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> result;result = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-string">"3"</span>;<span class="hljs-built_in">console</span>.log(result);<span class="hljs-comment">//输出“33”</span>result = <span class="hljs-string">"1"</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span>;<span class="hljs-built_in">console</span>.log(result);<span class="hljs-comment">//输出“123”</span></code></pre><p>做减法、乘法、除法运算时，自动转换为Number</p><pre><code class="hljs js">result = <span class="hljs-number">100</span> - <span class="hljs-string">"1"</span>;<span class="hljs-comment">// 99</span>result = <span class="hljs-number">2</span> * <span class="hljs-string">"8"</span>;<span class="hljs-comment">// 16</span>result = <span class="hljs-number">2</span> * <span class="hljs-literal">undefined</span>;<span class="hljs-comment">// NaN</span>result = <span class="hljs-number">2</span> * <span class="hljs-literal">null</span>;<span class="hljs-comment">// 0</span></code></pre><p>关系运算符，比较的时候</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"1"</span> &lt; <span class="hljs-number">5</span>);       <span class="hljs-comment">//true 字符串转换为数字</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"11"</span> &lt; <span class="hljs-string">"5"</span>);    <span class="hljs-comment">//true 比较unicode编码</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"abc"</span> &lt; <span class="hljs-string">"cde"</span>); <span class="hljs-comment">//true 比较unicode编码</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"戒"</span> &gt; <span class="hljs-string">"我"</span>);    <span class="hljs-comment">//true 比较unicode编码</span></code></pre><h3 id="1.7">对象</h3><p>生成一个对象：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();person.name = <span class="hljs-string">"王子豪"</span>;person.age = <span class="hljs-number">19</span>;person.gender = <span class="hljs-string">"男"</span>;</code></pre><p>对象属性的删除与修改：</p><pre><code class="hljs awk"><span class="hljs-regexp">//</span>修改person.age = <span class="hljs-number">20</span>;<span class="hljs-regexp">//</span>删除<span class="hljs-keyword">delete</span> person.age;</code></pre><p>特殊属性名</p><pre><code class="hljs js"><span class="hljs-comment">//语法：对象["属性名"] = 属性值</span>person[<span class="hljs-string">"1234"</span>] = <span class="hljs-number">56</span>;</code></pre><p>in 运算符：用于检查一个对象中是否含有指定的属性</p><pre><code class="hljs js"><span class="hljs-built_in">document</span>.write(<span class="hljs-string">"name"</span> <span class="hljs-keyword">in</span> person);<span class="hljs-comment">//注意，就算是.运算符也要用双引号</span><span class="hljs-built_in">document</span>.write(<span class="hljs-string">"1234"</span> <span class="hljs-keyword">in</span> person);</code></pre><p>对象字面量的使用：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> classmate  = {            name:<span class="hljs-string">"王著"</span>,            age:<span class="hljs-number">18</span>,            gender:<span class="hljs-string">"男"</span>    school:{    name:<span class="hljs-string">"中山大学"</span>    dormitory:<span class="hljs-string">"520"</span>            }        }<span class="hljs-built_in">document</span>.write(classmate.name, classmate.age, classmate.gender);</code></pre><p>基本数据类型和引用数据类型之间的区别：</p><p>类似于每一个对象是一个指针</p><p><img src="3.png" alt=""></p><p>枚举对象中的属性</p><pre><code class="hljs js"><span class="hljs-keyword">for</span>( <span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> classmate){    <span class="hljs-built_in">console</span>.log(i);    <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">":"</span> + clssmate[i]);<span class="hljs-comment">//输出如 name：王著</span>}</code></pre><h3 id="1.8">函数</h3><pre><code class="hljs js"><span class="hljs-comment">//创建一个函数对象</span><span class="hljs-keyword">var</span> fun = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>();<span class="hljs-comment">//可以将要封装的代码以字符串的形式传递给构造函数</span><span class="hljs-keyword">var</span> fun1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">"document.write('hellofunction');"</span>);fun1();<span class="hljs-comment">//一般不会用上述方法</span><span class="hljs-comment">//函数声明：</span><span class="hljs-comment">//语法：</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params">[形参<span class="hljs-number">1</span>,形参<span class="hljs-number">2</span>,...形参N]</span>)</span>{        语句...    }<span class="hljs-comment">//函数表达式：</span><span class="hljs-comment">//语法：</span>    <span class="hljs-keyword">var</span> fun3 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{        语句...    }</code></pre><p>函数的实参可以是任意数据类型，同时调用函数时，不会检查实参的数量</p><p>如果实参的数量少于形参的数量，则没有对应实参的形参将是<code>undefined</code></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a,b</span>)</span>{    <span class="hljs-built_in">document</span>.write(a+b);}sum(<span class="hljs-number">123</span>,<span class="hljs-number">456</span>);<span class="hljs-comment">//输出579</span>sum(<span class="hljs-number">123</span>,<span class="hljs-string">"hello"</span>);   <span class="hljs-comment">//输出"123hello"</span>sum(<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>);<span class="hljs-comment">//输出"1"</span>sum(<span class="hljs-number">123</span>,<span class="hljs-number">456</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">false</span>);<span class="hljs-comment">//输出579</span></code></pre><p>立即执行函数(只会执行一次)</p><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{    alert(<span class="hljs-string">"这是一个匿名函数"</span>); })();</code></pre><h3 id="1.9">this相关</h3><p>解析器在调用函数每次都会向函数内部传递进一个隐含的参数——this，this指向的是一个对象。这个对象我们称为函数执行的上下文对象。</p><p>根据函数的调用方法的不同，this会指向不同的对象</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span>{    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);}<span class="hljs-keyword">var</span> obj = {    name:<span class="hljs-string">"孙悟空"</span>,    sayName:fun};<span class="hljs-built_in">console</span>.log(obj.sayName == fun);<span class="hljs-comment">//这里的方法与函数是同一个对象</span>obj.sayName();<span class="hljs-comment">//输出 Object，对象的this</span>fun();<span class="hljs-comment">//输出 Window，全局的this</span></code></pre><p>用法</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span>{    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<span class="hljs-comment">//可以在函数里使用this</span>}<span class="hljs-keyword">var</span> obj1 = {    name:<span class="hljs-string">"孙悟空"</span>,    sayName:fun};<span class="hljs-keyword">var</span> obj2 = {    name:<span class="hljs-string">"猪八戒"</span>,    sayName:fun};<span class="hljs-keyword">var</span> obj3 = {    name:<span class="hljs-string">"沙和尚"</span>,    sayName:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);    }}obj1.sayName();obj2.sayName();obj3.sayName();</code></pre><h3 id="1.10">构造函数</h3><p>工厂中的创建对象方法：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">creatPerson</span>(<span class="hljs-params">name, age, gender</span>)</span>{    <span class="hljs-comment">//创建一个新对象</span>    <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();    <span class="hljs-comment">//向对象添加属性</span>    obj.name = name;    obj.age = age;    obj.gender = gender;    obj.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{        alert(<span class="hljs-built_in">this</span>.name);    }    <span class="hljs-comment">//将新对象返回</span>    <span class="hljs-keyword">return</span> obj;}</code></pre><p>构造函数：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age, gender</span>)</span>{    <span class="hljs-built_in">this</span>.name = name;    <span class="hljs-built_in">this</span>.age = age;    <span class="hljs-built_in">this</span>.gender = gender;    <span class="hljs-built_in">this</span>.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{        alert(<span class="hljs-built_in">this</span>.name);    };        <span class="hljs-keyword">var</span> per = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"孙悟空"</span>, <span class="hljs-number">18</span>, <span class="hljs-string">"男"</span>);}</code></pre><p>使用<code>instanceof</code>可以检查一个对象是否是一个类的实例</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(per <span class="hljs-keyword">instanceof</span> Person);<span class="hljs-comment">//返回true</span><span class="hljs-built_in">console</span>.log(per <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>);<span class="hljs-comment">//返回true，所有对象都是Object的子类（祖宗）</span></code></pre><p>原型对象：</p><p><img src="4.png" alt="4"></p><pre><code class="hljs js"><span class="hljs-comment">//使所有的对象共享同一个方法，避免同一个方法创建很多次</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age, gender</span>)</span>{    <span class="hljs-built_in">this</span>.name = name;    <span class="hljs-built_in">this</span>.age = age;    <span class="hljs-built_in">this</span>.gender = gender;    <span class="hljs-built_in">this</span>.sayName = fun;}<span class="hljs-comment">//假如采用下列方式：</span><span class="hljs-comment">//在全局作用域中定义</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span>{    alert(<span class="hljs-built_in">this</span>.name);}<span class="hljs-comment">//***********污染全局作用域的命名空间，同时很不安全************//</span><span class="hljs-comment">//向原型对象中添加sayName方法</span>Person.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{    alert(<span class="hljs-built_in">this</span>.name);};</code></pre><p><img src="5.png" alt="5"></p><p>但是，使用<code>in</code>检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true。可以使用对象的<code>hasOwnPropery</code></p><p><img src="6.png" alt="image-20210209204919405"></p><h3 id="1.11">数组</h3><pre><code class="hljs js"><span class="hljs-comment">//创建数组对象</span><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();arr[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;arr[<span class="hljs-number">1</span>] = <span class="hljs-number">31</span>;arr[<span class="hljs-number">2</span>] = <span class="hljs-number">33</span>;<span class="hljs-built_in">console</span>.log(arr);<span class="hljs-comment">//输出 10,31，33</span><span class="hljs-built_in">console</span>.log(arr[<span class="hljs-number">3</span>]); <span class="hljs-comment">//输出 undefined</span><span class="hljs-built_in">console</span>.log(arr.length); <span class="hljs-comment">//输出3，！！！！！！！注意length是属性</span><span class="hljs-comment">//length可被直接修改</span><span class="hljs-comment">//使用字面量创建数组</span><span class="hljs-keyword">var</span> arr1 = [];<span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<span class="hljs-comment">//使用构造函数创建数组</span><span class="hljs-keyword">var</span> arr3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>);<span class="hljs-comment">//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!注意！！！！！！！！！！！！</span><span class="hljs-keyword">var</span> arr4[<span class="hljs-number">10</span>];<span class="hljs-comment">//表示大小为1，元素为10的数组</span><span class="hljs-keyword">var</span> arr5 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//表示创建大小为10的数组</span></code></pre><p>可查看JS参考手册https://www.w3school.com.cn/jsref/jsref_obj_array.asp</p><p>数组中可以存放任何数据类型</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = {<span class="hljs-attr">name</span>:<span class="hljs-string">"孙悟空"</span>};arr = [<span class="hljs-string">"hello"</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">undefined</span>,obj];<span class="hljs-comment">//都可以存放，甚至包括 函数和数组</span></code></pre><p>数组的方法</p><p>继续学习参考手册https://www.w3school.com.cn/jsref/jsref_obj_array.asp</p><p>常用的有如下：<code>join()</code>、<code>pop()</code>、<code>shift()</code>、<code>unshift()</code>、<code>push()</code>、<code>splice()</code>、<code>slice()</code></p><br><p>遍历数组</p><p><code>foreach()</code>方法，只支持IE8以上的浏览器</p><pre><code class="hljs js"><span class="hljs-comment">//forEach()方法需要一个函数作为参数</span>arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello"</span>);});</code></pre><p>数组排序</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>];arr.sort();<span class="hljs-comment">//排序</span>arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>{    <span class="hljs-built_in">console</span>.log(item);});<span class="hljs-comment">//forEach中添加的函数，可以含有三个参数currentValue, index, arr</span>arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>{    <span class="hljs-keyword">return</span> b - a;});<span class="hljs-comment">//添加一个比较函数，进行逆序排序</span>arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>{    <span class="hljs-built_in">console</span>.log(item);});</code></pre><h3 id="1.12">Date</h3><pre><code class="hljs js"><span class="hljs-comment">//创建一个Date对象</span><span class="hljs-comment">//封装为当前代码的执行时间</span><span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<span class="hljs-comment">//创建一个指定的时间对象</span><span class="hljs-keyword">var</span> date2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">"2/10/2021 20:52:30"</span>);<span class="hljs-comment">//</span><span class="hljs-keyword">var</span> date = date2.getDate();<span class="hljs-keyword">var</span> day = date2.getDay();<span class="hljs-keyword">var</span> month = date2.getMonth();<span class="hljs-keyword">var</span> year = date2.getYear();<span class="hljs-keyword">var</span> hour = date2.getHours();<span class="hljs-keyword">var</span> minute = date2.getMinutes();<span class="hljs-keyword">var</span> second = date2.getSeconds();<span class="hljs-comment">//时间戳，从格林威治标准时间的1970年1月1日，0时0分0秒，到当前时间的毫秒数</span><span class="hljs-comment">//计算机底层保存时间时，使用的都是时间戳</span><span class="hljs-keyword">var</span> time = date2.getTime();<span class="hljs-comment">//输出格林威治时间的时间戳的得到的是负值？？？？</span><span class="hljs-keyword">var</span> date2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">"1/1/1970 0:0:0"</span>);      <span class="hljs-built_in">console</span>.log(date2.getTime());<span class="hljs-comment">//这是因为显示的是东八区时间</span></code></pre><p>使用时间戳检测代码性能</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> start = <span class="hljs-built_in">Date</span>.now();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> ; i&lt; <span class="hljs-number">100</span> ; i++){    <span class="hljs-built_in">console</span>.log(i);}<span class="hljs-keyword">var</span> end = <span class="hljs-built_in">Date</span>.now();<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"执行了"</span> + (end - start) + <span class="hljs-string">"毫秒"</span>);</code></pre><h3 id="1.13">包装类</h3><p>JS提供了三个包装类，通过这三个包装类可以将基本数据类型的数据转换为对象。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> num = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">3</span>);<span class="hljs-keyword">var</span> str = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">"hello"</span>);<span class="hljs-keyword">var</span> bool = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>);num.name = <span class="hljs-string">"sansan"</span>;<span class="hljs-comment">//方法和属性只能添加给对象，不能添加给基本数据类型</span><span class="hljs-keyword">var</span> s = <span class="hljs-number">123</span>;s.hello = <span class="hljs-string">"hello"</span>;<span class="hljs-comment">//先将s变为一个对象，再将对象销毁</span></code></pre><h3 id="1.14">正则表达式</h3><pre><code class="hljs stylus"><span class="hljs-number">350396117</span>@qq.com邮件的规则：    前边XXXXX + @ + XXXXX + .com    正则表达式用于定义一些字符串的规则：    计算机可以根据正则表达式，来检查一个字符串是否符合规则    获取将字符串中符合规则的内容提取出来</code></pre><pre><code class="hljs js"><span class="hljs-comment">//创建一个正则表达式的对象(Regular Expression)</span><span class="hljs-comment">/*</span><span class="hljs-comment">语法：</span><span class="hljs-comment">var 变量 = new RegExp("正则表达式","匹配模式");</span><span class="hljs-comment">*/</span><span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"a"</span>);<span class="hljs-comment">//这个正则表达式用于检查字符串中是否含有a</span><span class="hljs-keyword">var</span> str = <span class="hljs-string">"a"</span>;<span class="hljs-comment">/*正则表达式的方法</span><span class="hljs-comment">test()</span><span class="hljs-comment"> - 使用这个方法可以检查一个字符串是否符合正则表达式的规则，</span><span class="hljs-comment"> 如果符合返回true，否则返回false</span><span class="hljs-comment">*/</span><span class="hljs-built_in">console</span>.log(reg.test(str));<span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">"sdjkasdk"</span>));<span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">"sdd"</span>));<span class="hljs-comment">//false</span><span class="hljs-comment">/*使用字面量来创建正则表达式</span><span class="hljs-comment">- 语法：var 变量 = /正则表达式/匹配模式</span><span class="hljs-comment">*/</span><span class="hljs-keyword">var</span> reg2 = <span class="hljs-regexp">/a/i</span>;<span class="hljs-comment">//字面量的形式定死了，不能传变量</span></code></pre><p>匹配模式：</p><pre><code class="hljs gcode"><span class="hljs-comment">//传递一个匹配模式作为第二个参数：</span>    i 忽略大小写<span class="hljs-comment">(ignored)</span>    g 全局匹配模式<span class="hljs-comment">(global)</span>    m 执行多行匹配</code></pre><p>练习：</p><pre><code class="hljs js"><span class="hljs-comment">//创建一个正则表达式，检查一个字符串是否含有a或b</span><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/a|b/</span>;</code></pre><pre><code class="hljs js"><span class="hljs-comment">//创建一个正则表达式，检查一个字符串中是否有字母</span><span class="hljs-comment">/*</span><span class="hljs-comment">"[]"里也是或的关系</span><span class="hljs-comment">[ab] == a|b</span><span class="hljs-comment">[a-z] == 任意小写字母</span><span class="hljs-comment">[A-Z] == 任意大写字母</span><span class="hljs-comment">[A-z] == 任意字母</span><span class="hljs-comment">[0-9] == 任意数字</span><span class="hljs-comment">*/</span><span class="hljs-keyword">var</span> reg =  <span class="hljs-regexp">/[A-z]/</span>;<span class="hljs-comment">//任意字母</span><span class="hljs-comment">//检查一个字符串中是否含有abc或adc或aec</span>reg = <span class="hljs-regexp">/a[bde]c/</span>;<span class="hljs-comment">/*</span><span class="hljs-comment">[^ ] 除了里面的东西，都行</span><span class="hljs-comment">*/</span><span class="hljs-comment">//除了a、b、ab,任意字符串都行</span>reg = <span class="hljs-regexp">/[^ab]/</span>;</code></pre><p>字符串与正则表达式：</p><pre><code class="hljs js"><span class="hljs-comment">/*</span><span class="hljs-comment">split()方法</span><span class="hljs-comment"> - 可以将一个字符串拆分为一个数组</span><span class="hljs-comment"> - 方法中可以传递一个正则表达式作为参数，这样方法将会根据正则表达式拆分字符串</span><span class="hljs-comment"> </span><span class="hljs-comment">*/</span><span class="hljs-keyword">var</span> str = <span class="hljs-string">"1a2b3d4h56j7"</span>;<span class="hljs-comment">//根据任意字母拆分字符串</span><span class="hljs-keyword">var</span> result = str.split(<span class="hljs-regexp">/[A-z]/</span>);<span class="hljs-built_in">document</span>.write(result);<span class="hljs-comment">//输出 1,2,3,4,56,7</span><span class="hljs-comment">/*</span><span class="hljs-comment">search()方法</span><span class="hljs-comment"> - 可以搜索字符串中是否含有指定内容</span><span class="hljs-comment"> - 如果搜索到指定内容，则会返回第一次出现的索引，否则返回-1</span><span class="hljs-comment"> - 它可以接受一个正则表达式作为参数，根据正则表达式去检索字符串</span><span class="hljs-comment">*/</span>str  = <span class="hljs-string">"hello abc hello aec afc"</span>;result = str.search(<span class="hljs-regexp">/a[bef]c/</span>);<span class="hljs-comment">//搜索abc或aec或afc</span><span class="hljs-comment">/*</span><span class="hljs-comment">match()</span><span class="hljs-comment"> - 可以根据正则表达式，从一个字符串中将符合条件的内容提取出来</span><span class="hljs-comment"> - 默认情况下，match只会找到第一个符合要求的内容</span><span class="hljs-comment"> 我们可以设置正则表达式为全局匹配模式</span><span class="hljs-comment">*/</span>str = <span class="hljs-string">"1a2b3d4h56j7"</span>;result = str.match(<span class="hljs-regexp">/[A-z]/</span>);<span class="hljs-built_in">console</span>.log(result);<span class="hljs-comment">//输出 a  // 即使只有一个元素，也返回到数组中</span>result = str.match(<span class="hljs-regexp">/[A-z]/g</span>);<span class="hljs-built_in">console</span>.log(result);<span class="hljs-comment">//输出 a,b,d,h,j</span><span class="hljs-comment">/*</span><span class="hljs-comment">replace()方法</span><span class="hljs-comment"> - 可以将字符串中指定内容替换为新的内容</span><span class="hljs-comment"> - 参数</span><span class="hljs-comment"> 1. 被替换的内容,可以接受一个正则表达式作为参数</span><span class="hljs-comment"> 2. 新的内容，</span><span class="hljs-comment"> - 默认只会替换第一个，可以使用全局匹配模式</span><span class="hljs-comment"> </span><span class="hljs-comment">*/</span>result = str.replace(<span class="hljs-regexp">/a-z/gi</span>, <span class="hljs-string">"@_@"</span>);<span class="hljs-built_in">console</span>.log(result);</code></pre><p>量词：</p><pre><code class="hljs js"><span class="hljs-comment">/*</span><span class="hljs-comment">- 通过量词可以设置一个内容的出现次数</span><span class="hljs-comment">- {X} 出现X次</span><span class="hljs-comment">*/</span><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/a{3}/</span>;  <span class="hljs-comment">// aaa</span>reg = <span class="hljs-regexp">/(ab){3}/</span>;  <span class="hljs-comment">//ababab</span></code></pre><p><img src="7.png" alt="image-20210211132940291"></p><p>去除前后的空格：</p><pre><code class="hljs js">str1 = str.replace(<span class="hljs-regexp">/^\s*/</span>,<span class="hljs-string">""</span>);<span class="hljs-comment">//去除前面的空格</span>str2 = str.replace(<span class="hljs-regexp">/^\s*|\s*$/g</span>,<span class="hljs-string">""</span>);<span class="hljs-comment">//去除前后的空格</span><span class="hljs-built_in">console</span>.log(str);</code></pre><p>手机号：</p><pre><code class="hljs js"><span class="hljs-comment">/*手机号规则：</span><span class="hljs-comment">13767890123</span><span class="hljs-comment">1. 以1开头</span><span class="hljs-comment">2. 第二位3-9任意数字</span><span class="hljs-comment">3. 三位以后任意数字9个</span><span class="hljs-comment"></span><span class="hljs-comment">/^1[3-9][0-9]{9}$/</span><span class="hljs-comment">*/</span><span class="hljs-keyword">var</span> phoneStr = <span class="hljs-string">"13767890123"</span>;<span class="hljs-keyword">var</span> phoneReg = <span class="hljs-regexp">/^1[3-9][0-9]{9}$/</span>;<span class="hljs-built_in">console</span>.log(phoneReg.test(phoneStr));</code></pre><p>电子邮件：</p><pre><code class="hljs js"><span class="hljs-comment">/*任意字母数字下划线.任意字母数字下划线@任意字母数字.任意字母(2-5位)任意字母(2-5位)</span><span class="hljs-comment">\w{3,}  (\.\w+)* @ [A-z0-9]+ (\.[A-z]{2,5}){1,2}</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span><span class="hljs-keyword">var</span> emailReg = <span class="hljs-regexp">/^\w{3,}(\.\w+)*@[A-z0-9]+(\.[A-z]{2,5}){1,2}$/</span>;<span class="hljs-keyword">var</span> email = <span class="hljs-string">"abc@abc.com"</span>;<span class="hljs-built_in">console</span>.log(emailReg.test(email));</code></pre><h2 id="2">DOM</h2><p>DOM(Document Object Model) 文档对象模型</p><ul><li>文档：就是整个HTML网页文档</li><li>对象：将网页的每一个部分都转换为了一个对象(万物皆是对象，包括文档本身)</li><li>模型：使用模型来表示对象之间的关系，这样方便我们获取对象</li></ul><p><img src="8.png" alt="image-20210211163807649"></p><p><img src="9.png" alt="image-20210211164137276"></p><p><img src="10.png" alt="image-20210211164314588"></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span> = <span class="hljs-string">"btn"</span>&gt;</span>        我是一个按钮    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>    /*浏览器已经为我们提供了 文档节点 对象，这个对象是window属性    可以在页面中直接使用，文档节点代表的是整个网页*/<span class="javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>); <span class="hljs-comment">//输出HTMLDocument</span></span>      <span class="javascript">    <span class="hljs-comment">//获取button对象</span></span><span class="javascript">    <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"btn"</span>);</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(btn);  <span class="hljs-comment">//输出button对象</span></span>        <span class="javascript">    <span class="hljs-comment">//修改按钮文字</span></span><span class="javascript">    btn.innerHTML = <span class="hljs-string">"I'm a button"</span>;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><h3 id="2.1">事件</h3><p>事件，就是文档或浏览器窗口中发生的一些特定的交换瞬间。JavaScript和HTML之间的交互是通过事件实现的。（点击某个元素，将鼠标移动至某个元素上方，按下键盘上的某个键，等等）</p><p>可以在事件对应的属性中设置一些js代码，当事件被触发时，这些代码将会执行。</p><p><code>&lt;button id = "btn" onclick = "alert('讨厌，你点我干什么');"&gt;我是一个按钮&lt;/button&gt;</code></p><p>但是，结构与行为耦合，不方便维护，不推荐使用</p><p>可采取下列的方式：</p><pre><code class="hljs js">&lt;body&gt;    &lt;button id = <span class="hljs-string">"btn"</span>&gt;        我是一个按钮    &lt;/button&gt;    &lt;script&gt;    <span class="hljs-comment">//获取button对象</span>    <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"btn"</span>);    <span class="hljs-built_in">console</span>.log(btn);  <span class="hljs-comment">//输出button对象</span>            <span class="hljs-comment">//绑定一个双击事件</span>    btn.ondblclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{    alert(<span class="hljs-string">"你还点~~~"</span>);    };    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="2.2">DOM 查询</h3><p>通过document对象调用：</p><ol><li><code>getElementById()</code>: 通过id属性获取一个元素节点对象</li><li><code>getElementsByTagName()</code>: 通过标签名获取<mark>一组</mark>元素节点对象</li><li><code>getElementsByName()</code>: 通过name属性获取<mark>一组</mark>元素节点对象</li></ol><p>通过具体的元素节点调用：</p><ol><li><code>getElementsByTagName()</code>: <mark>方法</mark>，返回当前节点的指定标签名后代节点</li><li><code>childNodes</code>: <mark>属性</mark>，表示当前节点的所有子节点</li><li><code>firstChild</code>: <mark>属性</mark>，表示当前节点的第一个子节点</li><li><code>lastChild</code>: <mark>属性</mark>，表示当前节点的最后一个子节点</li><li><code>parentNode</code>： <mark>属性</mark>，表示当前节点的父节点</li><li><code>previousSibling</code> : <mark>属性</mark>，表示当前节点的前一个兄弟节点</li><li><code>nextSibling</code> : <mark>属性</mark>，表示当前节点的后一个兄弟节点</li></ol><p>制作一个查询的封装函数：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myClick</span>(<span class="hljs-params">idStr, fun</span>)</span>{    <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.getElementById(idStr);    btn.onclick = fun;}</code></pre><h3 id="2.3">图片切换</h3><img src="12.png" style="zoom:30%;"><p>基本步骤思路：</p><ol><li>获取标签变量。较简单的是通过标签获取；也可以通过TagName（不过要注意是否是数组）</li><li>两个按钮都绑定一个单击事件</li></ol><p>耶~~，可以完全靠自己写出来啦</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>        /* *{            padding: 0px;            margin: 0px;        } */<span class="css">        <span class="hljs-selector-id">#outer</span>{</span>            margin : 100px auto;<span class="css">            <span class="hljs-selector-tag">padding</span><span class="hljs-selector-pseudo">:10px</span>;</span>            width: 350px;            background-color: rgb(190, 183, 113);<span class="css">            <span class="hljs-selector-tag">text-align</span><span class="hljs-selector-pseudo">:center</span>;</span>        }    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">        <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{</span><span class="javascript">            <span class="hljs-keyword">var</span> prev = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"prev"</span>);</span><span class="javascript">            <span class="hljs-keyword">var</span> next = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"next"</span>);</span><span class="javascript">            <span class="hljs-keyword">var</span> img = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"diary"</span>);</span><span class="javascript">            <span class="hljs-keyword">var</span> info = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"info"</span>);</span><span class="javascript">            <span class="hljs-comment">//数组</span></span><span class="javascript">            <span class="hljs-keyword">var</span> imgArr = [<span class="hljs-string">"1.jpg"</span>, <span class="hljs-string">"2.jpg"</span>, <span class="hljs-string">"3.jpg"</span>];</span><span class="javascript">            <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;</span><span class="javascript">            <span class="hljs-keyword">var</span> len = imgArr.length;</span><span class="javascript">            info.innerHTML = <span class="hljs-string">"一共有"</span> + len + <span class="hljs-string">"张图片，这是第"</span>+ (index + <span class="hljs-number">1</span>) + <span class="hljs-string">"张"</span>;</span><span class="javascript">            prev.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{</span>                index = (index - 1) &gt;= 0 ? index -1 : index - 1 + len;                img.src = imgArr[index];<span class="javascript">                info.innerHTML = <span class="hljs-string">"一共有"</span> + len + <span class="hljs-string">"张图片，这是第"</span>+ (index + <span class="hljs-number">1</span>) + <span class="hljs-string">"张"</span>;</span>            }<span class="javascript">            next.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{</span>                index = (index + 1)%len;                img.src = imgArr[index];<span class="javascript">                info.innerHTML = <span class="hljs-string">"一共有"</span> + len + <span class="hljs-string">"张图片，这是第"</span>+ (index + <span class="hljs-number">1</span>) + <span class="hljs-string">"张"</span>;</span>            }                    }    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"outer"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"info"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"1.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"大理寺日志"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"diary"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"300"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"prev"</span>&gt;</span>上一张<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"next"</span>&gt;</span>下一张<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="2.4">全选练习</h3><img src="11.png" alt="image-20210213214849373 wi" style="zoom:70%;" align="center"><br><p>基本步骤思路：</p><ol><li>控制选项的属性是<code>checked</code>，<code>true</code>或<code>false</code></li></ol><pre><code class="hljs js">&lt;!DOCTYPE html&gt;&lt;html lang=<span class="hljs-string">"en"</span>&gt;&lt;head&gt;    &lt;meta charset=<span class="hljs-string">"UTF-8"</span>&gt;    &lt;meta http-equiv=<span class="hljs-string">"X-UA-Compatible"</span> content=<span class="hljs-string">"IE=edge"</span>&gt;    &lt;meta name=<span class="hljs-string">"viewport"</span> content=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script&gt;        <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{            <span class="hljs-keyword">var</span> arr = <span class="hljs-built_in">document</span>.getElementsByName(<span class="hljs-string">"items"</span>);            <span class="hljs-comment">//五个按钮</span>            <span class="hljs-comment">//1 全选</span>            <span class="hljs-keyword">var</span> checkedAllBtn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"checkedAllBtn"</span>);            checkedAllBtn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{                                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {                    arr[i].checked = <span class="hljs-literal">true</span>;                }            }            <span class="hljs-comment">//2 全部不选</span>            <span class="hljs-keyword">var</span> checkedNoBtn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"checkedNoBtn"</span>);            checkedNoBtn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{                                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {                    arr[i].checked = <span class="hljs-literal">false</span>;                }            }            <span class="hljs-comment">//3 反转选项</span>            <span class="hljs-keyword">var</span> checkedRevBtn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"checkedRevBtn"</span>);            checkedRevBtn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{                                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {                    arr[i].checked = !(arr[i].checked);                }            }            <span class="hljs-comment">//4 提交后，弹出提示框</span>            <span class="hljs-keyword">var</span> send = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"send"</span>);            send.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{                                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {                    <span class="hljs-keyword">if</span>(arr[i].checked){                        alert(arr[i].value);                    }                }            }            <span class="hljs-comment">//5右上角的框选中时，四个全选</span>            <span class="hljs-keyword">var</span> checkAllBox = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"checkAllBox"</span>);            checkAllBox.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> ; i &lt; arr.length;  i++){                    arr[i].checked = <span class="hljs-built_in">this</span>.checked;<span class="hljs-comment">//妙妙妙啊</span>                }            }            <span class="hljs-comment">//6四个全选时，右上角的框也要被选中</span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> ; i &lt; arr.length; i ++){                                arr[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{                    checkAllBox.checked = <span class="hljs-literal">true</span>;                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; arr.length; j ++){                        <span class="hljs-keyword">if</span>(!arr[j].checked){                            checkAllBox.checked = <span class="hljs-literal">false</span>;                            <span class="hljs-keyword">break</span>;                        }                    }                }            }                    }    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=<span class="hljs-string">""</span> method=<span class="hljs-string">"post"</span>&gt;        你爱好的运动是 &lt;input type=<span class="hljs-string">"checkbox"</span>  id=<span class="hljs-string">"checkAllBox"</span> /&gt; 全选或全不选        &lt;br/&gt;        &lt;input type=<span class="hljs-string">"checkbox"</span> name=<span class="hljs-string">"items"</span> value=<span class="hljs-string">"足球"</span> /&gt;足球        &lt;input type=<span class="hljs-string">"checkbox"</span> name=<span class="hljs-string">"items"</span> value=<span class="hljs-string">"篮球"</span> /&gt;篮球        &lt;input type=<span class="hljs-string">"checkbox"</span> name=<span class="hljs-string">"items"</span> value=<span class="hljs-string">"羽毛球"</span> /&gt;羽毛球        &lt;input type=<span class="hljs-string">"checkbox"</span> name=<span class="hljs-string">"items"</span> value=<span class="hljs-string">"乒乓球"</span> /&gt;乒乓球        &lt;br/&gt;        &lt;input type=<span class="hljs-string">"button"</span> id=<span class="hljs-string">"checkedAllBtn"</span> value=<span class="hljs-string">"全选"</span> /&gt;        &lt;input type=<span class="hljs-string">"button"</span> id=<span class="hljs-string">"checkedNoBtn"</span> value=<span class="hljs-string">"全不选"</span> /&gt;        &lt;input type=<span class="hljs-string">"button"</span> id=<span class="hljs-string">"checkedRevBtn"</span> value=<span class="hljs-string">"反选"</span> /&gt;        &lt;input type=<span class="hljs-string">"button"</span> id=<span class="hljs-string">"send"</span> value=<span class="hljs-string">"提交"</span> /&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="2.5">DOM增删改</h3><p><img src="13.png" alt=""></p><img src="14.png" alt="image-20210214171009270" style="zoom:70%;"><pre><code class="hljs js">&lt;script&gt;    <span class="hljs-comment">//封装一个单击函数</span>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myClick</span>(<span class="hljs-params">idStr,fun</span>)</span>{            <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.getElementById(idStr);            btn.onclick = fun;        }                <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{            <span class="hljs-comment">//一、添加广州——方法1：</span>            myClick(<span class="hljs-string">"btn01"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{                <span class="hljs-comment">//创建元素节点</span>                <span class="hljs-keyword">var</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"li"</span>);                <span class="hljs-comment">//创建文本节点</span>                <span class="hljs-keyword">var</span> text = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">"广州"</span>);                <span class="hljs-comment">//往li中添加text</span>                li.appendChild(text);                <span class="hljs-comment">//往ul中添加li</span>                <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"city"</span>);                ul.appendChild(li);            });            <span class="hljs-comment">//二、添加广州到北京前</span>            myClick(<span class="hljs-string">"btn02"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{                <span class="hljs-keyword">var</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"li"</span>);                <span class="hljs-keyword">var</span> text = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">"广州"</span>)                li.appendChild(text);                <span class="hljs-comment">//获取北京与city</span>                <span class="hljs-keyword">var</span> beijing = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"bj"</span>);                <span class="hljs-keyword">var</span> city = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"city"</span>);                <span class="hljs-comment">//插入到北京前</span>                city.insertBefore(li,bj);   <span class="hljs-comment">//(新节点,旧节点)</span>            });            <span class="hljs-comment">//三、使用广州节点替换北京节点</span>            myClick(<span class="hljs-string">"btn03"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{                <span class="hljs-keyword">var</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"li"</span>);                <span class="hljs-keyword">var</span> text = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">"广州"</span>)                li.appendChild(text);                <span class="hljs-comment">//获取北京与city</span>                <span class="hljs-keyword">var</span> beijing = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"bj"</span>);                <span class="hljs-keyword">var</span> city = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"city"</span>);                <span class="hljs-comment">//替换</span>                city.replaceChild(li,beijing);            });            <span class="hljs-comment">//四、删除北京节点</span>            myClick(<span class="hljs-string">"btn04"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{                <span class="hljs-comment">//获取北京与city</span>                <span class="hljs-comment">// var beijing = document.getElementById("bj");</span>                <span class="hljs-comment">// var city = document.getElementById("city");</span>                <span class="hljs-comment">// //替换</span>                <span class="hljs-comment">// city.removeChild(beijing);</span>                <span class="hljs-comment">//或者！！！！！！！！我找我爸爸删我自己！！！！！！</span>                <span class="hljs-keyword">var</span> beijing = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"bj"</span>);                <span class="hljs-comment">//替换</span>                beijing.parentNode.removeChild(beijing);            });            <span class="hljs-comment">//五、读取</span>            myClick(<span class="hljs-string">"btn05"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{                <span class="hljs-keyword">var</span> city = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"city"</span>);                alert(city.innerHTML);            });            <span class="hljs-comment">//六、设置bj内的HTML代码</span>            <span class="hljs-comment">//这样也可以，一般两种方法结合使用</span>            myClick(<span class="hljs-string">"btn06"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{                <span class="hljs-keyword">var</span> city = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"city"</span>);                city.innerHTML += <span class="hljs-string">"&lt;li&gt;广州&lt;/li&gt;"</span>;            });        }                    &lt;/script&gt;</code></pre><p>a的索引问题：</p><pre><code class="hljs js"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{    <span class="hljs-keyword">var</span> allA = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"a"</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; allA.length; i++){    <span class="hljs-comment">//for 循环在页面加载完成后，立即执行</span>    <span class="hljs-comment">//而响应函数，在超链接被点击时才会执行.此时，i为allA.length</span>        allA[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{            <span class="hljs-keyword">var</span> tr = <span class="hljs-built_in">this</span>.parentNode.parentNode; <span class="hljs-comment">//因此这里不能使用allA[i]</span>            <span class="hljs-keyword">var</span> flag = confirm(<span class="hljs-string">"确认删除"</span>+ name + <span class="hljs-string">"吗？"</span>);            <span class="hljs-keyword">if</span>(flag){                ...;            }            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//取消超链接的默认跳转行为</span>        };    }}</code></pre><h3 id="2.6">DOM与CSS样式</h3><p>给出的材料如下：</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">        <span class="hljs-selector-id">#box1</span>{</span>            width: 200px;            height: 200px;            background-color: red;<span class="css">            <span class="hljs-comment">/* background-color:red !important; 添加！ important后，拥有最高优先级*/</span></span>        }    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"btn01"</span>&gt;</span>改变样式<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"btn02"</span>&gt;</span>读取样式<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"box1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>修改样式方法</p><pre><code class="hljs js"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{    <span class="hljs-keyword">var</span> box1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"box1"</span>);    <span class="hljs-keyword">var</span> btn01 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"btn01"</span>);    btn01.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{        <span class="hljs-comment">/*</span><span class="hljs-comment">            修改样式方法</span><span class="hljs-comment">                语法： 元素.style.样式名 = 样式值(字符串)</span><span class="hljs-comment">        */</span>       box1.style.width = <span class="hljs-string">"300px"</span>;       box1.style.height = <span class="hljs-string">"300px"</span>;       <span class="hljs-comment">//box1.style.background-color = "yellow";错误，因为含有减号</span>       box1.style.backgroundColor = <span class="hljs-string">"yellow"</span>;    };};</code></pre><p>读取样式：</p><pre><code class="hljs js">btn02.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-comment">/*</span><span class="hljs-comment">通过style设置和读取都是内联样式，无法读取样式表中的样式，</span><span class="hljs-comment">简单来说就是只能读取程序里的变量或标签里设置的属性</span><span class="hljs-comment">*/</span> alert(box1.style.width);<span class="hljs-comment">/*</span><span class="hljs-comment">     getComputedStyle()这个方法来获取元素的当前样式</span><span class="hljs-comment">     这个方法是window的方法，可以直接使用</span><span class="hljs-comment">     需要两个参数：</span><span class="hljs-comment">          1. 获取样式的元素</span><span class="hljs-comment">          2. 传递一个伪元素，一般为null</span><span class="hljs-comment">     该方法会返回一个对象，该对象里封装了当前元素的对应样式</span><span class="hljs-comment">     如果获取的样式没有设置，则会获取真实的值，而不是默认值</span><span class="hljs-comment">     如：没有设置width，它不会获取auto，而是一个长度</span><span class="hljs-comment">   */</span>       <span class="hljs-keyword">var</span> obj = getComputedStyle(box1,<span class="hljs-literal">null</span>);    alert(obj.width);};</code></pre><p><code>getStyle()</code>方法</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStyle</span>(<span class="hljs-params">obj,name</span>)</span>{    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.getComputedStyle){<span class="hljs-comment">//根据属性是否存在进行判断</span>        <span class="hljs-keyword">return</span> getComputedStyle(obj,<span class="hljs-literal">null</span>)[name];<span class="hljs-comment">//正常浏览器</span>    }<span class="hljs-keyword">else</span>{        <span class="hljs-keyword">return</span> obj.currentStyle[name];<span class="hljs-comment">//IE8</span>    }}</code></pre><p>制作一个读协议书的小功能：</p><pre><code class="hljs js">&lt;!DOCTYPE html&gt;&lt;html lang=<span class="hljs-string">"en"</span>&gt;&lt;head&gt;    &lt;meta charset=<span class="hljs-string">"UTF-8"</span>&gt;    &lt;meta http-equiv=<span class="hljs-string">"X-UA-Compatible"</span> content=<span class="hljs-string">"IE=edge"</span>&gt;    &lt;meta name=<span class="hljs-string">"viewport"</span> content=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        #info{            width: <span class="hljs-number">200</span>px;            height: <span class="hljs-number">400</span>px;            overflow: auto;        }    &lt;/style&gt;    &lt;script&gt;        <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{            <span class="hljs-comment">//onscroll 该事件会在元素的滚动条滚动时触发</span>            <span class="hljs-keyword">var</span> info = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"info"</span>);            <span class="hljs-keyword">var</span> inputs = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"input"</span>);            info.onscroll = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{                <span class="hljs-comment">//已滚到底;由于谷歌浏览器的一些属性保留了小数位，所以需要使用1来判断，不能用等于0来判断</span>                <span class="hljs-keyword">if</span>(info.scrollHeight - info.scrollTop - info.clientHeight&lt;<span class="hljs-number">1</span>){                    <span class="hljs-comment">//变为可用</span>                    inputs[<span class="hljs-number">0</span>].disabled = <span class="hljs-literal">false</span>;                    inputs[<span class="hljs-number">1</span>].disabled = <span class="hljs-literal">false</span>;                }            };        }    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;h3&gt;欢迎亲爱的用户注册&lt;/h3&gt;    &lt;p  id = <span class="hljs-string">"info"</span>&gt;        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册        亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读就别注册    &lt;/p&gt;    &lt;!-- 如果为表单项添加disabled=<span class="hljs-string">"disabled"</span>,则表单项变成不可用状态 --&gt;    &lt;input type=<span class="hljs-string">"checkbox"</span>  disabled = <span class="hljs-string">"disabled"</span> /&gt;我已仔细阅读协议，一定遵守    &lt;input type=<span class="hljs-string">"submit"</span>  value = <span class="hljs-string">"注册"</span> disabled = <span class="hljs-string">"disabled"</span>/&gt; &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="2.7">事件对象</h3><p><img src="15.png" alt="image-20210215172917998"></p><p>在div里移动鼠标，显示xy坐标</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">        <span class="hljs-selector-id">#areaDiv</span>{</span><span class="css">            <span class="hljs-selector-tag">width</span><span class="hljs-selector-pseudo">:200px</span>;</span><span class="css">            <span class="hljs-selector-tag">height</span><span class="hljs-selector-pseudo">:100px</span>;</span><span class="css">            <span class="hljs-selector-tag">outline</span>:<span class="hljs-selector-id">#000000</span> <span class="hljs-selector-tag">solid</span> 1<span class="hljs-selector-tag">px</span>;</span>        }<span class="css">        <span class="hljs-selector-id">#showMsg</span>{</span><span class="css">            <span class="hljs-selector-tag">width</span><span class="hljs-selector-pseudo">:200px</span>;</span><span class="css">            <span class="hljs-selector-tag">height</span><span class="hljs-selector-pseudo">:30px</span>;</span><span class="css">            <span class="hljs-selector-tag">outline</span>:<span class="hljs-selector-id">#000000</span> <span class="hljs-selector-tag">solid</span> 1<span class="hljs-selector-tag">px</span>;</span>        }    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">        <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{</span><span class="javascript">            <span class="hljs-keyword">var</span> areaDiv = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"areaDiv"</span>);</span><span class="javascript">            <span class="hljs-keyword">var</span> showMsg = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"showMsg"</span>);</span><span class="javascript">            areaDiv.onmousemove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>{</span><span class="javascript">                <span class="hljs-comment">//解决事件对象的兼容性问题</span></span><span class="javascript">                event = event || <span class="hljs-built_in">window</span>.event;</span>                <span class="javascript">                <span class="hljs-keyword">var</span> x = event.clientX;</span><span class="javascript">                <span class="hljs-keyword">var</span> y = event.clientY;</span><span class="javascript">                showMsg.innerHTML = <span class="hljs-string">"x = "</span> + x + <span class="hljs-string">" "</span> + <span class="hljs-string">"y = "</span> + y;</span>            };        }            <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"areaDiv"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"showMsg"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>div跟随鼠标移动</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">        <span class="hljs-selector-id">#box</span> {</span><span class="css">            <span class="hljs-selector-tag">width</span><span class="hljs-selector-pseudo">:100px</span>;</span>            height: 100px;            background-color: red;<span class="css">            <span class="hljs-comment">/* 开启box1的绝对定位 */</span></span>            position: absolute;        }    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">        <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{</span><span class="javascript">            <span class="hljs-keyword">var</span> box = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"box"</span>);</span><span class="javascript">            <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>{</span><span class="javascript">                event = event || <span class="hljs-built_in">window</span>.event;</span><span class="javascript">                <span class="hljs-keyword">var</span> st = <span class="hljs-built_in">document</span>.body.scrollTop || <span class="hljs-built_in">document</span>.documentElement.scrollTop;</span><span class="javascript">                <span class="hljs-keyword">var</span> sl = <span class="hljs-built_in">document</span>.body.scrollLeft || <span class="hljs-built_in">document</span>.documentElement.scrollLeft;</span><span class="javascript">                <span class="hljs-keyword">var</span> left = event.clientX;<span class="hljs-comment">//clientX是相对于窗口的</span></span><span class="javascript">                <span class="hljs-keyword">var</span> top = event.clientY;     </span><span class="javascript">                <span class="hljs-comment">// var left = event.pageX;</span></span><span class="javascript">                <span class="hljs-comment">// var top = event.pageY;   可以直接获取页面坐标，但是这对IE8不兼容</span></span><span class="javascript">                box.style.left = left +sl + <span class="hljs-string">"px"</span>;</span><span class="javascript">                box.style.top = top +st+ <span class="hljs-string">"px"</span>;         </span>            };                    };    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"height:1000px;width:2000px;"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"box"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>事件的冒泡</p><p>所谓的冒泡指的是事件的向上传导，当其后代元素被触发时，其祖先元素也会被触发。</p><pre><code class="hljs js"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{            <span class="hljs-keyword">var</span> s1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"s1"</span>);            s1.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{                alert(<span class="hljs-string">"我是s1"</span>);            }            <span class="hljs-keyword">var</span> box1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"box1"</span>);            box1.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{                alert(<span class="hljs-string">"我是div"</span>);            }            <span class="hljs-built_in">document</span>.body.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{                alert(<span class="hljs-string">"我是body"</span>)            }        }</code></pre><p>如上述代码，点击span时，三个alert会依次触发。</p><p>在开发中，大部分的冒泡都是非常有用的；如果不希望发生事件冒泡，可以通过事件对象<mark>取消冒泡</mark>。如下：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> s1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"s1"</span>);s1.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{    <span class="hljs-comment">//取消span的冒泡</span>    event = event || <span class="hljs-built_in">window</span>.event;    alert(<span class="hljs-string">"我是s1"</span>);    event.cancelBubble = <span class="hljs-literal">true</span>;}</code></pre><p>事件的委派</p><p>——指将事件统一绑定给元素的共同祖先，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件</p><p>——事件委派利用了冒泡，通过委派可以减少事件的绑定次数</p><pre><code class="hljs js"><span class="hljs-comment">//这样可以快速绑定原有的li和新生成的li</span>            u1.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>{                event = event || <span class="hljs-built_in">window</span>.event;                <span class="hljs-comment">//target获取到响应函数触发的元素</span>                <span class="hljs-keyword">if</span>(event.target.className == <span class="hljs-string">"link"</span>){                    alert(<span class="hljs-number">666</span>);                }            }</code></pre><p>事件的绑定</p><pre><code class="hljs js"><span class="hljs-comment">/*通过这个方法也可以为元素绑定响应函数</span><span class="hljs-comment">- 参数：</span><span class="hljs-comment">1. 事件的字符串，不要on</span><span class="hljs-comment">2. 回调函数，事件触发时函数会被调用</span><span class="hljs-comment">3. 是否捕获阶段触发事件，需要一个布尔值，一般传false</span><span class="hljs-comment">*/</span>btn01.addEventListener(<span class="hljs-string">"click"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{    alert(<span class="hljs-number">1</span>);},<span class="hljs-literal">false</span>);</code></pre><p>事件的捕获</p><blockquote><p>关于事件的传播，网景公司和微软公司有不同的理解：</p><p>微软公司认为：事件应该是由内向外传播的，就是先触发当前元素上的事件——即在冒泡阶段执行</p><p>网景公司认为：事件应该是由外向内传播的，就是先触发最外层的祖先元素的事件，然后向内传播给后代元素</p><p>W3C综合了两个公司的方案，将事件传播分成了三个阶段：</p><ol><li>捕获阶段</li><li>目标阶段</li><li>冒泡阶段</li></ol></blockquote><p><img src="E:%5Cblog%5Csource_posts%5CJS%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%5C16.png" alt=""></p><p>拖拽练习</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">      <span class="hljs-selector-id">#box1</span> {</span>        width: 100px;        height: 100px;        background-color: red;        position: absolute;      }<span class="css">      <span class="hljs-selector-id">#box2</span>{</span>          width: 100px;          height: 100px;<span class="css">          <span class="hljs-selector-tag">background-color</span><span class="hljs-selector-pseudo">:yellow</span>;</span>          position: absolute;          left: 300px;<span class="css">          <span class="hljs-selector-tag">top</span> <span class="hljs-selector-pseudo">:300px</span>;</span>      }    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">      <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</span>        /*                拖拽box1元素                -拖拽流程：                    1. 当鼠标在拖拽元素上按下时，开始拖拽 onmousedown                    2. 当鼠标移动时，被拖拽元素跟随鼠标移动 onmousemove                    3. 当鼠标松开时，被拖拽元素固定在当前位置 onmouseup            */<span class="javascript">        <span class="hljs-keyword">var</span> box1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"box1"</span>);</span><span class="javascript">        <span class="hljs-comment">//为box1绑定按下事件</span></span><span class="javascript">        box1.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</span><span class="javascript">            <span class="hljs-comment">//div偏移量 = 鼠标.clientX - 元素.offsetLeft</span></span><span class="javascript">            <span class="hljs-keyword">var</span> ol = event.clientX - box1.offsetLeft;</span><span class="javascript">            <span class="hljs-keyword">var</span> ot = event.clientY - box1.offsetTop;</span><span class="javascript">          <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{</span><span class="javascript">            event = event || <span class="hljs-built_in">window</span>.event;</span><span class="javascript">            <span class="hljs-comment">//鼠标的坐标</span></span><span class="javascript">            <span class="hljs-keyword">var</span> left = event.clientX ;</span><span class="javascript">            <span class="hljs-keyword">var</span> top = event.clientY ;</span><span class="javascript">            <span class="hljs-comment">//box1位置</span></span><span class="javascript">            box1.style.left = left- ol + <span class="hljs-string">"px"</span>;</span><span class="javascript">            box1.style.top = top - ot + <span class="hljs-string">"px"</span>;</span>          };<span class="javascript">          <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{</span><span class="javascript">            <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-literal">null</span>;</span><span class="javascript">            <span class="hljs-built_in">document</span>.onmousedown = <span class="hljs-literal">null</span>;</span>        }<span class="javascript">          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span>        };                /*当我们拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容，<span class="javascript">        此时会导致拖拽功能的异常，这是浏览器提供的默认行为,简单的取消方法就是<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>*/</span>      };    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>666666666<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"box1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"box2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>滚轮练习</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">        <span class="hljs-selector-id">#box1</span>{</span><span class="css">            <span class="hljs-selector-tag">width</span><span class="hljs-selector-pseudo">:100px</span>;</span><span class="css">            <span class="hljs-selector-tag">height</span><span class="hljs-selector-pseudo">:100px</span>;</span><span class="css">            <span class="hljs-selector-tag">background-color</span><span class="hljs-selector-pseudo">:red</span>;</span>        }    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">        <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{</span><span class="javascript">            <span class="hljs-keyword">var</span> box1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"box1"</span>);</span><span class="javascript">            box1.onmousewheel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>{</span><span class="javascript">                event = event || <span class="hljs-built_in">window</span>.event;</span>                if(event.wheelDelta &gt; 0){<span class="javascript">                    box1.style.height = box1.clientHeight - <span class="hljs-number">10</span> + <span class="hljs-string">"px"</span>;</span><span class="javascript">                }<span class="hljs-keyword">else</span>{</span><span class="javascript">                    box1.style.height = box1.clientHeight + <span class="hljs-number">10</span> + <span class="hljs-string">"px"</span>;</span>                }<span class="javascript">                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//取消滚动条默认行为</span></span>            };                    }    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">style</span> = <span class="hljs-string">"height:2000px;"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"box1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h2 id="3">BOM</h2><p>BOM（Browser Object Model）浏览器对象模型</p><p>BOM是我们可以通过JS来操作浏览器。提供了一组对象</p><ol><li>Window：代表的是整个浏览器的窗口，同时Window也是网页中的全局对象</li><li>Navigator：代表了当前浏览器的信息，通过该对象来识别不同的浏览器。由于历史原因，大部分属性都不能帮助识别浏览器了，现在一般使用userAgent，但是IE11也隐藏了起来</li><li>Location：代表了当前浏览器的地址栏信息</li><li>History：代表浏览器的历史记录（由于隐私的原因，不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问有效）</li><li>Screen：代表用户的屏幕信息，显示器的相关信息</li></ol><p>这些BOM对象在浏览器中都是作为window对象的属性使用的。</p><h3 id="3.1">定时器简介</h3><p>涉及方法：</p><ol><li><code>clearInterval()</code>：取消由 setInterval() 设置的 timeout。</li><li><code>clearTimeout()</code>：取消由 setTimeout() 方法设置的 timeout。</li><li><code>setInterval()</code>：按照指定的周期（以毫秒计）来调用函数或计算表达式。</li><li><code>setTimeout()</code>：在指定的毫秒数后调用函数或计算表达式。</li></ol><pre><code class="hljs js"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{            <span class="hljs-keyword">var</span> h2 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"h2"</span>);            <span class="hljs-keyword">var</span> time = <span class="hljs-number">0</span>;            <span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{                h2.innerHTML = time ++;                <span class="hljs-keyword">if</span>(time == <span class="hljs-number">10</span>){                    <span class="hljs-built_in">clearInterval</span>(timer);<span class="hljs-comment">//timer是一个数字，是定时器的唯一标识</span>                }            },<span class="hljs-number">1000</span>);        }</code></pre><h2 id="4">综合练习</h2><h3 id="4.1">轮播图制作</h3><h3 id="4.2">二级菜单制作</h3><h3 id="4.3">JSON</h3><p>JS中的对象只有JS自己认识，其他语言都不认识；</p><p>JSON（JavaScript Object Notation  JS对象表示法）就是一个特殊格式的字符串，这个字符串可以被任意语言所识别，并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互。</p><p>JSON分类：</p><ol><li>对象{}</li><li>数组[]</li></ol><p>JSON中允许的值：</p><ol><li>字符串</li><li>数值</li><li>布尔值</li><li>null</li><li>对象</li><li>数组</li></ol><pre><code class="hljs js"><span class="hljs-comment">//创建一个对象</span><span class="hljs-keyword">var</span> obj = <span class="hljs-string">'{"name":"孙悟空","age":18 ,"gender":"男"}'</span>;<span class="hljs-comment">//创建一个数组</span><span class="hljs-keyword">var</span> arr = <span class="hljs-string">'[1,2,3,"hello",true]'</span>;</code></pre><p>在JS中，提供了一个工具类，就叫JSON</p><p>这个对象可以帮助我们将一个JSON转换为JS对象，也可以将一个JS对象转换为JSON</p><pre><code class="hljs js"><span class="hljs-comment">/*</span><span class="hljs-comment">JSON -&gt; JS对象：</span><span class="hljs-comment">JSON.parse()</span><span class="hljs-comment">*/</span><span class="hljs-keyword">var</span> json = <span class="hljs-built_in">JSON</span>.parse(str1);<span class="hljs-comment">/*</span><span class="hljs-comment">JS对象 -&gt; JSON：</span><span class="hljs-comment">JSON.stringify()</span><span class="hljs-comment">*/</span><span class="hljs-keyword">var</span> str = <span class="hljs-built_in">JSON</span>.stringify(obj);</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寒假力扣日志</title>
    <link href="/Wuhlan3/2021/01/23/%E5%AF%92%E5%81%87%E5%8A%9B%E6%89%A3%E6%97%A5%E5%BF%97/"/>
    <url>/Wuhlan3/2021/01/23/%E5%AF%92%E5%81%87%E5%8A%9B%E6%89%A3%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<p>刷题顺序参考如下：https://leetcode-cn.com/circle/article/48kq9d/</p><h1>目录</h1><p><a href="#1">链表相关</a></p><p><a href="#2">数组相关</a></p><p><a href="#3">动态规划相关</a></p><h2 id="1">链表相关</h2><h3 id="力扣203移除链表元素">力扣203<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">移除链表元素</a></h3><p>难点在于如何处理头节点。解决方法是添加一个哨兵节点(dummy node)。</p><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> val)</span> </span>{       <span class="hljs-keyword">if</span>(!head)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;       ListNode* newhead = <span class="hljs-keyword">new</span> ListNode();       newhead-&gt;next = head;       ListNode* pre, *cur;       pre = newhead;       cur = head;       <span class="hljs-keyword">while</span>(cur){           ListNode* temp = <span class="hljs-literal">nullptr</span>;           <span class="hljs-keyword">if</span>(cur-&gt;val == val){               pre-&gt;next = cur-&gt;next;                temp = cur;               cur = cur-&gt;next;               <span class="hljs-keyword">delete</span> temp;           }           <span class="hljs-keyword">if</span>(temp)<span class="hljs-keyword">continue</span>;           cur = cur-&gt;next;           pre = pre-&gt;next;       }       ListNode* temp = newhead-&gt;next;       <span class="hljs-keyword">delete</span> newhead;           <span class="hljs-keyword">return</span> temp;   }</code></pre><h3 id="力扣237删除链表中的节点">力扣237<a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">删除链表中的节点</a></h3><h4 id="算法思路">算法思路</h4><p>这道题函数中只有一个节点，要求删除该节点。（没有给出头节点）</p><p>一道简单的脑筋急转弯。由于题目强调了绝对不会删除掉尾节点，只需把下一个节点的元素赋给node，删除掉下一个节点即可。</p><h4 id="代码实现">代码实现</h4><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* node)</span> </span>{        node-&gt;val = node-&gt;next-&gt;val;        node-&gt;next = node-&gt;next-&gt;next;        <span class="hljs-comment">// ListNode* temp = node-&gt;next;</span>        <span class="hljs-comment">// delete temp;</span>    }</code></pre><p><strong>注意</strong>：在实现的过程中还是出现了问题，上面注释掉的代码，为什么不正确？</p><p>下面这篇文章讲的很好，c++的指针类型分为静态分配和动态分配。</p><p><code>delete</code>只能用于释放堆指针，也就是<code>new</code>出来的指针，而不能用于栈指针。</p><blockquote><p>如果在<code>deleteNode</code>前在使用<code>c</code>节点本身，那就可能引发不确定行为。</p><p>由于<code>ListNode</code>是个单链表节点，而单链表节点本质上是无法做到在链表里删除自身的，所以这题只能通过这种替换的方式来伪造删除了节点。</p><p>这题会误导很多开发者，这题的设计模式更是不可取！</p><p>个人认为这题应该删除</p><p>而203. 移除链表元素这题才是真正的移除链表元素！</p><p>作者：AmazingPP<br>链接：https://leetcode-cn.com/problems/delete-node-in-a-linked-list/solution/tong-pi-ci-ti-li-ying-shan-chu-yin-chu-c-taij/<br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h3 id="力扣19-删除链表的倒数第-N-个结点">力扣19 <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a></h3><h4 id="算法思路-2">算法思路</h4><p>方法一：暴力法</p><pre><code> 1. 遍历一遍，获取链表的长度 2. 再循环L-n-1次，获取目标结点的前一个结点。</code></pre><p>方法二：快慢指针法（只需遍历一遍）</p><h4 id="代码实现-2">代码实现</h4><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> n)</span> </span>{        ListNode* dummynode = <span class="hljs-keyword">new</span> ListNode();        dummynode-&gt;next = head;        ListNode* fast = dummynode;        ListNode* slow = dummynode;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++){            fast = fast-&gt;next;        }        <span class="hljs-keyword">while</span>(fast-&gt;next){            fast = fast-&gt;next;            slow = slow-&gt;next;        }        ListNode* temp = slow-&gt;next;        slow-&gt;next = slow-&gt;next-&gt;next;        <span class="hljs-keyword">delete</span> temp;        <span class="hljs-keyword">return</span> dummynode-&gt;next;    }</code></pre><h3 id="力扣430-扁平化多级双向链表">力扣430 <a href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/">扁平化多级双向链表</a></h3><h4 id="题目要求">题目要求</h4><p><img src="multilevellinkedlist.png" alt="1"></p><p>变化为</p><p><img src="multilevellinkedlistflattened.png" alt="2"></p><h4 id="算法思路-3">算法思路</h4><ol><li>DFS（事实上，歪着脖子看，就是二叉树的前序遍历）将结点存入数组中</li><li>遍历数组，从新连接结点</li></ol><h4 id="代码实现-3">代码实现</h4><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>    <span class="hljs-built_in">vector</span>&lt;Node*&gt; arr;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node* head)</span></span>{        <span class="hljs-keyword">if</span>(!head)<span class="hljs-keyword">return</span>;        arr.push_back(head);        dfs(head-&gt;child);        dfs(head-&gt;next);    }    <span class="hljs-function">Node* <span class="hljs-title">flatten</span><span class="hljs-params">(Node* head)</span> </span>{        dfs(head);        <span class="hljs-keyword">int</span> size = arr.size();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size;  i++){            <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span> &lt; size) arr[i]-&gt;next = arr[i+<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>) arr[i]-&gt;prev = arr[i<span class="hljs-number">-1</span>];            arr[i]-&gt;child = <span class="hljs-literal">NULL</span>;        }        <span class="hljs-keyword">return</span> head;    }};</code></pre><p>因为前两天学习到很多方法，所以今天的题目都能很快完成</p><h3 id="力扣61-旋转链表">力扣61 <a href="https://leetcode-cn.com/problems/rotate-list/">旋转链表</a></h3><h3 id="力扣24-两两交换链表中的节点">力扣24 <a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">两两交换链表中的节点</a></h3><h3 id="力扣206-反转链表">力扣206 <a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></h3><h4 id="算法思路-4">算法思路</h4><ol><li><p>迭代法（三指针）</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{        ListNode* dummynode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>,head);        <span class="hljs-keyword">if</span>(dummynode-&gt;next == <span class="hljs-literal">NULL</span> || dummynode-&gt;next-&gt;next == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> head;        ListNode* pre = <span class="hljs-literal">NULL</span>;        ListNode* mid = dummynode-&gt;next;        ListNode* tail = dummynode-&gt;next-&gt;next;        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>){            mid-&gt;next =  pre;            <span class="hljs-keyword">if</span>(tail == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">break</span>;            pre = mid;            mid = tail;            tail = tail-&gt;next;        }        <span class="hljs-keyword">return</span> mid;    }};</code></pre></li><li><p>递归法</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) {            <span class="hljs-keyword">return</span> head;        }        ListNode* newHead = reverseList(head-&gt;next);        head-&gt;next-&gt;next = head;     <span class="hljs-comment">//下一个结点指回自己</span>        head-&gt;next = <span class="hljs-literal">NULL</span>;        <span class="hljs-keyword">return</span> newHead;    }};</code></pre></li></ol><h3 id="力扣92-反转链表-II">力扣92 <a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/"> 反转链表 II</a></h3><h4 id="算法思路-5">算法思路</h4><p>该题难点在于要求一次遍历，需要理清变量的位置。</p><p>哨兵节点：<code>dummynode</code></p><p>反转链表需要三个变量：<code>fir</code>、<code>sec</code>、<code>thr</code></p><p>确定反转后的头和尾需要两个变量：<code>pre</code>、<code>tail</code></p><p><img src="1.jpg" alt="3"></p><h4 id="代码实现-4">代码实现</h4><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>{        <span class="hljs-keyword">if</span>(!head)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        <span class="hljs-keyword">if</span>(!head-&gt;next)<span class="hljs-keyword">return</span> head;        <span class="hljs-keyword">if</span>(m == n)<span class="hljs-keyword">return</span> head;        ListNode* dummynode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>,head);        ListNode* fir = dummynode;        ListNode* sec = dummynode-&gt;next;        ListNode* thr = dummynode-&gt;next-&gt;next;        ListNode* pre;<span class="hljs-comment">//连接m点</span>        ListNode* tail;<span class="hljs-comment">//连接n点</span>        <span class="hljs-keyword">while</span>(thr){            <span class="hljs-keyword">if</span>(m == <span class="hljs-number">1</span>)<span class="hljs-keyword">break</span>;            fir = sec;            sec = thr;            thr = thr-&gt;next;            n--;            m--;        }        pre = fir;        tail = sec;        <span class="hljs-keyword">while</span>(thr){            fir= sec;            sec = thr;            thr = thr-&gt;next;            sec-&gt;next = fir;            n--;            <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<span class="hljs-keyword">break</span>;        }        tail-&gt;next = thr;        pre-&gt;next = sec;        <span class="hljs-keyword">return</span> dummynode-&gt;next;    }};</code></pre><h3 id="力扣25-K-个一组翻转链表">力扣25 <a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">K 个一组翻转链表</a></h3><h4 id="算法思路-6">算法思路</h4><ol><li>遍历一遍链表，获得链表长度<code>cnt</code>，根据<code>cnt</code>分割出每段<code>len</code></li><li>用三指针进行反转</li></ol><p>与上题类似。可以继续沿用上题的我画的图</p><p><mark>！！！注意注意！！！</mark>花了半个小时debug，问题在于 <code>fir = tail;</code>反转一段链表后，需要更新<code>fir</code>为<code>tail</code></p><h4 id="代码实现-5">代码实现</h4><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>{        <span class="hljs-keyword">if</span>(!head)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        <span class="hljs-keyword">if</span>(!head-&gt;next)<span class="hljs-keyword">return</span> head;        ListNode* dummynode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>,head);        <span class="hljs-comment">//得到长度</span>        ListNode* cur = dummynode;        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(cur){            cnt++;            cur = cur-&gt;next;        }        cnt--;        <span class="hljs-keyword">int</span> len = cnt/k;        ListNode* fir = dummynode;        ListNode* sec = dummynode-&gt;next;        ListNode* thr = dummynode-&gt;next-&gt;next;        ListNode* pre;        ListNode* tail;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; len; i ++){            pre = fir;            tail = sec;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j ++){                sec-&gt;next = fir;                fir = sec;                sec = thr;                <span class="hljs-keyword">if</span>(thr == <span class="hljs-literal">NULL</span>) thr = <span class="hljs-literal">NULL</span>;                <span class="hljs-keyword">else</span> thr = thr-&gt;next;            }            pre-&gt;next = fir;            tail-&gt;next = sec;            fir = tail;        }        <span class="hljs-keyword">return</span> dummynode-&gt;next;    }};</code></pre><p><mark>思考：</mark>如何只用一次遍历。太累了，以后再解决吧。</p><h3 id="力扣21-合并两个有序链表">力扣21 <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></h3><h3 id="力扣2-两数相加">力扣2 <a href="https://leetcode-cn.com/problems/add-two-numbers/">两数相加</a></h3><h3 id="力扣445-两数相加-II">力扣445 <a href="https://leetcode-cn.com/problems/add-two-numbers-ii/">两数相加 II</a></h3><h4 id="算法思路-7">算法思路</h4><ol><li>由于需要逆序处理链表，从个位开始相加，所以可以考虑使用<mark>栈</mark></li><li>引入一个<code>carry</code>变量作为进位</li></ol><h4 id="代码实现-6">代码实现</h4><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>{        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s1;        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s2;        ListNode* cur;        <span class="hljs-comment">//遍历l1</span>        cur = l1;        <span class="hljs-keyword">while</span>(cur){            s1.push(cur-&gt;val);            cur = cur-&gt;next;        }        <span class="hljs-comment">//遍历l2</span>        cur = l2;        <span class="hljs-keyword">while</span>(cur){            s2.push(cur-&gt;val);            cur = cur-&gt;next;        }        ListNode* ans = <span class="hljs-literal">NULL</span>;        <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;        <span class="hljs-comment">//当l1为空，l2为空，carry为0时结束循环</span>        <span class="hljs-keyword">while</span>(!s1.empty()|| !s2.empty() || carry){            <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span>(!s1.empty()){                left = s1.top();                s1.pop() ;            }            <span class="hljs-keyword">if</span>(!s2.empty()){                right = s2.top();                s2.pop();            }            <span class="hljs-keyword">int</span> newval = left+right+carry;            carry = newval/<span class="hljs-number">10</span>;            newval = newval%<span class="hljs-number">10</span>;            ListNode* node = <span class="hljs-keyword">new</span> ListNode(newval);            node-&gt;next = ans;            ans = node;        }        <span class="hljs-keyword">return</span> ans;    }};</code></pre><h3 id="力扣23-合并K个升序链表">力扣23 <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">合并K个升序链表</a></h3><h4 id="算法思路一、">算法思路一、</h4><p>一种想法是将所有结点打散，存在一个优先队列中。但是耗时较长</p><blockquote><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210126192802293.png" alt="image-20210126192802293"></p></blockquote><p>但是，可以直接的考虑应该是每次取出各个链表的第一个元素，放入优先队列。</p><p>学习优先队列的使用方法，熟悉<code>for(auto node : lists){}</code>这种遍历方式。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Status</span> {</span>        <span class="hljs-keyword">int</span> val;        ListNode *ptr;        <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> Status &amp;rhs) <span class="hljs-keyword">const</span> {            <span class="hljs-keyword">return</span> val &gt; rhs.val;        }    };<span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>{        <span class="hljs-built_in">priority_queue</span>&lt;Status&gt; q;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> node: lists) {            <span class="hljs-keyword">if</span> (node) q.push({node-&gt;val, node});        }        ListNode* dummynode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode* tail = dummynode;        <span class="hljs-keyword">while</span> (!q.empty()) {            <span class="hljs-keyword">auto</span> front = q.top(); q.pop();            tail-&gt;next = front.ptr;             tail = tail-&gt;next;            <span class="hljs-keyword">if</span> (front.ptr-&gt;next) q.push({front.ptr-&gt;next-&gt;val, front.ptr-&gt;next});        }        <span class="hljs-keyword">return</span> dummynode-&gt;next;    }};</code></pre><h4 id="算法思路二、">算法思路二、</h4><p>分治合并。</p><p><img src="https://pic.leetcode-cn.com/6f70a6649d2192cf32af68500915d84b476aa34ec899f98766c038fc9cc54662-image.png" alt="img"></p><p>需要两个函数：1.用于合并两个链表；2.分治递归</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//合并两个链表</span>    <span class="hljs-function">ListNode* <span class="hljs-title">merge2Lists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span></span>{        <span class="hljs-keyword">if</span>(!l1 &amp;&amp; !l2)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        <span class="hljs-keyword">if</span>(!l1 )<span class="hljs-keyword">return</span> l2;        <span class="hljs-keyword">if</span>(!l2) <span class="hljs-keyword">return</span> l1;        ListNode* cur1 = l1;        ListNode* cur2 = l2;        ListNode* dummynode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode* cur = dummynode;        <span class="hljs-keyword">while</span>(cur1 &amp;&amp; cur2){            <span class="hljs-keyword">if</span>(cur1-&gt;val &lt; cur2-&gt;val){                ListNode* temp = <span class="hljs-keyword">new</span> ListNode(cur1-&gt;val);                cur-&gt;next = temp;                cur1 = cur1-&gt;next;                cur = cur-&gt;next;            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur1-&gt;val &gt;= cur2-&gt;val){                ListNode* temp = <span class="hljs-keyword">new</span> ListNode(cur2-&gt;val);                cur-&gt;next = temp;                cur2 = cur2-&gt;next;                cur = cur-&gt;next;            }        }        cur-&gt;next = cur1? cur1 : cur2;        <span class="hljs-keyword">return</span> dummynode-&gt;next;    }    <span class="hljs-comment">//递归</span>    <span class="hljs-function">ListNode* <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;ListNode*&gt;&amp; lists, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>{        <span class="hljs-keyword">int</span> mid = (left + right)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(left == right)<span class="hljs-keyword">return</span> lists[left];        <span class="hljs-keyword">if</span>(left &gt; right)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        ListNode* ans = merge2Lists(fun(lists, left, mid),fun(lists, mid+<span class="hljs-number">1</span>, right));        <span class="hljs-keyword">return</span> ans;    }    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>{        <span class="hljs-keyword">return</span> fun(lists, <span class="hljs-number">0</span>, lists.size()<span class="hljs-number">-1</span>);    }};</code></pre><p>链表暂告一段落…</p><h2 id="2">数组相关</h2><h3 id="力扣485-最大连续1的个数">力扣485 <a href="https://leetcode-cn.com/problems/max-consecutive-ones/">最大连续1的个数</a></h3><h3 id="力扣495-提莫攻击">力扣495 <a href="https://leetcode-cn.com/problems/teemo-attacking/">提莫攻击</a></h3><h3 id="力扣414-第三大的数">力扣414 <a href="https://leetcode-cn.com/problems/third-maximum-number/">第三大的数</a></h3><h3 id="力扣-剑指-Offer-40-最小的k个数">力扣 <a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h3><h3 id="力扣628-三个数的最大乘积">力扣628 <a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/">三个数的最大乘积</a></h3><h3 id="力扣645-错误的集合">力扣645 <a href="https://leetcode-cn.com/problems/set-mismatch/">错误的集合</a></h3><p>https://leetcode-cn.com/problems/set-mismatch/solution/cyi-huo-fa-xiang-jie-by-feng-feng-19/</p><h3 id="力扣697-数组的度">力扣697 <a href="https://leetcode-cn.com/problems/degree-of-an-array/">数组的度</a></h3><h4 id="算法思路-8">算法思路</h4><ol><li>构建一个<code>unordered_map&lt;int,pair&lt;int,int&gt;&gt;</code>，其中pair包含数据出现次数与数据第一次出现的坐标</li></ol><h3 id="力扣448-找到所有数组中消失的数字">力扣448 <a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">找到所有数组中消失的数字</a></h3><h2 id="3">动态规划相关</h2><p><img src="2.png" alt="image-20210203195708610"></p><p>动态规划组成部分：</p><ol><li><p>确定状态：最后一步和子问题</p><p><img src="3.png" alt="image-20210203200248268"></p></li><li><p>转移方程</p><p><img src="4.png" alt="image-20210203200631362"></p></li><li><p>初始条件和边界情况</p><p><img src="5.png" alt="image-20210203201010114"></p></li><li><p>计算顺序（递归：自顶向下，动态规划：自底向上）</p><p><img src="6.png" alt="image-20210203201219009"></p></li></ol><p><img src="7.png" alt="image-20210203203659002"></p><h3 id="力扣338-比特位计数">力扣338 <a href="https://leetcode-cn.com/problems/counting-bits/">比特位计数</a></h3><h4 id="算法思路-9">算法思路</h4><p>要输出二进制数的‘1’的个数，只需要考虑两种情况：</p><ol><li>奇数：$f(i) = f(i-1)+1$</li><li>偶数：$f(i) = f(i/2)$</li></ol><h4 id="代码实现-7">代码实现</h4><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>{        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;        <span class="hljs-keyword">if</span>(num &gt;= <span class="hljs-number">0</span>)ans.push_back(<span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span>(num &gt;= <span class="hljs-number">1</span>)ans.push_back(<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= num; i ++){            <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>){                ans.push_back(ans[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);            }<span class="hljs-keyword">else</span>{                ans.push_back(ans[i/<span class="hljs-number">2</span>]);            }        }        <span class="hljs-keyword">return</span> ans;    }};</code></pre><h3 id="力扣45-跳跃游戏-II">力扣45 <a href="https://leetcode-cn.com/problems/jump-game-ii/">跳跃游戏 II</a></h3><h4 id="第一种思路使用动态规划：">第一种思路使用动态规划：</h4><p>另开数组记录每一个位置的步数，然后$f(x) = min({f(0),f(1),…f(x-1)})+1$</p><p>时间复杂度为$O(n^2)$</p><h4 id="第二种思路，从后往前">第二种思路，从后往前</h4><p>最坏时间复杂度也为$O(n^2)$，超出时间</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{        <span class="hljs-keyword">int</span> pos = nums.size()<span class="hljs-number">-1</span>;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(pos!=<span class="hljs-number">0</span>){            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pos; i ++){                <span class="hljs-keyword">if</span>(nums[i]+i &gt;= pos){                    pos = i;                    ans ++;                    <span class="hljs-keyword">break</span>;                }            }        }        <span class="hljs-keyword">return</span> ans;    }};</code></pre><h4 id="第三种思路，贪心算法">第三种思路，贪心算法</h4><p>时间复杂度为$O(n)$</p><p>在2的后面的两个数之中，找出一个能到达最远位置的数</p><img src="8.png" alt="image.png"><p>在3的后面的三个数之中，找出一个能到达最远位置的数</p><img src="9.png" alt="image.png"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> maxpos = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size()<span class="hljs-number">-1</span>; i ++){            maxpos = max(maxpos,nums[i]+i);            <span class="hljs-keyword">if</span>(i == end){                end = maxpos;                ans++;            }        }        <span class="hljs-keyword">return</span> ans;    }};</code></pre><h3 id="力扣198-打家劫舍">力扣198 <a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a></h3><h4 id="算法思路-10">算法思路</h4><p>转移方程：$f(i) = max(f(i-1),f(i-2)+nums[i])$</p><h4 id="代码实现-8">代码实现</h4><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{        <span class="hljs-keyword">if</span>(nums.size() == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> size = nums.size();        <span class="hljs-keyword">int</span> arr[size];        <span class="hljs-keyword">if</span>(size &gt;= <span class="hljs-number">1</span>)arr[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">if</span>(size &gt;= <span class="hljs-number">2</span>)arr[<span class="hljs-number">1</span>] = max(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; size; i ++){            arr[i] = max(arr[i<span class="hljs-number">-1</span>],arr[i<span class="hljs-number">-2</span>]+nums[i]);        }        <span class="hljs-keyword">return</span> arr[size<span class="hljs-number">-1</span>];    }};</code></pre><p>优化方案：发现可将上面的<code>arr</code>和<code>nums</code>合并为一个数组</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{        <span class="hljs-keyword">if</span>(nums.size() == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(nums.size() &gt;= <span class="hljs-number">2</span>)nums[<span class="hljs-number">1</span>] = max(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; nums.size(); i ++){            nums[i] = max(nums[i<span class="hljs-number">-1</span>],nums[i<span class="hljs-number">-2</span>]+nums[i]);        }        <span class="hljs-keyword">return</span> nums[nums.size()<span class="hljs-number">-1</span>];    }};</code></pre><h3 id="力扣213-打家劫舍-II">力扣213 <a href="https://leetcode-cn.com/problems/house-robber-ii/">打家劫舍 II</a></h3><h4 id="算法思路-11">算法思路</h4><ol><li>分为两种情况：（1）算头不算尾；（2）算尾不算头</li><li>在上述两种情况下，进行“打家劫舍”的操作</li></ol><h4 id="代码实现-9">代码实现</h4><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">first_rob</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp; nums)</span></span>{    <span class="hljs-keyword">if</span>(nums.size() &gt;= <span class="hljs-number">2</span>)nums[<span class="hljs-number">1</span>] = max(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; nums.size(); i ++){        nums[i] = max(nums[i<span class="hljs-number">-1</span>], nums[i<span class="hljs-number">-2</span>]+nums[i]);    }    <span class="hljs-keyword">return</span> nums[nums.size()<span class="hljs-number">-1</span>];}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{    <span class="hljs-comment">//分为两种情况，调用first_rob函数</span>    <span class="hljs-keyword">if</span>(nums.size()==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(nums.size() == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator head = nums.begin();    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator tail = nums.begin()+nums.size();    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">x</span><span class="hljs-params">(head+<span class="hljs-number">1</span>, tail)</span></span>;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">y</span><span class="hljs-params">(head, tail<span class="hljs-number">-1</span>)</span></span>;    <span class="hljs-keyword">return</span> max(first_rob(x), first_rob(y));}</code></pre><h3 id="力扣650-只有两个键的键盘">力扣650 <a href="https://leetcode-cn.com/problems/2-keys-keyboard/">只有两个键的键盘</a></h3><h4 id="算法思路：DP">算法思路：DP</h4><ol><li>寻找最大的因子<code>j</code></li><li>状态转移方程为$f(i) = f(j) + i/j$</li></ol><p>该算法效率不高，<mark>因为额外计算了很多不必要的量</mark>，最坏情况时间复杂度为$O(n^2)$</p><h4 id="代码实现-10">代码实现</h4><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSteps</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{    <span class="hljs-keyword">int</span> arr[n+<span class="hljs-number">1</span>];    <span class="hljs-keyword">if</span>(n &gt;= <span class="hljs-number">0</span>)arr[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(n &gt;= <span class="hljs-number">1</span>)arr[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(n &gt;= <span class="hljs-number">2</span>)arr[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i ++){        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>; j &gt;<span class="hljs-number">0</span>; j --){            <span class="hljs-keyword">if</span>(i%j == <span class="hljs-number">0</span>){                arr[i] = arr[j] + i/j;                <span class="hljs-keyword">break</span>;            }        }    }    <span class="hljs-keyword">return</span> arr[n];}</code></pre><h4 id="算法思路二：递归法">算法思路二：递归法</h4><h4 id="代码实现-11">代码实现</h4><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSteps</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n/<span class="hljs-number">2</span>; i &gt; <span class="hljs-number">1</span>; i--){            <span class="hljs-keyword">if</span>(n%i == <span class="hljs-number">0</span>){    <span class="hljs-comment">//得到最大因数</span>                <span class="hljs-keyword">return</span> minSteps(i)+n/i;                }        }        <span class="hljs-comment">//如果n为素数，则直接返回其本身。</span>        <span class="hljs-keyword">return</span> n;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贺新郎·读史</title>
    <link href="/Wuhlan3/2020/12/05/%E8%B4%BA%E6%96%B0%E9%83%8E%C2%B7%E8%AF%BB%E5%8F%B2/"/>
    <url>/Wuhlan3/2020/12/05/%E8%B4%BA%E6%96%B0%E9%83%8E%C2%B7%E8%AF%BB%E5%8F%B2/</url>
    
    <content type="html"><![CDATA[<center><h4>贺新郎·读史</h4></center><center>毛泽东</center><center>人猿相揖别。只几个石头磨过，小儿时节。</center><center>铜铁炉中翻火焰，为问何时猜得？不过几千寒热。</center><center>人世难逢开口笑，上疆场彼此弯弓月。</center><center>流遍了，郊原血。</center><br><center>一篇读罢头飞雪，但记得斑斑点点，几行陈迹。</center><center>五帝三皇神圣事，骗了无涯过客。有多少风流人物？</center><center>盗跖庄蹻流誉后，更陈王奋起挥黄钺。</center><center>歌未竟，东方白。</center><br><p>毛泽东的这首诗读来有许多触动。仅仅是开篇第一句就给我留下了极深的印象。</p><p>​“人猿相揖别”，寥寥数语，就将人类从猿进化过来的过程描述出来。想象到的是在一条时间线上，某一个特殊的时间节点，人类站在这一头，猿站在那一头，他们相互作了一个揖，便分道扬镳。而人类头也不回地往着继续进化的方向走去。此画面甚是诙谐有趣，仔细一想又有着历史的沉重感和使命感。</p><p>​“只几个石头磨过，小儿时节”，将石器时代比作人类的儿童时期。以一种居高临下的姿态看待人类，而对那时候人类的懵懂又形容的非常贴切。“磨”既是石器打磨的过程，也凸显了时间之久，间接体现了石器时代持续的时间之长。</p><p>​“铜铁炉中翻火焰，为问何时猜得？不过几千寒热。”，在这三句内又将铜器时代和铁器时代交代出来。其中铜与铁在火炉里炼制的过程是最能够代表这一时期的。如果要问具体是什么时候，我们很难知道，但不过是转眼数千年。其中“寒热”指的应该是寒暑，即春夏秋冬。</p><p>​“人世难逢开口笑，上疆场彼此弯弓月。流遍了，胶原血”，其中“认识难逢开口笑”化用了杜牧《九日齐山登高》诗中的一句：“尘世难逢开口笑”。这几句道尽了历史的真相。事实上在过往的历史中，人民生活艰苦，常处于水深火热之中，被统治阶级压迫。一辈子又有多少次真正的开口大笑。人类社会常常处于战乱的状态，相互争斗、残杀。“兴，百姓苦；亡，百姓苦”，王朝更替，但是社会的根本性质没有改变。鲜血已将山河的每一寸土地都染遍了。这里隐藏着毛泽东这位领导人对过往的叹息和开创一个能让人民开怀大笑的盛世的志向。</p><p>​“一篇读罢头飞雪，但记得斑斑点点，几行陈迹”，这一句有几种解释。一是毛泽东对这一生读史经历的总结，从青葱岁月到两鬓斑白，他将中国的历史通读了一遍，但到最后，留在记忆里的只有稀稀疏疏的星星点点；二是通过毛泽东的原稿可以发现，他将“一遍”改为“一篇”，我们只好解释为，当读到某篇史篇时，恍如置身冰雪，寒心愤怒至极。第二种解释与上文“流遍了，胶原血”联系更加紧密。</p><p>​“五帝三皇神圣事，骗了无涯过客。”这一句话，直接揭开史书的本质，语言十分犀利。有一句话这么说来着：“历史是一个任人打扮的小姑娘”。历史书不过是统治阶级为了巩固统治地位、维护自己神圣的形象，文人墨客、历史学家也随声附和，编造出所谓的正统思想来蒙蔽人民群众。既然如此，我们为什么还要读史呢？毛泽东曾给出过这个问题的答案。</p><p><img src="1.png" alt="1"></p><blockquote><p>令芦荻没有想到的是，毛泽东尽管酷爱历史，但在谈到该如何读二十四史时，却提出了一个让人吃惊的告诫，他说：“一部二十四史大半是假的，所谓实录之类也大半是假的。但是，如果因为大半是假的就不读了，那就是形而上学。不读，靠什么来了解历史呢？反过来，一切信以为真，书上的每句话，都被当作证实历史的信条，那就是历史唯心论了。正确的态度是用马克思主义的立场、观点和方法，分析它，批判它。把颠倒的历史颠倒过来。一部二十四史，写符瑞、迷信的文字，就占了不少，各朝各代的史书里都有。像《史记·高祖本纪》和《汉书·高帝纪》里，都写了刘邦斩白蛇的故事，又写了刘邦藏身的地方，上面常有云气，这一切都是骗人的鬼话。每一部史书，都是由继建的新王朝的臣子奉命修撰的，凡关系到本朝统治者不光彩的地方，自然不能写，也不敢写。如宋太祖赵匡胤本是后周的臣子，奉命北征，走到陈桥驿，竟发动兵变，篡夺了周的政权。宋臣薛居正等撰写的《旧五代史》里却说，他是黄袍加身，是受将士们‘擐甲将刃’、‘拥迫南行’被迫的结果，并把这次政变解释成是‘知其数而顺乎人’的正义行为。同时，封建社会有一条‘为尊者讳’的伦理道德标准，凡皇帝或父亲的恶性，或是隐而不书，或是把责任推给臣下或他人。譬如，宋高宗和秦桧主和投降，实际上，主和的责任不全在秦桧，起决定作用的是幕后的高宗赵构，这在《宋史·奸臣传》的《秦桧传》里，是多少有所反映的。特别是洋洋4000万言的二十四史，写的差不多都是帝王将相，人民群众的生活情形、生产情形，大多是只字不提，有的写了些，也是笼统地一笔带过，目的是谈如何加强统治的问题。有的更被歪曲地写了进去，如农民反压迫、剥削的斗争，一律被骂成十恶不赦的‘匪’、‘贼’、‘逆’。这是最不符合历史真实的假话。”</p></blockquote><blockquote><p>毛泽东还说：“搞文学史的人，一定要好好地读历史，要认真地读《资治通鉴》、二十四史。但要用马克思主义的立场、观点和方法读，否则就读不好，弄不清历史发展的头绪。要明白，所谓正史，那是指合乎封建统治阶级要求的‘正’，所以，书里总是给统治阶级制造迷信，说许多天命、符瑞之类的骗人的鬼话。所以书里要‘为尊者讳’，并把反抗他们起义的农民群众骂做‘匪’。其实，有些稗官野史由于不是官方修撰的，有时倒会写出点实情。所以，二十四史要读，《资治通鉴》要读，稗官野史、笔记小说也要读。历史书籍要多读，多读一本，就多了一份调查研究。读得多了，又有正确的立场和观点，进行判断和评论，就较少失误，这是辩证法，也是把被颠倒的历史再颠倒过来的重要的条件。”</p></blockquote><p>​“有多少风流人物？盗跖庄蹻流誉后，更陈王奋起挥黄钺”，此句可见，毛泽东对历史中帝王将相的丰功伟绩没有多加赞赏，反而对于盗跖、庄蹻、陈胜这样揭竿而起、反抗暴政的英雄更加敬佩，认为他们才是风流人物。粪土当年万户侯，而人民才是历史的创造者。</p><p>​“歌未竟，东方白”这句话有着不同的理解。一种是积极乐观的：历史这一首诗歌还没唱完，天就已经亮了，东方出现太阳，寓意着作者对未来充满期待，数风流人物还看今朝；另一种带有着悲观的色彩：结合当时时代背景来看，这首诗写于1965年，而在1963年的时候，毛泽东曾严厉批党内的腐败风气“进京赶考不及格了”、“很多干部快变成了李自成”。他突然明白阶级斗争从未结束，仍要继续斗争。</p><p>​</p><p>​这首诗的解读更多是翻看别人的感想汇总的，希望多年之后我再次读，会有不同的感受。</p><h4 id="参考资料">参考资料</h4><p>[1] 知乎 落花飞絮 <a href="https://www.zhihu.com/question/23701356/answer/175949600">https://www.zhihu.com/question/23701356/answer/175949600</a></p><p>[2] <a href="http://www.xinfajia.net/content/wview/11955.page">http://www.xinfajia.net/content/wview/11955.page</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>不务正业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>verilog基础</title>
    <link href="/Wuhlan3/2020/11/17/verilog%E5%9F%BA%E7%A1%80/"/>
    <url>/Wuhlan3/2020/11/17/verilog%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1>Verilog HDL基础</h1><p>​硬件描述语言HDL（Hardware Description Language）是硬件设计人员和电子自动化（EDA）工具之间的接口，其主要目的是用来编写设计文件，建立电子系统行为级的仿真模型。</p><p>​硬件描述语言利用计算机的强大功能对用HDL建模的复杂数字逻辑进行仿真，然后自动综合以生成符合要求且再电路结构上可以实现的数字逻辑网表（Netlist），根据网表和某种工艺的器件自动生成具体电路然后生成该工艺条件下这种具体电路的延时模型。仿真验证无误后用于制造ASIC芯片或写入CPLD和FPGA器件中。</p><p>这种特殊结构能够：</p><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>描述电路的连接<span class="hljs-number">2.</span>描述电路的功能<span class="hljs-number">3.</span>在不同抽象级上描述电路<span class="hljs-number">4.</span>描述电路的时序<span class="hljs-number">5.</span>表达具有并行性</code></pre><p>HDL主要有两种：Verilog 和 VHDL</p><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>verilog 起源于C语言，容易掌握<span class="hljs-number">2.</span>VHDL格式严谨<span class="hljs-number">3.</span>VHDL出现较晚，但标准化早。IEEE <span class="hljs-number">1706</span><span class="hljs-number">-1985</span>标准</code></pre><p>行为级的抽象：</p><pre><code class="hljs gcode">·系统级<span class="hljs-comment">(system)</span>·算法级<span class="hljs-comment">(algorithm)</span>·寄存器传输级<span class="hljs-comment">(RTL)</span><span class="hljs-comment">(Register Transfer Level)</span>·逻辑门级<span class="hljs-comment">(gate)</span>·开关电路级<span class="hljs-comment">(switch)</span></code></pre><p>对于这些，较适合使用Verilog设计；对于特大型（千万门级以上）的系统级设计，则VHDL比较合适。</p><h3 id="Verilog的设计方法">Verilog的设计方法</h3><ol><li>自顶向下（top-down）（与模拟电路自底向上相对）</li></ol><p><img src="1.png" alt="img"></p><ol start="2"><li><p>模块设计流程：</p><p><img src="2.png" alt="img"></p></li></ol><p><strong>需求分析</strong></p><p>工作人员需要对用户提出的功能要求进行分析理解，做出电路系统的整体规划，形成详细的技术指标，确定初步方案。例如，要设计一个电子屏，需要考虑供电方式、工作频率、产品体积、成本、功耗等，电路实现采用 ASIC 还是选用 FPGA/CPLD 器件等。</p><p><strong>功能划分</strong></p><p>正确地分析了用户的电路需求后，就可以进行逻辑功能的总体设计，设计整个电路的功能、接口和总体结构，考虑功能模块的划分和设计思路，各子模块的接口和时序（包括接口时序和内部信号的时序）等，向项目组成员合理分配子模块设计任务。</p><p><strong>文本描述</strong></p><p>可以用任意的文本编辑器，也可以用专用的 HDL 编辑环境，对所需求的数字电路进行设计建模，保存为 <strong>.v</strong> 文件。</p><p><strong>功能仿真（前仿真）</strong></p><p>对建模文件进行编译，对模型电路进行功能上的仿真验证，查找设计的错误并修正。</p><p>此时的仿真验证并没有考虑到信号的延迟等一些 timing 因素，只是验证逻辑上的正确性。</p><p><strong>逻辑综合</strong></p><p>综合（synthesize），就是在标准单元库和特定的设计约束的基础上，将设计的高层次描述（Verilog 建模）转换为门级网表的过程。逻辑综合的目的是产生物理电路门级结构，并在逻辑、时序上进行一定程度的优化，寻求逻辑、面积、功耗的平衡，增强电路的可测试性。</p><p>但不是所有的 Verilog 语句都是可以综合成逻辑单元的，例如时延语句。</p><p><strong>布局布线</strong></p><p>根据逻辑综合出的网表与约束文件，利用厂家提供的各种基本标准单元库，对门级电路进行布局布线。至此，已经将 Verilog 设计的数字电路，设计成由标准单元库组成的数字电路。</p><p><strong>时序仿真（后仿真）</strong></p><p>布局布线后，电路模型中已经包含了时延信息。利用在布局布线中获得的精确参数，用仿真软件验证电路的时序。单元器件的不同、布局布线方案都会给电路的时序造成影响，严重时会出现错误。出错后可能就需要重新修改 RTL（寄存器传输级描述，即 Verilog 初版描述），重复后面的步骤。这样的过程可能反复多次，直至错误完全排除。</p><p><strong>FPGA/CPLD 下载或 ASIC 制造工艺生产</strong></p><p>完成上面所有步骤后，就可以通过开发工具将设计的数字电路目标文件下载到 FPGA/CPLD 芯片中，然后在电路板上进行调试、验证。</p><p>如果要在 ASIC 上实现，则需要制造芯片。一般芯片制造时，也需要先在 FPGA 板卡上进行逻辑功能的验证。</p><h3 id="基础语法">基础语法</h3><h4 id="多路选择器">多路选择器</h4><p>（没有考虑延时问题）</p><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> muxtwo(out, a, b, s1);<span class="hljs-comment">//该模块中包含这些变量</span>    <span class="hljs-keyword">input</span> a,b,s1;    <span class="hljs-keyword">output</span> out;    <span class="hljs-keyword">reg</span> out;    <span class="hljs-keyword">always</span> @(s1 <span class="hljs-keyword">or</span> a <span class="hljs-keyword">or</span> b)<span class="hljs-comment">//当sl或a或b发生变化时，执行下列语句</span>    <span class="hljs-keyword">if</span> (! s1) out = a;    <span class="hljs-keyword">else</span> out = b;    <span class="hljs-keyword">endmodule</span></code></pre><p><img src="3.png" alt="image-20201109201401720"></p><p>结构级描述（描述中含有传输延时）</p><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> twomux(out,a,b,s1);    <span class="hljs-keyword">input</span> a,b,s1;    <span class="hljs-keyword">output</span> out;    <span class="hljs-keyword">not</span> u1(ns1, s1);<span class="hljs-comment">//ns1 非门</span>    <span class="hljs-keyword">and</span> #<span class="hljs-number">1</span> u2(se1a, a, ns1);<span class="hljs-comment">//se1a se1b 与门a和b</span>    <span class="hljs-keyword">and</span> #<span class="hljs-number">1</span> u3(se1b, b, s1);    <span class="hljs-keyword">or</span>#<span class="hljs-number">2</span> u4(out, se1a, se1b);<span class="hljs-keyword">endmodule</span></code></pre><h4 id="三位加法器">三位加法器</h4><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> adder(count, sum, a, b, cin);    <span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] a,b;<span class="hljs-comment">//分配三位</span>    <span class="hljs-keyword">input</span> cin;<span class="hljs-comment">//输入进位</span>    <span class="hljs-keyword">output</span> cout;<span class="hljs-comment">//输出进位</span>    <span class="hljs-keyword">output</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] sum;    <span class="hljs-keyword">assign</span> {cout, sum} = a+b+cin;     <span class="hljs-keyword">endmodule</span></code></pre><h4 id="两位比较器">两位比较器</h4><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> compare(equal,a,b);    <span class="hljs-keyword">output</span> equal;    <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]a,b;    <span class="hljs-keyword">assign</span> equal=(a==b) ? <span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<span class="hljs-keyword">endmodule</span></code></pre><h2 id="三、模块">三、模块</h2><p>模块分为两部分：一、描述接口；二、描述逻辑功能</p><p>声明输入输出口：<code>module 模块名(口1,口2,口3,……)</code></p><h5 id="1-I-O说明：">1.I/O说明：</h5><p>输入口：<code>input[信号位宽-1:0]端口名</code></p><p>输出口：<code>output[信号位宽-1:0]端口名</code></p><p>输入/输出口：<code>inout[信号位宽-1:0]端口名</code></p><p>也可以卸载端口声明中：<code>module module_name(input port1, input port2,output port1, output port2……)</code></p><h5 id="2-内部信号说明：">2.内部信号说明：</h5><p>在模块内用到的和与端口有关的wire和 reg 类型变量的声明。</p><p>如<code>reg[width-1:0]R变量1,R变量2……;</code></p><p><code>wire[width-1:0]W变量1,W变量2……;</code></p><h5 id="3-功能定义">3.功能定义</h5><p>（1）<code>assign</code>声明，如<code>assign a = b &amp; c;</code></p><p>（2）用实例元件，如<code>and #2 ul(q,a,b);</code>（ul是与门的名，#2指输出延迟两个单位时间，输入a,b，输出q）</p><p>（3）<code>always</code>块，如</p><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> clr);<span class="hljs-keyword">begin</span>     <span class="hljs-keyword">if</span>(clr) q&lt;= <span class="hljs-number">0</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(en) q&lt;=d;<span class="hljs-keyword">end</span></code></pre><p><strong>注意：上述3种例子是同时执行的（并发），顺序不会影响功能的实现；但是在always模块内，逻辑是按照指定顺序执行</strong></p><p><img src="4.png" alt="image-20201115145325925"></p><p><img src="5.png" alt="image-20201115145339991"></p><h4 id="数据类型及其常量和变量">数据类型及其常量和变量</h4><p><img src="6.png" alt="image-20201115145641460"></p><p><img src="7.png" alt="image-20201115145742133"></p><p><img src="9.png" alt="image-20201115145844734"></p><p><img src="10.png" alt="image-20201115145903038"></p><h5 id="变量：">变量：</h5><ol><li><p>wire型</p><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> a;<span class="hljs-comment">//定义一个1位wire数据</span><span class="hljs-keyword">wire</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]b;<span class="hljs-comment">//定义一个8位wire数据</span><span class="hljs-keyword">wire</span>[<span class="hljs-number">4</span>:<span class="hljs-number">1</span>]c,d;<span class="hljs-comment">//定义两个4位wire数据</span></code></pre></li><li><p>reg型</p><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> rega;<span class="hljs-comment">//定义一个1位reg数据</span><span class="hljs-keyword">reg</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]regb;<span class="hljs-comment">//定义一个8位reg数据</span><span class="hljs-keyword">reg</span>[<span class="hljs-number">4</span>:<span class="hljs-number">1</span>]regc,regd;<span class="hljs-comment">//定义两个4位reg数据</span></code></pre><p><img src="11.png" alt="image-20201115150754701"></p></li><li><p>memory型</p><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] mema[<span class="hljs-number">255</span>,<span class="hljs-number">0</span>];<span class="hljs-comment">//一个名为mema的存储器，有256个8位的寄存器</span></code></pre><p>区别：</p><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span>[n-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] rega;<span class="hljs-comment">//一个n位寄存器</span><span class="hljs-keyword">reg</span> mema [n-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];<span class="hljs-comment">//一个n个1位寄存器构成的存储器</span></code></pre></li></ol><h2 id="四、运算符">四、运算符</h2><p><img src="12.png" alt="image-20201115151500409"></p><h4 id="Verilog特殊运算符">Verilog特殊运算符</h4><ol><li><code>===</code>和<code>!==</code></li></ol><p><img src="13.png" alt="image-20201115204158446"></p><ol start="2"><li><p>位拼接运算符</p><pre><code class="hljs verilog">{a,b[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>],w,<span class="hljs-number">3'b101</span>}等于：{a,b[<span class="hljs-number">3</span>],b[<span class="hljs-number">2</span>],b[<span class="hljs-number">1</span>],b[<span class="hljs-number">0</span>],w,<span class="hljs-number">1'b1</span>,<span class="hljs-number">1'b0</span>,<span class="hljs-number">1'b1</span>}{<span class="hljs-number">4</span>{w}}<span class="hljs-comment">//等同于{w,w,w,w}</span>{b,<span class="hljs-number">3</span>{a,b}}<span class="hljs-comment">//可嵌套，等同于{b,a,b,a,b,a,b}</span></code></pre></li><li><p>缩减运算符</p><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] B;<span class="hljs-keyword">reg</span> C;    C = &amp;B;<span class="hljs-comment">//相当于</span>    C = ((B[<span class="hljs-number">0</span>]&amp;B[<span class="hljs-number">1</span>])&amp;B[<span class="hljs-number">2</span>])&amp;[<span class="hljs-number">3</span>]</code></pre><p><img src="14.png" alt="image-20201115205211934"></p></li></ol><h4 id="赋值语句">赋值语句</h4><ol><li><p>非阻塞赋值<code>a &lt;= b</code></p><p>(1)在语句块中，上述语句所赋的变量值不能立即为下面的语句所用</p><p>(2)块结束之后才能完成本次操作，而所赋的值是上次赋值得到的</p><p>(3)在编写可综合的时序逻辑模块时，这是最常用的赋值方法</p></li><li><p>阻塞赋值<code>a = b</code></p><p>(1)赋值语句执行完后，块才结束</p><p>(2)b的值在赋值语句执行完后，立刻就能改变</p><p>(3)在时序逻辑中使用，可能会出现意想不到的效果（贬义）</p></li></ol><p>简单理解</p><p>​1.非阻塞赋值：</p><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)    <span class="hljs-keyword">begin</span>         b &lt;= a;        c &lt;= b;    <span class="hljs-keyword">end</span></code></pre><p><img src="15.png" alt=""></p><ol start="2"><li>阻塞赋值：</li></ol><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)    <span class="hljs-keyword">begin</span>         b = a;        c = b;    <span class="hljs-keyword">end</span></code></pre><p><img src="16.png" alt="image-20201115211628565"></p><h4 id="块语句">块语句</h4><ol><li><p>顺序块</p><pre><code class="hljs verilog"><span class="hljs-keyword">begin</span>    语句<span class="hljs-number">1</span>；    语句<span class="hljs-number">2</span>；    ……<span class="hljs-keyword">end</span></code></pre><pre><code class="hljs verilog"><span class="hljs-keyword">begin</span>:块名    语句<span class="hljs-number">1</span>；    语句<span class="hljs-number">2</span>；    ……<span class="hljs-keyword">end</span></code></pre></li><li><p>并行块</p><pre><code class="hljs verilog"><span class="hljs-keyword">fork</span>    语句<span class="hljs-number">1</span>：    语句<span class="hljs-number">2</span>：    ……<span class="hljs-keyword">join</span></code></pre><pre><code class="hljs verilog"><span class="hljs-keyword">fork</span>:块名    语句<span class="hljs-number">1</span>：    语句<span class="hljs-number">2</span>：    ……<span class="hljs-keyword">join</span></code></pre></li><li><p>起始时间和结束时间</p><p>顺序块：起始时间就是第一条语句开始被执行的时间，结束时间就是最后一条语句执行完的时间</p><p>并行块：起始时间对于所有块来说是相同的，结束时间是按时间排序在最后的语句执行结束的时间。</p></li></ol><p>分支与循环</p><ol><li><p>if 没啥好说的</p></li><li><p>case：</p><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] rega;<span class="hljs-keyword">reg</span>[<span class="hljs-number">9</span>:<span class="hljs-number">0</span>]  result;<span class="hljs-keyword">case</span>(rega)    <span class="hljs-number">16'd0</span>: result = <span class="hljs-number">10'b0111_1111_11</span>    <span class="hljs-number">16'd1</span>: result = <span class="hljs-number">10'b1011_1111_11</span>    <span class="hljs-number">16'd2</span>: result = <span class="hljs-number">10'b1101_1111_11</span>    <span class="hljs-number">16'd3</span>: result = <span class="hljs-number">10'b1110_1111_11</span>    <span class="hljs-number">16'd4</span>: result = <span class="hljs-number">10'b1111_0111_11</span>    <span class="hljs-number">16'd5</span>: result = <span class="hljs-number">10'b1111_1111_11</span>    <span class="hljs-number">16'd6</span>: result = <span class="hljs-number">10'b1111_1111_11</span>    <span class="hljs-number">16'd7</span>: result = <span class="hljs-number">10'b1111_1111_11</span>    <span class="hljs-number">16'd8</span>: result = <span class="hljs-number">10'b1111_1111_11</span>    <span class="hljs-number">16'd9</span>: result = <span class="hljs-number">10'b1111_1111_11</span>    <span class="hljs-keyword">default</span>: result = <span class="hljs-number">10'bx</span><span class="hljs-keyword">endcase</span></code></pre></li><li><p>forever（多用于产生周期性波形）</p><pre><code class="hljs verilog"><span class="hljs-keyword">forever</span> 语句；或：<span class="hljs-keyword">forever</span>    <span class="hljs-keyword">begin</span>        多条语句    <span class="hljs-keyword">end</span></code></pre></li><li><p>repeat（后常接常量表达式）</p><pre><code class="hljs verilog"><span class="hljs-keyword">repeat</span>(表达式) 语句；或：<span class="hljs-keyword">repeat</span>（表达式）    <span class="hljs-keyword">begin</span>        多条语句    <span class="hljs-keyword">end</span></code></pre></li><li><p>while</p><pre><code class="hljs verilog"><span class="hljs-keyword">while</span>(表达式) 语句；或：<span class="hljs-keyword">while</span>（表达式）    <span class="hljs-keyword">begin</span>        多条语句    <span class="hljs-keyword">end</span></code></pre></li><li><p>for 没啥好说的</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可怜的小猪</title>
    <link href="/Wuhlan3/2020/10/29/%E5%8F%AF%E6%80%9C%E7%9A%84%E5%B0%8F%E7%8C%AA/"/>
    <url>/Wuhlan3/2020/10/29/%E5%8F%AF%E6%80%9C%E7%9A%84%E5%B0%8F%E7%8C%AA/</url>
    
    <content type="html"><![CDATA[<h5 id="题目">题目</h5><p>有 1000 只水桶，其中有且只有一桶装的含有毒药，其余装的都是水。它们从外观看起来都一样。如果小猪🐷喝了毒药，它会在 15 分钟内死去。</p><p>问题来了，如果需要你在一小时内，弄清楚哪只水桶含有毒药，你最少需要多少只猪？</p><p>回答这个问题，并为下列的进阶问题编写一个通用算法。</p><h5 id="进阶">进阶:</h5><p>假设有 n 只水桶，猪饮水中毒后会在 m 分钟内死亡，你需要多少猪（x）就能在 p 分钟内找出 “有毒” 水桶？这 n 只水桶里有且仅有一只有毒的桶。</p><h5 id="提示：">提示：</h5><p>可以允许小猪同时饮用任意数量的桶中的水，并且该过程不需要时间。<br>小猪喝完水后，必须有 m 分钟的冷却时间。在这段时间里，只允许观察，而不允许继续饮水。<br>任何给定的桶都可以无限次采样（无限数量的猪）。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">poorPigs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> buckets, <span class="hljs-keyword">int</span> minutesToDie, <span class="hljs-keyword">int</span> minutesToTest)</span> </span>{    <span class="hljs-keyword">if</span>(buckets == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> matrixsize = minutesToTest / minutesToDie +<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> pigsnum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(max &lt; buckets){        pigsnum++;        max = <span class="hljs-built_in">pow</span>(matrixsize,pigsnum);    }    <span class="hljs-keyword">return</span> pigsnum;}</code></pre><p>或：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">poorPigs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> buckets, <span class="hljs-keyword">int</span> minutesToDie, <span class="hljs-keyword">int</span> minutesToTest)</span> </span>{        <span class="hljs-keyword">int</span> states = minutesToTest / minutesToDie + <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">log</span>(buckets) / <span class="hljs-built_in">log</span>(states));    }</code></pre><p>详细思路可看：<a href="https://leetcode-cn.com/problems/poor-pigs/solution/ke-lian-de-xiao-zhu-by-leetcode/">https://leetcode-cn.com/problems/poor-pigs/solution/ke-lian-de-xiao-zhu-by-leetcode/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>空瓶换新酒</title>
    <link href="/Wuhlan3/2020/10/29/%E7%A9%BA%E7%93%B6%E6%8D%A2%E6%96%B0%E9%85%92/"/>
    <url>/Wuhlan3/2020/10/29/%E7%A9%BA%E7%93%B6%E6%8D%A2%E6%96%B0%E9%85%92/</url>
    
    <content type="html"><![CDATA[<h2 id="空瓶换新酒">空瓶换新酒</h2><p>小区便利店正在促销，用 numExchange 个空酒瓶（&gt;1）可以兑换一瓶新酒。你购入了 numBottles 瓶酒。</p><p>如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。</p><p>请你计算 最多能喝到多少瓶酒。(不可以赊账，可以思考如何使用$O(1)$的方法来解决)</p><pre><code class="hljs angelscript">input:T <span class="hljs-comment">//测试样例总数:</span>numBottles numExchange…示例：输入：<span class="hljs-number">9</span> <span class="hljs-number">3</span>输出：<span class="hljs-number">13</span></code></pre><h4 id="递归法">递归法</h4><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWaterBottles</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numBottles, <span class="hljs-keyword">int</span> numExchange)</span></span>{    <span class="hljs-keyword">if</span>(numBottles &lt; numExchange){        <span class="hljs-keyword">return</span> numBottles;    }    <span class="hljs-keyword">int</span> drunk = numBottles - numBottles % numExchange;    <span class="hljs-keyword">return</span> numWaterBottles(numBottles / numExchange+numBottles % numExchange, numExchange) + drunk;}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{        <span class="hljs-keyword">int</span> numBottles,numExchange;        <span class="hljs-built_in">cin</span>&gt;&gt;numBottles&gt;&gt;numExchange;        <span class="hljs-built_in">cout</span>&lt;&lt;numWaterBottles(numBottles, numExchange);}</code></pre><h4 id="O-1-法">O(1)法</h4><p><img src="bottle.png" alt="bottle"></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{        <span class="hljs-keyword">int</span> numBottles,numExchange;        <span class="hljs-built_in">cin</span>&gt;&gt;numBottles&gt;&gt;numExchange;        <span class="hljs-built_in">cout</span>&lt;&lt;(numBottles * numExchange<span class="hljs-number">-1</span>)/(numExchange<span class="hljs-number">-1</span>)&lt;&lt;<span class="hljs-built_in">endl</span>;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIPS</title>
    <link href="/Wuhlan3/2020/10/16/MIPS/"/>
    <url>/Wuhlan3/2020/10/16/MIPS/</url>
    
    <content type="html"><![CDATA[<h4 id="二、MIPS操作数之32个寄存器">二、MIPS操作数之32个寄存器</h4><table><thead><tr><th style="text-align:left">寄存器名字</th><th style="text-align:left">寄存器编号</th><th style="text-align:left">寄存器功能</th></tr></thead><tbody><tr><td style="text-align:left"><code>$zero</code></td><td style="text-align:left"><code>$0</code></td><td style="text-align:left">恒等于零</td></tr><tr><td style="text-align:left"><code>$at</code></td><td style="text-align:left"><code>$1</code></td><td style="text-align:left">被汇编器保留，用于处理大的常数</td></tr><tr><td style="text-align:left"><code>$v0 – $v1</code></td><td style="text-align:left"><code>$2-$3</code></td><td style="text-align:left">存放函数返回值</td></tr><tr><td style="text-align:left"><code>$a0 – $a3</code></td><td style="text-align:left"><code>$4-$7</code></td><td style="text-align:left">传递函数参数</td></tr><tr><td style="text-align:left"><code>$t0 – $t7</code></td><td style="text-align:left"><code>$8-$15</code></td><td style="text-align:left">存放临时变量</td></tr><tr><td style="text-align:left"><code>$s0 – $s7</code></td><td style="text-align:left"><code>$16-$23</code></td><td style="text-align:left">存放需要保存的临时值</td></tr><tr><td style="text-align:left"><code>$t8 – $t9</code></td><td style="text-align:left"><code>$24-$25</code></td><td style="text-align:left">额外的存放临时变量</td></tr><tr><td style="text-align:left"><code>$k0 – $k1</code></td><td style="text-align:left"><code>$26-$27</code></td><td style="text-align:left">用于操作系统内核</td></tr><tr><td style="text-align:left"><code>$gp</code></td><td style="text-align:left"><code>$28</code></td><td style="text-align:left">指向全局变量的指针</td></tr><tr><td style="text-align:left"><code>$sp</code></td><td style="text-align:left"><code>$29</code></td><td style="text-align:left">指向栈顶的指针</td></tr><tr><td style="text-align:left"><code>$fp</code></td><td style="text-align:left"><code>$30</code></td><td style="text-align:left">指向栈帧[^footnote2]的指针</td></tr><tr><td style="text-align:left"><code>$ra</code></td><td style="text-align:left"><code>$31</code></td><td style="text-align:left">返回地址，用于函数调用</td></tr></tbody></table><h4 id="三、MIPS汇编语言指令类型及寻址方式">三、MIPS汇编语言指令类型及寻址方式</h4><p><img src="mips1.png" alt="image-20201016100110436"></p><p><img src="mips2.png" alt="image-20201016100254039"></p><p>不调用其他过程的过程称为<strong>叶过程</strong>（leaf procedure）</p><h5 id="编译一个不调用其他过程的C过程">编译一个不调用其他过程的C过程</h5><p>思考步骤：</p><ol><li>保存调用过程之后，还需要使用的寄存器<code>$t0~$t7</code>、<code>$a0~$a1</code>、<code>$v0~$v1</code></li><li>保存用到的参数（<code>$a0~$a1</code>）</li><li>保存返回地址<code>$ra</code></li></ol><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">leaf_example</span><span class="hljs-params">(<span class="hljs-keyword">int</span> g, <span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>{    <span class="hljs-keyword">int</span> f;    f = (g+h)-(i+j);    <span class="hljs-keyword">return</span> f}</code></pre><p>MIPS：</p><pre><code class="hljs mipsasm"><span class="hljs-symbol">leaf_example:</span>    <span class="hljs-keyword">addi</span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">sp</span>, -<span class="hljs-number">12</span> <span class="hljs-comment">#在栈中分配3个空间</span>    <span class="hljs-keyword">sw</span>$<span class="hljs-built_in">t1</span>, <span class="hljs-number">8</span>($<span class="hljs-built_in">sp</span>)<span class="hljs-comment">#push $t1</span>    <span class="hljs-keyword">sw</span>$<span class="hljs-built_in">t0</span>, <span class="hljs-number">4</span>($<span class="hljs-built_in">sp</span>)<span class="hljs-comment">#push $t0</span>    <span class="hljs-keyword">sw</span>$<span class="hljs-built_in">s0</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<span class="hljs-comment">#push $s0</span>        <span class="hljs-keyword">add</span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">a0</span>, $<span class="hljs-built_in">a1</span><span class="hljs-comment">#t0 = g + h</span>    <span class="hljs-keyword">add</span>$<span class="hljs-built_in">t1</span>, $<span class="hljs-built_in">a2</span>, $<span class="hljs-built_in">a3</span><span class="hljs-comment">#t1 = i + j</span>    <span class="hljs-keyword">sub </span>$<span class="hljs-built_in">s0</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span><span class="hljs-comment">#f = g + h - (i + j)</span>    <span class="hljs-keyword">add</span>$<span class="hljs-built_in">v0</span>, $<span class="hljs-built_in">s0</span>, $<span class="hljs-built_in">zero</span><span class="hljs-comment">#将f放入一个返回值寄存器v0中</span>        <span class="hljs-keyword">lw </span>$<span class="hljs-built_in">s0</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<span class="hljs-comment">#弹出s0</span>    <span class="hljs-keyword">lw </span>$<span class="hljs-built_in">t0</span>, <span class="hljs-number">4</span>($<span class="hljs-built_in">sp</span>)<span class="hljs-comment">#弹出t0</span>    <span class="hljs-keyword">lw</span>$<span class="hljs-built_in">t1</span>, <span class="hljs-number">8</span>($<span class="hljs-built_in">sp</span>)<span class="hljs-comment">#弹出t1</span>    <span class="hljs-keyword">addi</span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">sp</span>, <span class="hljs-number">12</span><span class="hljs-comment">#恢复</span>        <span class="hljs-keyword">jr</span>$<span class="hljs-built_in">ra</span><span class="hljs-comment">#根据返回地址跳转</span></code></pre><h5 id="编译一个递归C过程">编译一个递归C过程</h5><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{    <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span>         <span class="hljs-keyword">return</span> (n*fact(n<span class="hljs-number">-1</span>));}</code></pre><p>MIPS:</p><pre><code class="hljs mipsasm"><span class="hljs-symbol">fact:</span>    <span class="hljs-keyword">addi</span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">sp</span>, -<span class="hljs-number">8</span><span class="hljs-comment">#在栈中分配两个空间</span>    <span class="hljs-keyword">sw</span>$<span class="hljs-built_in">ra</span>, <span class="hljs-number">4</span>($<span class="hljs-built_in">sp</span>)<span class="hljs-comment">#push ra, 如果没有这一步就回不来了</span>    <span class="hljs-keyword">sw</span>$<span class="hljs-built_in">a0</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<span class="hljs-comment">#push n</span>        <span class="hljs-keyword">slti</span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">a0</span>, <span class="hljs-number">1</span>    <span class="hljs-keyword">beq</span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">zero</span>, L1<span class="hljs-comment">#if(n&gt;=1),goto L1</span>        <span class="hljs-keyword">addi</span>$<span class="hljs-built_in">v0</span>, $<span class="hljs-built_in">zero</span>, <span class="hljs-number">1</span><span class="hljs-comment">#return 1</span>    <span class="hljs-keyword">addi </span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">sp</span>, <span class="hljs-number">8</span><span class="hljs-comment">#弹出</span>    <span class="hljs-keyword">jr</span>$<span class="hljs-built_in">ra</span>    <span class="hljs-symbol">L1:</span>    <span class="hljs-keyword">addi</span>$<span class="hljs-built_in">a0</span>, $<span class="hljs-built_in">a0</span>, -<span class="hljs-number">1</span><span class="hljs-comment"># n = n - 1</span>    <span class="hljs-keyword">jal </span>fact<span class="hljs-comment"># 递归调用fact，此时v0= fact(n-1)</span>        <span class="hljs-keyword">lw</span>$<span class="hljs-built_in">a0</span>, <span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<span class="hljs-comment">#取出a0</span>    <span class="hljs-keyword">lw</span>$<span class="hljs-built_in">ra</span>, <span class="hljs-number">4</span>($<span class="hljs-built_in">sp</span>)<span class="hljs-comment">#取出ra</span>    <span class="hljs-keyword">addi</span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">sp</span>, <span class="hljs-number">8</span><span class="hljs-comment">#栈弹出两个空间</span>        <span class="hljs-keyword">mul </span> $<span class="hljs-built_in">v0</span>, $<span class="hljs-built_in">a0</span>, $<span class="hljs-built_in">v0</span> <span class="hljs-comment">#return n*fact(n-1)</span>        <span class="hljs-keyword">jr</span>$<span class="hljs-built_in">ra</span></code></pre><p>未完待续……</p><h3 id="参考资料">参考资料</h3><p>[1]https://blog.csdn.net/qq_32146369/article/details/79006728</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十大排序</title>
    <link href="/Wuhlan3/2020/10/07/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/"/>
    <url>/Wuhlan3/2020/10/07/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="十大排序算法">十大排序算法</h2><p><strong>经典图镇楼</strong></p><p><img src="sort.png" alt="image-festival"></p><p>在STL中，是以函数sort实现的</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(iterator begin, iterator end)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(iterator begin, iterator end, comparator cmp)</span></span>;</code></pre><p>迭代器必须支持随机访问。sort算法并不能保证相等的项保持他们原有的顺序。（若这很重要，可以使用<code>stable_sort</code>）这里一般使用的是快速排序。</p><h3 id="冒泡排序">冒泡排序</h3><p><img src="bubbleSort.gif" alt="image-festival"></p><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//整数或浮点数皆可使用,若使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(T arr[], <span class="hljs-keyword">int</span> len)</span> </span>{        <span class="hljs-keyword">int</span> i, j;        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++)                <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++)                        <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])                                swap(arr[j], arr[j + <span class="hljs-number">1</span>]);}</code></pre><h3 id="选择排序">选择排序</h3><p><img src="selectionSort.gif" alt="image-festival"></p><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//整数或浮点数皆可使用,若使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selection_sort</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt;&amp; arr)</span> </span>{        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size() - <span class="hljs-number">1</span>; i++) {                <span class="hljs-keyword">int</span> min = i;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.size(); j++)                        <span class="hljs-keyword">if</span> (arr[j] &lt; arr[min])                                min = j;                <span class="hljs-built_in">std</span>::swap(arr[i], arr[min]);        }}</code></pre><h3 id=""></h3><h3 id="插入排序">插入排序</h3><p><img src="insertionSort.gif" alt="image-festival"></p><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] <span class="hljs-built_in">array</span>)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; <span class="hljs-built_in">array</span>.length;i++)    {        <span class="hljs-keyword">int</span> temp = <span class="hljs-built_in">array</span>[i];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;j &gt;= <span class="hljs-number">0</span>;j--)        {            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[j] &gt; temp)            {                <span class="hljs-built_in">array</span>[j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">array</span>[j];                <span class="hljs-built_in">array</span>[j] = temp;            }            <span class="hljs-keyword">else</span>                <span class="hljs-keyword">break</span>;        }    }}</code></pre><h3 id="-2"></h3><h3 id="希尔排序">希尔排序</h3><p><img src="shellsort.jpg" alt="image-festival"></p><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shell_sort</span><span class="hljs-params">(T <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> length)</span> </span>{    <span class="hljs-keyword">int</span> h = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (h &lt; length / <span class="hljs-number">3</span>) {        h = <span class="hljs-number">3</span> * h + <span class="hljs-number">1</span>;    }    <span class="hljs-keyword">while</span> (h &gt;= <span class="hljs-number">1</span>) {        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h; i &lt; length; i++) {            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt;= h &amp;&amp; <span class="hljs-built_in">array</span>[j] &lt; <span class="hljs-built_in">array</span>[j - h]; j -= h) {                <span class="hljs-built_in">std</span>::swap(<span class="hljs-built_in">array</span>[j], <span class="hljs-built_in">array</span>[j - h]);            }        }        h = h / <span class="hljs-number">3</span>;    }}</code></pre><h3 id="-3"></h3><h3 id="归并排序">归并排序</h3><p><img src="mergeSort.gif" alt="image-festival"></p><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(T arr[], <span class="hljs-keyword">int</span> len)</span> </span>{    T *a = arr;    T *b = <span class="hljs-keyword">new</span> T[len];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> seg = <span class="hljs-number">1</span>; seg &lt; len; seg += seg) {        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>; start &lt; len; start += seg + seg) {            <span class="hljs-keyword">int</span> low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);            <span class="hljs-keyword">int</span> k = low;            <span class="hljs-keyword">int</span> start1 = low, end1 = mid;            <span class="hljs-keyword">int</span> start2 = mid, end2 = high;            <span class="hljs-keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];            <span class="hljs-keyword">while</span> (start1 &lt; end1)                b[k++] = a[start1++];            <span class="hljs-keyword">while</span> (start2 &lt; end2)                b[k++] = a[start2++];        }        T *temp = a;        a = b;        b = temp;    }    <span class="hljs-keyword">if</span> (a != arr) {        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)            b[i] = a[i];        b = a;    }    <span class="hljs-keyword">delete</span>[] b;}</code></pre><h3 id="-4"></h3><h3 id="快速排序">快速排序</h3><p><img src="quickSort.gif" alt="image-festival"></p><p><strong>迭代法</strong></p><pre><code class="hljs c++"><span class="hljs-comment">// 参考：http://www.dutor.net/index.php/2011/04/recursive-iterative-quick-sort/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Range</span> {</span>    <span class="hljs-keyword">int</span> start, end;    Range(<span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> e = <span class="hljs-number">0</span>) {        start = s, end = e;    }};<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(T arr[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> len)</span> </span>{    <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span>;     Range r[len];    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;    r[p++] = Range(<span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);    <span class="hljs-keyword">while</span> (p) {        Range range = r[--p];        <span class="hljs-keyword">if</span> (range.start &gt;= range.end)            <span class="hljs-keyword">continue</span>;        T mid = arr[range.end];        <span class="hljs-keyword">int</span> left = range.start, right = range.end - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) {            <span class="hljs-keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right) left++;            <span class="hljs-keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right) right--;            <span class="hljs-built_in">std</span>::swap(arr[left], arr[right]);        }        <span class="hljs-keyword">if</span> (arr[left] &gt;= arr[range.end])            <span class="hljs-built_in">std</span>::swap(arr[left], arr[range.end]);        <span class="hljs-keyword">else</span>            left++;        r[p++] = Range(range.start, left - <span class="hljs-number">1</span>);        r[p++] = Range(left + <span class="hljs-number">1</span>, range.end);    }}</code></pre><p><strong>递归法</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort_recursive</span><span class="hljs-params">(T arr[], <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>{    <span class="hljs-keyword">if</span> (start &gt;= end)        <span class="hljs-keyword">return</span>;    T mid = arr[end];    <span class="hljs-keyword">int</span> left = start, right = end - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) { <span class="hljs-comment">//在整个范围内搜寻比枢纽元值小或大的元素，然后将左侧元素与右侧元素交换</span>        <span class="hljs-keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right) <span class="hljs-comment">//试图在左侧找到一个比枢纽元更大的元素</span>            left++;        <span class="hljs-keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right) <span class="hljs-comment">//试图在右侧找到一个比枢纽元更小的元素</span>            right--;        <span class="hljs-built_in">std</span>::swap(arr[left], arr[right]); <span class="hljs-comment">//交换元素</span>    }    <span class="hljs-keyword">if</span> (arr[left] &gt;= arr[end])        <span class="hljs-built_in">std</span>::swap(arr[left], arr[end]);    <span class="hljs-keyword">else</span>        left++;    quick_sort_recursive(arr, start, left - <span class="hljs-number">1</span>);    quick_sort_recursive(arr, left + <span class="hljs-number">1</span>, end);}<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(T arr[], <span class="hljs-keyword">int</span> len)</span> </span>{    quick_sort_recursive(arr, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);}</code></pre><h3 id="堆排序">堆排序</h3><p><img src="heapSort.gif" alt="heapSort"></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//堆调整</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">max_heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>{       <span class="hljs-keyword">int</span> dad = start;    <span class="hljs-keyword">int</span> son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (son &lt;= end) { <span class="hljs-comment">// 要求子节点在范围内</span>        <span class="hljs-keyword">if</span> (son + <span class="hljs-number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="hljs-number">1</span>]) <span class="hljs-comment">// 判断是否有另一个更大的子节点</span>            son++;        <span class="hljs-keyword">if</span> (arr[dad] &gt; arr[son]) <span class="hljs-comment">// 如果父节点最大，则不需要交换</span>            <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 交换父子位置后，进行子孙的比较</span>            swap(arr[dad], arr[son]);            dad = son;            son = son * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;        }    }}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> len)</span> </span>{    <span class="hljs-comment">//初始化，使初始数组变成大顶堆，时间复杂度为nlogn</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)        max_heapify(arr, i, len - <span class="hljs-number">1</span>);    <span class="hljs-comment">//将堆顶放到最后，然后再调节为大顶堆，复杂度也为nlogn</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) {        swap(arr[<span class="hljs-number">0</span>], arr[i]);        max_heapify(arr, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);    }}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-keyword">int</span> arr[] = { <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span> };    <span class="hljs-keyword">int</span> len = (<span class="hljs-keyword">int</span>) <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(*arr);    heap_sort(arr, len);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)        <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">' '</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><h3 id="计数排序">计数排序</h3><p>未完待续……</p><h3 id="桶排序">桶排序</h3><h3 id="基数排序">基数排序</h3><h3 id="参考资料">参考资料</h3><p>[1]https://www.runoob.com/w3cnote/ten-sorting-algorithm.html</p><p>[2]https://zhuanlan.zhihu.com/p/61488756</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFS——打开转盘锁</title>
    <link href="/Wuhlan3/2020/10/06/BFS%E2%80%94%E2%80%94%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/"/>
    <url>/Wuhlan3/2020/10/06/BFS%E2%80%94%E2%80%94%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="752-打开转盘锁"><a href="https://leetcode-cn.com/problems/open-the-lock/">752. 打开转盘锁</a></h2><h3 id="题意解析">题意解析</h3><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： <code>'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'</code> 。每个拨轮可以自由旋转：例如把 <code>'9'</code> 变为 <code>'0'</code>，<code>'0'</code> 变为 <code>'9'</code> 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 <code>'0000'</code> ，一个代表四个拨轮的数字的字符串。</p><p>列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串 <code>target</code> 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。</p><p><strong>示例 1:</strong></p><pre><code class="hljs clean">输入：deadends = [<span class="hljs-string">"0201"</span>,<span class="hljs-string">"0101"</span>,<span class="hljs-string">"0102"</span>,<span class="hljs-string">"1212"</span>,<span class="hljs-string">"2002"</span>], target = <span class="hljs-string">"0202"</span>输出：<span class="hljs-number">6</span>解释：可能的移动序列为 <span class="hljs-string">"0000"</span> -&gt; <span class="hljs-string">"1000"</span> -&gt; <span class="hljs-string">"1100"</span> -&gt; <span class="hljs-string">"1200"</span> -&gt; <span class="hljs-string">"1201"</span> -&gt; <span class="hljs-string">"1202"</span> -&gt; <span class="hljs-string">"0202"</span>。注意 <span class="hljs-string">"0000"</span> -&gt; <span class="hljs-string">"0001"</span> -&gt; <span class="hljs-string">"0002"</span> -&gt; <span class="hljs-string">"0102"</span> -&gt; <span class="hljs-string">"0202"</span> 这样的序列是不能解锁的，因为当拨动到 <span class="hljs-string">"0102"</span> 时这个锁就会被锁定。</code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs nix">输入: <span class="hljs-attr">deadends</span> = [<span class="hljs-string">"8888"</span>], <span class="hljs-attr">target</span> = <span class="hljs-string">"0009"</span>输出：<span class="hljs-number">1</span>解释：把最后一位反向旋转一次即可 <span class="hljs-string">"0000"</span> -&gt; <span class="hljs-string">"0009"</span>。</code></pre><p><strong>示例 3:</strong></p><pre><code class="hljs nix">输入: <span class="hljs-attr">deadends</span> = [<span class="hljs-string">"8887"</span>,<span class="hljs-string">"8889"</span>,<span class="hljs-string">"8878"</span>,<span class="hljs-string">"8898"</span>,<span class="hljs-string">"8788"</span>,<span class="hljs-string">"8988"</span>,<span class="hljs-string">"7888"</span>,<span class="hljs-string">"9888"</span>], <span class="hljs-attr">target</span> = <span class="hljs-string">"8888"</span>输出：-<span class="hljs-number">1</span>解释：无法旋转到目标数字且不被锁定。</code></pre><p><strong>示例 4:</strong></p><pre><code class="hljs nix">输入: <span class="hljs-attr">deadends</span> = [<span class="hljs-string">"0000"</span>], <span class="hljs-attr">target</span> = <span class="hljs-string">"8888"</span>输出：-<span class="hljs-number">1</span></code></pre><p><strong>提示：</strong></p><ol><li>死亡列表 <code>deadends</code> 的长度范围为 <code>[1, 500]</code>。</li><li>目标数字 <code>target</code> 不会在 <code>deadends</code> 之中。</li><li>每个 <code>deadends</code> 和 <code>target</code> 中的字符串的数字会在 10,000 个可能的情况 <code>'0000'</code> 到 <code>'9999'</code> 中产生。</li></ol><h3 id="解题思路">解题思路</h3><p>广度优先搜索，从“0000”开始，对每一位进行+1或-1（八种情况）然后入队，如果遇到死亡数字，则不再令他入队。当出现target时，返回步数。</p><h3 id="代码实现">代码实现</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unordered_set&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//锁+1 &amp;&amp; 需要考虑9重新变为0</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">plusnum</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str, <span class="hljs-keyword">int</span> index)</span></span>{    <span class="hljs-keyword">if</span>(str[index] == <span class="hljs-string">'9'</span>)        str[index] = <span class="hljs-string">'0'</span>;    <span class="hljs-keyword">else</span>        str[index] += <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> str;}<span class="hljs-comment">//锁-1 &amp;&amp; 需要考虑0重新变为9</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">minusnum</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str, <span class="hljs-keyword">int</span> index)</span></span>{    <span class="hljs-keyword">if</span>(str[index] == <span class="hljs-string">'0'</span>)         str[index] = <span class="hljs-string">'9'</span>;    <span class="hljs-keyword">else</span>        str[index] -= <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> str;} <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">openLock</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; deadends, <span class="hljs-built_in">string</span> target)</span></span>{    <span class="hljs-comment">//定义一个集合存放不能到达的数字，方便使用count来判断是否在集合中</span>    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; deadEnds;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; i: deadends)  <span class="hljs-comment">//遍历</span>        deadEnds.insert(i);    <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>;<span class="hljs-comment">//定义step记录当前步数</span>    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; visited; <span class="hljs-comment">//定义visited，记录已经到达过的数字</span>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-built_in">string</span>&gt; res;    res.push(<span class="hljs-string">"0000"</span>);    <span class="hljs-keyword">while</span>(!res.empty()){        <span class="hljs-keyword">int</span> size = res.size();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){            <span class="hljs-built_in">string</span> temp = res.front();            res.pop();            <span class="hljs-comment">//若为死亡数字，则抛弃后续路径</span>            <span class="hljs-keyword">if</span>(deadEnds.count(temp))                <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">//若为target。返回当前步数</span>            <span class="hljs-keyword">if</span>(temp == target)                <span class="hljs-keyword">return</span> step;            <span class="hljs-comment">//遍历八种情况，若没有访问过，就入队</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++){                <span class="hljs-built_in">string</span> up = plusnum(temp,j);                <span class="hljs-built_in">string</span> down = minusnum(temp,j);                  <span class="hljs-keyword">if</span>(!visited.count(up))                        {                            res.push(up);                            visited.insert(up);                        }                        <span class="hljs-keyword">if</span>(!visited.count(down))                        {                            res.push(down);                            visited.insert(down);                        }            }        }        ++step;<span class="hljs-comment">//每当把上一次的队列出完后，step+1</span>    }    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; }</code></pre><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{     <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; deadends;     <span class="hljs-keyword">int</span> num;     <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"deadends的数量:"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;     <span class="hljs-built_in">cin</span> &gt;&gt; num;<span class="hljs-comment">// deadends的数量</span>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++){         <span class="hljs-built_in">string</span> temp;         <span class="hljs-built_in">cin</span>&gt;&gt; temp;         deadends.push_back(temp);     }     <span class="hljs-built_in">string</span> target;     <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"target:"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;     <span class="hljs-built_in">cin</span> &gt;&gt; target ;     <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"至少需要"</span> &lt;&lt; openLock(deadends, target) &lt;&lt; <span class="hljs-string">"次"</span> &lt;&lt; <span class="hljs-built_in">endl</span>; }</code></pre><h3 id="参考资料">参考资料</h3><p>[1]https://leetcode-cn.com/problems/open-the-lock/solution/czhi-nan-shen-mei-de-yan-du-you-xian-sou-suo-by-go/</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFS——小岛数量（二）</title>
    <link href="/Wuhlan3/2020/10/05/BFS%E2%80%94%E2%80%94%E5%B0%8F%E5%B2%9B%E6%95%B0%E9%87%8F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/Wuhlan3/2020/10/05/BFS%E2%80%94%E2%80%94%E5%B0%8F%E5%B2%9B%E6%95%B0%E9%87%8F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="BFS——小岛数量（二）">BFS——小岛数量（二）</h2><h3 id="题意解析">题意解析</h3><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong></p><pre><code class="hljs scheme">[[<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'0</span>'],[<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'0</span>'],[<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>'],[<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>']]</code></pre><p><strong>输出: 1</strong></p><p><strong>示例 2:</strong></p><p><strong>输入:</strong></p><pre><code class="hljs scheme">[[<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>'],[<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>'],[<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>'],[<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'1</span>']]</code></pre><p><strong>输出: 3</strong><br>解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</p><h3 id="解题思路">解题思路</h3><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则将其加入队列，开始进行广度优先搜索。在广度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0。直到队列为空，搜索结束。</p><p>最终岛屿的数量就是我们进行广度优先搜索的次数。</p><h3 id="代码实现">代码实现</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; grid)</span> </span>{        <span class="hljs-keyword">int</span> nr = grid.size();      <span class="hljs-comment">//行数</span>        <span class="hljs-keyword">if</span>(nr == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> nc = grid[<span class="hljs-number">0</span>].size();   <span class="hljs-comment">//列数</span>        <span class="hljs-keyword">int</span> num_islands = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; nr; r++){            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; nc; c++){                <span class="hljs-comment">// 如果 遍历到某个位置为‘1’， 就进行广度优先搜索（BFS）</span>                <span class="hljs-keyword">if</span>(grid[r][c] == <span class="hljs-string">'1'</span>){                    ++num_islands;                    grid[r][c] = <span class="hljs-string">'0'</span>;                    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; neighbors;    <span class="hljs-comment">//定义一个存放位置的队列</span>                    neighbors.push({r, c});             <span class="hljs-comment">//放入当前的位置</span>                    <span class="hljs-keyword">while</span>(!neighbors.empty()){                        <span class="hljs-keyword">auto</span> rc = neighbors.front();       <span class="hljs-comment">// 取队列头</span>                        neighbors.pop();                    <span class="hljs-comment">// 弹出队列头</span>                        <span class="hljs-keyword">int</span> row = rc.first, col = rc.second;                            <span class="hljs-comment">//对相邻位置进行判断，如果是1，就加入队列</span>                        <span class="hljs-keyword">if</span>(row - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[row<span class="hljs-number">-1</span>][col] == <span class="hljs-string">'1'</span>){                            neighbors.push({row - <span class="hljs-number">1</span>, col});                            grid[row - <span class="hljs-number">1</span>][col] = <span class="hljs-string">'0'</span>;                        }                        <span class="hljs-keyword">if</span>(row + <span class="hljs-number">1</span> &lt; nr &amp;&amp; grid[row+<span class="hljs-number">1</span>][col] == <span class="hljs-string">'1'</span>){                            neighbors.push({row + <span class="hljs-number">1</span>, col});                            grid[row + <span class="hljs-number">1</span>][col] = <span class="hljs-string">'0'</span>;                        }                        <span class="hljs-keyword">if</span>(col <span class="hljs-number">-1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[row][col <span class="hljs-number">-1</span> ] == <span class="hljs-string">'1'</span>){                            neighbors.push({row, col - <span class="hljs-number">1</span>});                            grid[row][col - <span class="hljs-number">1</span>] = <span class="hljs-string">'0'</span>;                        }                        <span class="hljs-keyword">if</span> (col + <span class="hljs-number">1</span> &lt; nc &amp;&amp; grid[row][col+<span class="hljs-number">1</span>] == <span class="hljs-string">'1'</span>){                            neighbors.push({row, col + <span class="hljs-number">1</span>});                            grid[row][col + <span class="hljs-number">1</span>] = <span class="hljs-string">'0'</span>;                        }                    }                }            }        }        <span class="hljs-keyword">return</span> num_islands;    }</code></pre><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; &gt; grid;    <span class="hljs-keyword">int</span> row;    <span class="hljs-keyword">int</span> col;    <span class="hljs-built_in">cin</span> &gt;&gt; row &gt;&gt; col;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; row; ++r){        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; temp;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; col; ++c){            <span class="hljs-keyword">char</span> num;            <span class="hljs-built_in">cin</span> &gt;&gt; num;            temp.push_back(num);        }        grid.push_back(temp);    }        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"岛屿数量为"</span> &lt;&lt; numIslands(grid);}</code></pre><h3 id="参考资料">参考资料</h3><p>[1]https://leetcode-cn.com/problems/number-of-islands</p><p>[2]https://leetcode-cn.com/problems/number-of-islands/solution/po-shi-wu-hua-de-shen-du-you-xian-bian-li-by-shang/</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DFS——小岛数量（一）</title>
    <link href="/Wuhlan3/2020/10/04/DFS%E2%80%94%E2%80%94%E5%B0%8F%E5%B2%9B%E6%95%B0%E9%87%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/Wuhlan3/2020/10/04/DFS%E2%80%94%E2%80%94%E5%B0%8F%E5%B2%9B%E6%95%B0%E9%87%8F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="DFS——小岛数量（一）">DFS——小岛数量（一）</h2><h3 id="题意解析">题意解析</h3><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong></p><pre><code class="hljs scheme">[[<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'0</span>'],[<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'0</span>'],[<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>'],[<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>']]</code></pre><p><strong>输出: 1</strong></p><p><strong>示例 2:</strong></p><p><strong>输入:</strong></p><pre><code class="hljs scheme">[[<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>'],[<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>'],[<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>'],[<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'0</span>',<span class="hljs-symbol">'1</span>',<span class="hljs-symbol">'1</span>']]</code></pre><p><strong>输出: 3</strong><br>解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</p><h3 id="解题思路">解题思路</h3><p>深度优先遍历<br>1.遍历整个数组，遇到1，num_islands++，num_islands是记录岛的个数的<br>2.运行一下dfs函数，把这个岛所有陆地给我沉喽，这个岛全部的1变成0<br>3.等把grid全遍历完，grid就全是0了，再把num_islands输出，这个num_islands就是我们记录的岛的个数<br>注意：grid竟然是char类型的，所有1和0都要加单引号哦</p><h3 id="代码实现">代码实现</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">// 深度优先搜索，其中 row,col对应递归所到的位置</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; &amp;grid, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">int</span> rowsize = grid.size();    <span class="hljs-keyword">int</span> colsize = grid[<span class="hljs-number">0</span>].size();    grid[row][col] = <span class="hljs-string">'0'</span>; <span class="hljs-comment">//用以标记已经判断过</span>    <span class="hljs-keyword">if</span> (row - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[row - <span class="hljs-number">1</span>][col] == <span class="hljs-string">'1'</span>)        dfs(grid, row - <span class="hljs-number">1</span>, col);    <span class="hljs-keyword">if</span> (row + <span class="hljs-number">1</span> &lt; rowsize &amp;&amp; grid[row + <span class="hljs-number">1</span>][col] == <span class="hljs-string">'1'</span>)        dfs(grid, row + <span class="hljs-number">1</span>, col);    <span class="hljs-keyword">if</span> (col - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[row][col - <span class="hljs-number">1</span>] == <span class="hljs-string">'1'</span>)        dfs(grid, row, col - <span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (col + <span class="hljs-number">1</span> &lt; colsize &amp;&amp; grid[row][col + <span class="hljs-number">1</span>] == <span class="hljs-string">'1'</span>)        dfs(grid, row, col + <span class="hljs-number">1</span>);    }<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; grid)</span> </span>{    <span class="hljs-keyword">int</span> rowsize = grid.size();    <span class="hljs-keyword">if</span>(rowsize == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> colsize = grid[<span class="hljs-number">0</span>].size();        <span class="hljs-keyword">int</span> num_islands = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r&lt; rowsize; r++){        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c&lt; colsize; c++){            <span class="hljs-keyword">if</span>(grid[r][c] == <span class="hljs-string">'1'</span>){                ++num_islands; <span class="hljs-comment">//发现1， 岛屿数量+1 ， 并且把岛屿所有的地方通过深度搜索遍历出来</span>                dfs(grid, r, c);            }        }    }            <span class="hljs-keyword">return</span> num_islands;} </code></pre><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; &gt; grid;    <span class="hljs-keyword">int</span> row;    <span class="hljs-keyword">int</span> col;    <span class="hljs-built_in">cin</span> &gt;&gt; row &gt;&gt; col;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; row; ++r){        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; temp;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; col; ++c){            <span class="hljs-keyword">char</span> num;            <span class="hljs-built_in">cin</span> &gt;&gt; num;            temp.push_back(num);        }        grid.push_back(temp);    }        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"岛屿数量为"</span> &lt;&lt; numIslands(grid);}</code></pre><h3 id="参考资料">参考资料</h3><p>[1]https://leetcode-cn.com/problems/number-of-islands</p><p>[2]https://leetcode-cn.com/problems/number-of-islands/solution/po-shi-wu-hua-de-shen-du-you-xian-bian-li-by-shang/</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>过节</title>
    <link href="/Wuhlan3/2020/09/29/%E8%BF%87%E8%8A%82/"/>
    <url>/Wuhlan3/2020/09/29/%E8%BF%87%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<center><h4>过节</h4></center><center>北岛</center><center>毒蛇炫耀口中的钉子</center><center>大地有著毒蛇</center><center>吞吃鸟蛋的寂静</center><center>所有钟表</center><center>停止在无梦的时刻</center><center>丰收聚敛着</center><center>田野死后的笑容</center><center>从水银的镜子</center><center>影像成双的人们</center><center>乘家庭的轮子</center><center>去集市</center><center>一位本地英雄</center><center>在废弃的停车场上</center><center>唱歌</center><center>玻璃晴朗</center><center>橘子辉煌</center><p><img src="festival.jpg" alt="image-festival"></p><h4 id="第一次">第一次</h4><p>​        看到她的名字，好奇地搜了一下，仅仅是看到“玻璃晴朗，橘子辉煌”两句。对于将两组名词和形容词毫不相关地搭配在一起，顿时觉得有趣。联想到的是，金色的秋天，万里无云的天空泛着清澈的蓝色。阳光穿透玻璃，房间里瞬间明朗起来，桌子上的橘子因阳光闪耀着金黄色。这是<strong>秋天收获的喜悦</strong>，这是<strong>生活的恬淡闲适</strong>，这是<strong>最朴实无华的事物散发出最耀眼的光芒</strong>。</p><h4 id="第二次">第二次</h4><p>​        偶然的机会，再次阅读。发现除了末尾两句外，描写的都是负面的事物。“毒蛇”、“钉子”、“寂静”、“无梦”、“死后”、“废弃”…… 理解能力有限的我，打开知乎看各种点评。标题是《过节》，这是张灯结彩、阖家欢乐的日子。然而，人们仅仅顾着庆祝节日，却忘记了为丰收做出贡献的田野，任由毒蛇的糟蹋，田野只能笑着死去。收获颇丰的人们成群结队地往集市赶去，然而真正的英雄却只能独自一人在废弃的停车场唱歌。透过玻璃看向窗外，一切还是那么晴朗，橘子在外皮的包裹下也依旧辉煌夺目。整首诗构造了一种<strong>表面欢快热闹</strong>、而<strong>背面是被废弃被遗忘的沉寂</strong>。结尾二句，用格外绚丽的色彩，与上文形成对比，更加具有讽刺意味。更有甚者，认为作者将玻璃比作天空，将橘子比作太阳。一切皆为虚幻。</p><h4 id="第三次">第三次</h4><p>​        我一度为大家的偏阴郁的解读而感到难过。毕竟我最先读到的仅仅是“玻璃晴朗，橘子辉煌”二句。思考良久后，我转念一想，诗人在他创作出这样的诗歌，肯定会与他的时代背景、个人经历相联系。但是，当他的诗作为作品广为流传以后，便不再是他的诗了。或许我的想法不够成熟老练，但在这一刻我确实有赋予专属于我自己的理解的权利。光明的背后自然离开不了黑暗，但又凭什么说，我们所看到的光明是就不是真实的呢？我希望做一个极致的“乐观的悲观主义者”，如罗曼罗兰所说的那样"<strong>世界上只有一种真正的英雄主义,那就是认清生活的真相后还依然热爱生活</strong>"；我更愿化身为阻隔阴霾的玻璃，经过过滤的阳光照耀在橘子上，“橘子辉煌”，如常。</p>]]></content>
    
    
    
    <tags>
      
      <tag>不务正业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯——八皇后</title>
    <link href="/Wuhlan3/2020/09/29/%E5%9B%9E%E6%BA%AF-%E5%85%AB%E7%9A%87%E5%90%8E/"/>
    <url>/Wuhlan3/2020/09/29/%E5%9B%9E%E6%BA%AF-%E5%85%AB%E7%9A%87%E5%90%8E/</url>
    
    <content type="html"><![CDATA[<h2 id="回溯——八皇后">回溯——八皇后</h2><h3 id="题意解析">题意解析</h3><p><strong>八皇后问题</strong>（英文：Eight queens），是由国际西洋棋棋手马克斯·贝瑟尔于1848年提出的问题，是==回溯算法==的典型案例。<br>问题表述为：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。如果经过±90度、±180度旋转，和对角线对称变换的摆法看成一类，共有42类。计算机发明后，有多种计算机语言可以编程解决此问题。</p><h3 id="解题思路">解题思路</h3><p><strong>二、如何解决八皇后问题？</strong></p><p>所谓递归回溯，本质上是一种枚举法。（我们更愿意称之为“有技巧的枚举”）这种方法从棋盘的第一行开始尝试摆放第一个皇后，摆放成功后，递归一层，再遵循规则在棋盘第二行来摆放第二个皇后。如果当前位置无法摆放，则向右移动一格再次尝试，如果摆放成功，则继续递归一层，摆放第三个皇后…</p><p>如果某一层看遍了所有格子，都无法成功摆放，则回溯到上一个皇后，让上一个皇后右移一格，再进行递归。如果八个皇后都摆放完毕且符合规则，那么就得到了其中一种正确的解法。说起来有些抽象，我们来看一看递归回溯的详细过程。</p><p>1.<strong>第一层</strong>递归，尝试在<strong>第一行</strong>摆放<strong>第一个皇后</strong>：</p><p><img src="1.png" alt="img"></p><p>2.<strong>第二层</strong>递归，尝试在<strong>第二行</strong>摆放<strong>第二个皇后</strong>（前两格被第一个皇后封锁，只能落在第三格）：</p><p><img src="2.png" alt="img"></p><p>3.<strong>第三层</strong>递归，尝试在<strong>第三行</strong>摆放<strong>第三个皇后</strong>（前四格被第一第二个皇后封锁，只能落在第五格）：</p><p><img src="3.png" alt="img"></p><p>4.<strong>第四层</strong>递归，尝试在<strong>第四行</strong>摆放<strong>第四个皇后</strong>（第一格被第二个皇后封锁，只能落在第二格）：</p><p><img src="4.png" alt="img"></p><p>5.<strong>第五层</strong>递归，尝试在<strong>第五行</strong>摆放<strong>第五个皇后</strong>（前三格被前面的皇后封锁，只能落在第四格）：</p><p><img src="5.png" alt="img"></p><p>6.由于所有格子都“绿了”，第六行已经没办法摆放皇后，于是进行回溯，重新摆放<strong>第五个皇后</strong>到<strong>第八格</strong>。：</p><p><img src="6.png" alt="img"></p><p>7.第六行仍然没有办法摆放皇后，第五行也已经尝试遍了，于是回溯到<strong>第四行</strong>，重新摆放<strong>第四个皇后</strong>到<strong>第七格</strong>。：</p><p><img src="7.png" alt="img"></p><p>8.继续摆放第五个皇后，以此类推…</p><h3 id="代码实现">代码实现</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ArSize = <span class="hljs-number">8</span>;<span class="hljs-comment">//这个数等于几，就是几皇后。</span><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> arr[ArSize][ArSize], <span class="hljs-keyword">int</span> row)</span></span>;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> arr[ArSize][ArSize], <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> column)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">outPut</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> arr[ArSize][ArSize])</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">bool</span> chessboard[ArSize][ArSize];    <span class="hljs-comment">// 数组初始化</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : chessboard)    {        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;j : i)        {            j = <span class="hljs-literal">false</span>;        }    }    solve(chessboard, <span class="hljs-number">0</span>);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"八皇后问题共有"</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">"种解！"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><pre><code class="hljs c++"><span class="hljs-comment">// 回溯法</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> arr[ArSize][ArSize], <span class="hljs-keyword">int</span> row)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> column = <span class="hljs-number">0</span>; column &lt; ArSize; ++column)    {        arr[row][column] = <span class="hljs-literal">true</span>;        <span class="hljs-comment">//在确定的某一行，遍历每一列放下棋子</span>        <span class="hljs-keyword">if</span> (check(arr, row, column))    <span class="hljs-comment">//满足条件：1.继续在下一行放下棋子；2.如果是最后一行，输出矩阵</span>        {            <span class="hljs-keyword">if</span> (row + <span class="hljs-number">1</span> == ArSize)            {                outPut(arr);            }            <span class="hljs-keyword">else</span>            {                solve(arr, row + <span class="hljs-number">1</span>);            }        }        arr[row][column] = <span class="hljs-literal">false</span>;    }}<span class="hljs-comment">// 判断皇后的落点是否合规</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> arr[ArSize][ArSize], <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> column)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">if</span> (row == <span class="hljs-number">0</span>)    {        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//第一行不需要判断</span>    }    <span class="hljs-keyword">int</span> i, j;    <span class="hljs-comment">// 判断纵向是否有冲突</span>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; row; ++i)    {        <span class="hljs-keyword">if</span> (arr[i][column])        {            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        }    }    i = row - <span class="hljs-number">1</span>;    j = column - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 判断正斜对角线是否有冲突</span>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>)    {        <span class="hljs-keyword">if</span> (arr[i][j])        {            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        }        --i;        --j;    }    i = row - <span class="hljs-number">1</span>;    j = column + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 判断负斜对角线是否有冲突</span>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt;= ArSize - <span class="hljs-number">1</span>)    {        <span class="hljs-keyword">if</span> (arr[i][j])        {            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        }        --i;        ++j;    }    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;}<span class="hljs-comment">// 打印每种正确的解法</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">outPut</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> arr[ArSize][ArSize])</span></span><span class="hljs-function"></span>{    ++num;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"**********************"</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">"*********************"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ArSize; ++i)    {        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; ArSize; ++j)        {            <span class="hljs-built_in">cout</span> &lt;&lt; arr[i][j] &lt;&lt; <span class="hljs-string">" "</span>;        }        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    }    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"*********************************************"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;}</code></pre><h3 id="参考资料">参考资料</h3><p>[1]https://www.cnblogs.com/smile233/p/8483729.html</p><p>[2]https://baike.baidu.com/item/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my_first_article</title>
    <link href="/Wuhlan3/2020/09/27/my-first-article/"/>
    <url>/Wuhlan3/2020/09/27/my-first-article/</url>
    
    <content type="html"><![CDATA[<p>嘻嘻，博客搭建成功！！！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/Wuhlan3/2020/09/27/hello-world/"/>
    <url>/Wuhlan3/2020/09/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
